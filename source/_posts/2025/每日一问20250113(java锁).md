# java 锁(Lock)





## 类型

**内置锁（Synchronized 关键字）**

Synchronized  具有可重入性

java 最基本的同步机制，它可以修饰方法或者代码块，

对象锁: 当修饰对象中非静态方法，则是对象锁，锁会作用于该对象

类锁: 当修饰静态方法，则是类锁，锁会作用于整个类

**显式锁（java.util.concurrent.locks 包）**

lock接口和  reentrantLock类 

lock接口提供了比Synchronized 更灵活的锁机制，它定义了基本的锁操作(获取锁lock，释放锁unlock)

reentrantLock类是 lock接口的一个实现类，具有可重入性



读锁和写锁的区别:

读锁: 多个线程可以同时获取到读锁，当遇到写操作才阻塞，不能被其他线程获取到；

写锁(排他锁): 当一个线程获取了锁，其他线程无论是读操作还是写操作都阻塞。



锁的公平性:

对于`ReentrantLock`和`ReentrantReadWriteLock`,可以设置为公平锁或非公平锁，公平锁就是当多个线程尝试获取锁，是按请求锁的顺序来分配锁的，非公平锁则是新线程和等待的线程一起争抢锁。

注: 非公平锁更适用于高并发场景，因为减少了线程唤醒的次数，但有可能产生饥饿现象即某些等待线程一直获取不到锁，可通过其他方式来解决优化饥饿现象。



#### 以ReentrantLock为例锁获取过程

非公平锁获取过程:

首先要知道AQS是一个抽象线程队列同步器，当一个线程释放锁，新来的线程和队列同步器里的线程同时争抢锁，通过一个

公平锁获取过程:





## 字段解释

可重入(Reentrant): 意味着一个线程可以重复的获取到同一个锁，