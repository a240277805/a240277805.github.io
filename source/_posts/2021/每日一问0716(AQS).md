---
title:
---
# AQS （AbstractQueuedSynchronizer）

## 啥是AQS

- AQS 是 AbstractQueuedSynchronizer  的缩写
- AbstractQueuedSynchronizer 是一个抽象类
- AbstractQueued[Sync](https://so.csdn.net/so/search?q=Sync)hronizer类继承AbstractOwnableSynchronizer
- 其有2个内部类，分别为Node和ConditionObject
- 有一个int 成员变量 表示同步状态，保证该成员变量的可见性 （voletile）
- - Node  是队列同步其中的组成类，是放线程队列**CLH（FIFO）队列**（双向链表）的一个节点，
- 有一个实现类 ，Sync ;Sync 来实现加锁逻辑

- 

## 实现 锁需要具备以下几个核心要素

① 需要一个state变量，标记该锁的状态。state变量至少有两个值：0、1。对state变量的操作，要确保线程安全，也就是会用到CAS。

② 需要记录当前是哪个线程持有锁。

③ 需要底层支持对一个线程进行阻塞或唤醒操作。

④ 需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到CAS。

==实现依赖：==

- State  是 int 4个字节 32位；它是多线程可见的； 可以分为高16位，低16位，用来区分读写锁，一般写锁用一位(最多一个线程获取写锁),读锁 看自己实现 （可获取多把读锁） exclusiveOwnerThread=该线程

- 针对要素③，在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是==park/unpark==。有一个LockSupport的工具类，对这一对原语做了简单封装
- CAS 操作

## 锁

Syncronized重入的实现原理
任意一把Syncronized锁对象，使用java -c xx.class 编译以后会产生两个指令monitorEnter和monitorExit，这两个指令代表锁的获取和锁的释放，多出来的monitorExit是程序异常的时候，可以正常的释放锁。
每个锁对象拥有一个锁计数器和一个指向持有该锁的线程指针当执行moniterenter时，如果目标锁对象的计数器为零，那么说明他没有被其他线程持有，java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1，在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么java虚拟机计数器可以加1否则需要等待，直至持有线程释放锁。当执行monitorexit时，java虚拟机则将锁对象的计数器减1，计数器为0说明锁已经释放
ReentrantLock可重入锁实现原理
实现加锁次数和释放锁次数不一致由于加锁次数和释放锁次数不一致，第二个线程始终无法获取到锁，导致一直等待正常情况下，加锁几次就要解锁几次.
ReentrantLock锁少释放的问题： 导致其他线程获取不到锁，程序会一直阻塞







#### AQS作用

- 加锁会导致阻塞，有阻塞就会排队，实现排队必然需要有某种形式的队列来进行管理

#### AQS的原理

AQS为实现阻塞锁，**依赖先进先出的一个等待依靠一个原子int值来表示状态**，通过占用和释放方法，改变状态值AQS使用一个volatile的int类型的成员变量来表示同步状态，**通过内置的FIFO队列来表示完成获取资源的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配**，通过CAS完成对State值得修改

#### AQS的变量

- state变量： 判断是否阻塞
  - 阻塞需要排队（前提：自旋如果达到一定时间），实现排队必须需要队列
- Node节点的变量
  - 队列中每个队列的个体也就是Node



###  Condition

condition 是 lock 的内部类， condition 必须和lock 一起使用，

功能：定义线程阻塞 唤醒的条件

java.util.concurrent.locks.Condition是JUC提供的与Java的Object中wait/notify/notifyAll类似功能的一个接口，通过此接口，==线程可以在某个特定的条件下等待/唤醒。==

**此外一把互斥锁可以绑定多个Condition，这意味着在同一把互斥锁上竞争的线程可以在不同的条件下等待，唤醒时可以根据条件来唤醒线程，这是Object中的wait/notify/notifyAll不具备的机制**

JUC中Condition接口的主要实现类是AQS的内部类ConditionObject，它内部维护了一个队列，我们可以称之为==条件队列==(有点像规则引擎)，在某个Condition上等待的线程被signal/signalAll后，ConditionObject会将对应的节点转移到外部类AQS的等待队列中，线程需要获取到AQS等待队列的锁，才可以继续恢复执行后续的用户代码。

ConditionObject的firstWaiter/lastWaiter以及AQS.Node的nextWaiter都是没有volatile修饰的。这是因为ConditionObject假设在await/signal/signalAll等方法的调用是已经持有互斥锁的。



最简单的处理方式是，对于不持锁的请求抛出异常，不应该依靠await -> fullyRelease这一步来抛出异常，此时按照流程已经调用过addConditionWaiter了。可以在await这类方法前面与signal/signalAll一样预检查一次持锁情况:

## 参考

[深入理解 AQS 底层实现原理](https://blog.csdn.net/weixin_44624375/article/details/110133306)