<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/19/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020/每日一问0516(zookeeper)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0516(zookeeper)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0516(zookeeper)/">每日一问0516(zookeeper)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式协调zookeeper"><a href="#分布式协调zookeeper" class="headerlink" title="分布式协调zookeeper"></a>分布式协调zookeeper</h1><p>PAC：分区容错性，可用性，一致性<br>产生背景、数据模型、基本架构、程序设计以及应用案例 避免 <code>脑裂</code><br><code>脑裂:本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源，结果会导致系统混乱，数据损坏。</code></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>多叉二叉树，每个节点叫ZNode</p>
<p>node可以分为持久节点、临时节点两类</p>
<p><em>临时节点生命周期与会话绑定，一旦客户端会话失效，所有该会话创建的临时节点都会被移除。</em></p>
<p>另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>
<p>组成:</p>
<ul>
<li>data: 数据域</li>
<li>type:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. persistent：持久化节点</span><br><span class="line">2.ephemeral：临时节点</span><br><span class="line">3.sequential：自增节点，自动在文件名默认追加一个增量的唯一数字</span><br></pre></td></tr></table></figure></li>
<li>version: 数据版本号<code>Stat</code>的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）</li>
<li>children: ZNode 可以有子节点，但不允许临时节点有子节点</li>
<li>ACL：访问控制列表，可以单独设置每个znode 的可访问用户列表。</li>
</ul>
<h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><p>订阅发布机制，一旦触发便被删除</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>客户端与其中一个zk的 TCP长连接,通过心跳检测维持<br>作用：</p>
<ul>
<li>维持有效的会话</li>
<li>可以向zk服务器发送请求并接受响应</li>
<li>通过该连接接收来自服务端的watcher 实践通知。</li>
</ul>
<p>只要sessionTimeOut 未过期，各种原因导致连接断后重连 ，之前的会话仍然有效</p>
<p>创建session流程</p>
<p><img src="/../../ImgSource/zk_session_create.png" alt="avatar"></p>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>不同于 paxos,是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。<br>具体：zookeeper 使用一种单一的主进程来接收并处理来自客户端的所有事务请求，并采用ZAB原子广播协议，将服务器状态的变更以proposal的形式广播到所有副本进程上去。</p>
<p><img src="/../../ImgSource/ZAB.png" alt="avatar"><br>两种模式：</p>
<ul>
<li>崩溃恢复 （leader中断）</li>
<li>消息广播</li>
</ul>
<h3 id="广播消息步骤"><a href="#广播消息步骤" class="headerlink" title="广播消息步骤"></a>广播消息步骤</h3><p><img src="/../../ImgSource/ZK-guangbo.png" alt="avatar"></p>
<ol>
<li>follower 接收到事务消息，转发给leader</li>
<li>leader 生成唯一的全局单调递增的<code>ZXID</code></li>
<li>leader 为所有follower 分配一个单独的队列，然后将事务放到队列，并根据FIFO发送</li>
<li>follower 接收到后写入日志并持久化到磁盘，然后反馈给leader ACK</li>
<li>leader 收到过半 follwer ACK 则广播 commit 消息给所有 follower</li>
<li>leader 和收到消息的follower 完成事务的提交。</li>
</ol>
<h2 id="leader-选举"><a href="#leader-选举" class="headerlink" title="leader 选举"></a>leader 选举</h2><p>选举分为刚启动时选举和服务中leader中断或过半失去响应进入选举状态。</p>
<p><img src="/../../ImgSource/zk_leader_xuanju.png" alt="avatar"></p>
<h3 id="启动时选举"><a href="#启动时选举" class="headerlink" title="启动时选举"></a>启动时选举</h3><p>1.每个Server会发出一个投票</p>
<p>   由于是初始情况，第一轮都将自己作为leader投票。投票内容 （myid,ZXID），将投票结果发送给集群中其他所有机器。</p>
<p>2.接收来自各个服务器的投票。 </p>
<p> 首先会检查投票的有效性，包括检查是否是本轮投票，是否来自LOOKING状态的服务器。</p>
<p>3.处理投票</p>
<p>接收到个每一个投票，都需要和自己的投票进行PK。 PK规则如下</p>
<ul>
<li>优先检查 ZXID，ZXID大的优先作为Leader。</li>
<li>如果ZXID相同，那么比较myid,myid 较大的作为leader.</li>
</ul>
<p>问题：怎么来确定是第几轮投票。是收到过半服务器投票就开始下一轮，还是每收到一次投票比较后就发送这个投票结果？</p>
<p>结果找到了:</p>
<p><img src="/../../ImgSource/zk_leader_xuanjulunci.png" alt="avatar"></p>
<p>即由于是TCP连接，收到一轮投票后，再进行判断；这个时候需要收到其余所有Follower 投票而不是个过半。</p>
<p>4.统计投票</p>
<p>每次投票后，服务器都会统计所有投票，判断是否有过半机器接收到相同的投票信息。</p>
<p>5.改变服务器状态</p>
<p>一旦确定了Leader，每个服务器就会更新自己的状态：如果是Follower变更为FOLLOWING，如果是Leader变更为LEADING</p>
<h3 id="服务器于行期间Leader选举"><a href="#服务器于行期间Leader选举" class="headerlink" title="服务器于行期间Leader选举"></a>服务器于行期间Leader选举</h3><p>leader挂了会进入恢复模式，进行Leader选举。 过程和启动时选举一样。</p>
<h3 id="Leader选举算法分析"><a href="#Leader选举算法分析" class="headerlink" title="Leader选举算法分析"></a>Leader选举算法分析</h3><p>Zookeeper中提供了三种选举算法，LeaderElection（0）、UDP版本的FastLeaderElection（1）、TCP版本的FastLeaderElection（2）。 可以通过配置文件zoo.cfg中使用electionAlg属性指定。0-3表示<br><code>从 3.4。0版本开始，废除了0,1算法，只保留了TCP版本的FastLeaderElection</code></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h2 id="zk-运维"><a href="#zk-运维" class="headerlink" title="zk 运维"></a>zk 运维</h2><h3 id="通过Jconsole-连接Zookeeper"><a href="#通过Jconsole-连接Zookeeper" class="headerlink" title="通过Jconsole 连接Zookeeper"></a>通过Jconsole 连接Zookeeper</h3><p><img src="/../../ImgSource/zk_JConsole_connect.png" alt="avatar"><br>可以监控 内存，线程</p>
<h3 id="读写TPS监控"><a href="#读写TPS监控" class="headerlink" title="读写TPS监控"></a>读写TPS监控</h3><p>通过TaobaoKeeper可以看到每台ZK服务器的读写TPS详情。包括连接的创建断开、数据节点的创建与删除、数据节点内容的读取预更新和子节点列表等。</p>
<h3 id="数据与日志管理"><a href="#数据与日志管理" class="headerlink" title="数据与日志管理"></a>数据与日志管理</h3><p>zk服务器会有dataDir 和dataLogDir两个目录，分别用于存储快照数据和事务日志。正常运行过程中，会不断的输出日志，需要人为清理。</p>
<ul>
<li>通过脚本清理</li>
<li>使用清理工具 PurgeTxnLog</li>
<li>自动清理 再3.4.0版本开始 提供了自动清理机制 ，需要配置autopurge.snapRetainCount 和 autopurge.purgeInterval 两个参数来实现定时清理。</li>
</ul>
<h3 id="Too-many-connections"><a href="#Too-many-connections" class="headerlink" title="Too many connections"></a>Too many connections</h3><p>maxClientCnxns 参数用于设置语序单个客户端创建的最大连接数。如果超过了，超过的部分会被拒绝连接。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="zookeeper-和-eureka-有什么区别"><a href="#zookeeper-和-eureka-有什么区别" class="headerlink" title="zookeeper 和 eureka 有什么区别"></a>zookeeper 和 eureka 有什么区别</h3><p>作为注册中心来说 基于CAP原则（数据一致性，可用性，分区容错性），<br>ZK是保证CP，euraka 保证AP<br>ZK是由leader 选举 ，下发事务请求，保证数据的一致性。ZK在leader 宕机或进行扩容的时候不能对外提供服务，这个时候对有些系统来说是影响非常大的。<br>eurka 多台是 同等级的，挂了一个，通过他的负载均衡算法，另外的可以正常提供服务。另外还有心跳检测。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69246172">从Paxos到Zookeeper</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0516(zookeeper)/" data-id="cld1bs9t0001cfynhduj75a1m" data-title="每日一问0516(zookeeper)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0520(dubbo)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0520(dubbo)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0520(dubbo)/">每日一问0520(dubbo)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p>Dobbo 服务调用过程</p>
<ul>
<li>服务提供方(Provider)所在的应用在容器中启动并运行</li>
<li>服务 提供方(Provider)将自己要发布的服务注册到注册中心(Registry)</li>
<li>服务调用方(Consumer)启动后想注册中心订阅它想要调用的服务</li>
<li>注册中心(registry)存储着Provider注册的远程服务，并将其所管理的服务列表通知给服务调用方(Consumer)，且注册中心和提供方和调用方之间均保持长连接，可以获取Provider发布的服务的变化情况，并将最新的服务列表推送给Consumer</li>
<li>Consumer根据从注册中心获得的服务列表，根据软负载均衡算法选择一个服务提供者（provider）进行远程服务调用，如果调用失败则选择另一台进行调用。（COnsumer会缓存服务列表，及时注册中心宕机也不妨碍进行远程服务调用）</li>
<li>监控中心(Monitor)对服务的发布和订阅进行监控和统计服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心(Monitor)；Monitor可以选择Zookeeper、Redis或者Multiast注册中心等，</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>缓存如何更新</li>
<li>怎么集成netty</li>
<li>一个请求的整个过程</li>
<li>坑</li>
<li>用到的模块</li>
<li>和zk的交互</li>
<li>Consumer 的负载均衡怎么做的</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200301232431652.jpg" alt="avatar"> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/introduction/">Dubbo3 简介</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0520(dubbo)/" data-id="cld1bs9t0001dfynh9jie9nx9" data-title="每日一问0520(dubbo)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0521(SpringAOP)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0521(SpringAOP)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0521(SpringAOP)/">每日一问0521(SpringAOP)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="AOP-（Aspect-Oriented-Programming）"><a href="#AOP-（Aspect-Oriented-Programming）" class="headerlink" title="AOP （Aspect Oriented Programming）"></a>AOP （Aspect Oriented Programming）</h1><h2 id="AOP应用范围"><a href="#AOP应用范围" class="headerlink" title="AOP应用范围"></a>AOP应用范围</h2><ul>
<li>Authentication：权限；</li>
<li>● Caching：缓存；</li>
<li>● Context passing：内容传递；</li>
<li>● Error handling：错误处理；</li>
<li>● Lazy loading：懒加载；</li>
<li>● Debugging：调试；</li>
<li>● logging, tracing, profiling and monitoring：记录跟踪、优化、校准；</li>
<li>● Performance optimization：性能优化；</li>
<li>● Persistence：持久化；</li>
<li>● Resource pooling：资源池；</li>
<li>● Synchronization：同步；</li>
<li>● Transactions：事务。</li>
</ul>
<h2 id="AOP名词解释"><a href="#AOP名词解释" class="headerlink" title="AOP名词解释"></a>AOP名词解释</h2><p>● 关注点（Concern）：一个关注点就是一个特定的目的，一块我们感兴趣的区域。从技术的角度来说，一个典型的软件系统包含一些核心的关注点和系统级的关注点。举个例子来说，一个信用卡处理系统的核心关注点是借贷&#x2F;存入处理，而系统级的关注点则是日志、事务完整性、授权、安全及性能问题等。许多关注点——我们叫它横切关注点（Crosscutting Concerns）——会在多个模块中出现，使用现有的编程方法，横切关注点会横越多个模块，结果是使系统难以设计、理解、实现和演进；● 切面（Aspect）：如果一个关注点模块化，则这个关注点可能会横切多个对象。事务管理是Java EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用通用类（基于模式的风格）或者在普通类中以@Aspect注解（@AspectJ风格）来实现；<br>● 连接点（Joinpoint）：在程序执行过程中的某个特定的点，比如在某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是代表一个方法的执行。通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息；<br>● 通知（Advice）：在切面的某个特定的连接点上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等。通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都以拦截器做通知模型，并维护一个以连接点为中心的拦截器链；<br>● 切入点（Pointcut）：匹配连接点的断连。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式及如何与连接点匹配是AOP的核心，Spring默认使用AspectJ切入点语法；<br>● 引入（Introduction）：也被称为内部类型声明（Inter Type Declaration），用来声明额外的方法或者某个类型的字段。Spring允许引入新的接口（及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现IsModified接口，以便简化缓存机制；<br>● 目标对象（Target Object）：被一个或者多个切面（Aspect）所通知（Advise）的对象。也有人把它叫做被通知（Advised）对象。既然Spring AOP是通过在运行时代理实现的，那么这个对象永远是一个被代理（Proxied）对象；<br>● AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（AspectContract，包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Spring 2.0最新引入了基于模式（Schema Based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。</span><br></pre></td></tr></table></figure>
<p>● 织入（Weaving）：把切面（Aspect）连接到其他的应用程序类型或者对象上，并创建一个被通知（Advised）的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<h2 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h2><p>● 前置通知（Before Advice）：在某连接点（Join Point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）；<br>● 返回后通知（After Returning Advice）：在某连接点（Join Point）正常完成后执行的通知。例如，一个方法没有抛出任何异常，正常返回；<br>● 抛出异常后通知（After Throwing Advice）：在方法抛出异常，退出时执行的通知；<br>● 后通知（After Finally Advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）；<br>● 环绕通知（Around Advice）：包围一个连接点（Join Point）的通知，如方法调用，这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是继续执行连接点，还是直接返回它们自己的返回值或通过抛出异常来结束执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0521(SpringAOP)/" data-id="cld1bs9t1001efynh5z5aboas" data-title="每日一问0521(SpringAOP)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0522(设计模式)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0522(%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0522(%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)/">每日一问0522(设计模式)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计的六大原则：</p>
<p> 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：&#x3D;&#x3D;就一个类而言，应该只有一个引起它变化的原因.&#x3D;&#x3D;</p>
<p> 开闭原则(Open-Closed Principle, OCP)：&#x3D;&#x3D;一个软件实体应当对扩展开放，对修改关闭&#x3D;&#x3D;。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p> 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<p> 依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
<p> 接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p> 迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>通过上文介绍的返奖业务模型，我们可以看到返奖的主流程就是选择不同的返奖策略的过程，每个返奖策略都包括返奖金额计算、更新用户奖金信息、以及结算这三个步骤。 我们可以使用<strong>工厂模式生产出不同的策略</strong>，同时使用策略模式来进行不同的策略执行。</p>
<p>工厂方法模式帮助我们直接产生一个具体的策略对象，策略模式帮助我们保证这些策略对象可以自由地切换而不需要改动其他逻辑，从而达到解耦的目的。通过这两个模式的组合，当我们系统需要增加一种返奖策略时，只需要实现RewardStrategy接口即可，无需考虑其他的改动。当我们需要改变策略时，只要修改策略的类名即可。不仅增强了系统的可扩展性，避免了大量的条件判断，而且从真正意义上达到了高内聚、低耦合的目的。</p>
<p>（规则引擎 可使用策略模式？）</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>kafka 进行消息监听 ，进行Topic 广播</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>模式定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p>例如: 订单 下单过程中看是否命中哪个活动，哪个优惠券，建立多个对象，对象之间通过某个方法进行调用传递，使多个对象都有机会处理请求，用责任链模式。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>定义一个创建对象的接口，让子类决定实例化那个类。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/112371239?utm_term=%E4%B8%9A%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-112371239&spm=3001.4430">设计模式在美团外卖营销业务中的实践</a></p>
<ul>
<li>*** *<a target="_blank" rel="noopener" href="https://github.com/youlookwhat/DesignPattern">DesignPattern</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0522(%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)/" data-id="cld1bs9t1001ffynhdeu5cowu" data-title="每日一问0522(设计模式)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0528(java内存模型)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0528(java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0528(java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)/">每日一问0528(java内存模型)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型 JMM"></a>Java 内存模型 JMM</h1><p><img src="https://img-blog.csdnimg.cn/20181109104341534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZSaXZhbA==,size_16,color_FFFFFF,t_70" alt="avatar"></p>
<p>java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p><strong>运作原理</strong>：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>
<p><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有<code>MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol</code>，等等</p>
<p><img src="https://pic1.zhimg.com/80/v2-1a021d2833b7a537dcdfdf0025f52a6c_1440w.jpg" alt="img"></p>
<p><strong>指令重排序问题</strong>：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化</p>
<ul>
<li>线程之间的共享变量存储在主内存（Main Memory）中</li>
<li>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读&#x2F;写共享变量的拷贝副本。</li>
<li>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。</li>
</ul>
<h2 id="Java内存模型解决的问题"><a href="#Java内存模型解决的问题" class="headerlink" title="Java内存模型解决的问题"></a><strong>Java内存模型解决的问题</strong></h2><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）。</p>
<ul>
<li>Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</li>
<li>Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li>
<li>Java中的final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）</li>
</ul>
<p><strong>重排序导致的可见性问题：</strong></p>
<p>Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。</p>
<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p>
<ul>
<li>volatile关键字本身就包含了禁止指令重排序的语义</li>
<li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li>
</ul>
<p><strong>happens before（先行发生原则）：</strong></p>
<p>（我的理解：会有很多的指令打包发到CPU去执行，但有些是有先后顺序，遵循的原则就是 happens before 比如 volatile 关键字标识的对象 有很多的读 和写操作指令，就会按这个原则，先把所有的写操作执行完，然后执行读操作。）</p>
<p>从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
<p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则</p>
<p><strong>内存屏障禁止特定类型的处理器重排序：</strong></p>
<p>重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p><strong>多线程竞争（Race Conditions）问题</strong>：当读，写和检查共享变量时出现race conditions。</p>
<p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>其中read和load，store和write必须成对使用，顺序但补一定连续的执行。通俗的说，就是执行了read，后面一定会执行load，但不一定read之后立马load；store和write也一样。lock和unlock也是成对出现，一个变量在同一时间点只能有一个线程对其进行lock。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>volatile 不能保证多线程的安全性的原因的自己的一些思考：</li>
</ol>
<p>  内存模型 有主内存和工作内存，工作内存的存取和CPU指令的执行效率 相差不是一个量级，所以为了优化 有个打包发到CPU执行，再打包写回工作内存的优化（指令重排序），但这个优化为了保证程序执行的正确性，有一些原则要遵循，也就是happens-before 原则，volatile关键字遵循的原则就是针对于关键字修饰的对象的所有打包的读写操作里边，所有的写要发生在所有的读之前，这样看似原子操作，然后 多个线程的读写请求，所有的写操作执行完了，所有的读操作读到的都是最新的值，也就是多个线程可见到对象最新的值(可见性)；但是，所有的写操作还是重排执行的，比如累加，就会出问题。</p>
<h2 id="无锁编程-应用"><a href="#无锁编程-应用" class="headerlink" title="无锁编程 应用"></a>无锁编程 应用</h2><ol>
<li>一写一读的无锁队列: 内存屏障</li>
<li>一写多读的无锁队列：Volatile 关键字</li>
<li>多写多读的无锁队列：CAS（Compare and set + lock）</li>
<li>无锁栈（只对head指针进行CAS操作）</li>
<li>无锁链表 （ConcurrentSkipListMap 实现，并发的跳查表）</li>
</ol>
<h2 id="Atomic-类"><a href="#Atomic-类" class="headerlink" title="Atomic 类"></a>Atomic 类</h2><p><img src="/../../ImgSource/image-20220111135943920.png" alt="image-20220111135943920"></p>
<h3 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h3><p>应对这种功能</p>
<p><img src="/../../ImgSource/image-20220111141328322.png" alt="image-20220111141328322"></p>
<h3 id="ABA问题如何解决"><a href="#ABA问题如何解决" class="headerlink" title="ABA问题如何解决"></a>ABA问题如何解决</h3><p>要解决ABA 问题，不仅要比较“值”，还要比较“版本号”，而这正是AtomicStamped-Reference做的事情</p>
<p>AtomicMarkableReference  AtomicMarkableReference与AtomicStampedReference原理类似，只是Pair里面的版本号是boolean类型的，而不是整型的累加变量，因为是boolean类型，只能有true、false 两个版本号，所以并不能完全避免ABA问题，只是降低了ABA发生的概率。</p>
<p><img src="/../../ImgSource/image-20220111141636974.png" alt="image-20220111141636974"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/VRival/article/details/83869129">java内存模型</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0528(java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)/" data-id="cld1bs9t2001gfynh4ovafheb" data-title="每日一问0528(java内存模型)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0601(数据结构)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0601(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0601(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/">每日一问0601(数据结构)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0601(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/" data-id="cld1bs9t2001hfynh678w6iyu" data-title="每日一问0601(数据结构)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0620(服务架构)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0620(%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0620(%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84)/">每日一问0620(服务架构)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h1><h2 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>云原生主要包括四个部分:</p>
<ul>
<li>微服务</li>
<li>容器</li>
<li>持续集成和交付</li>
<li>DevOps</li>
</ul>
<h3 id="Service-mesh"><a href="#Service-mesh" class="headerlink" title="Service mesh"></a>Service mesh</h3><p><img src="https://upload-images.jianshu.io/upload_images/3144413-37463a2c78d63d22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1170/format/webp" alt="avatar"><br>Sevice Mesh 是云原生下的微服务治理方案。<br>主机独立进程代理<br>，蚂蚁金服已经有了自己的一套完整的 Service Mesh 服务框架– Sofa Mesh<br><img src="https://img2018.cnblogs.com/blog/1837087/201910/1837087-20191025182722274-240580979.png" alt="avatar"><br>Istio 是目前最热的 Service Mesh 开源项目</p>
<p>Istio 主要分为两个部分：数据平面和控制平面。</p>
<h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p>目前Service Mesh的实现非常多，其实在Service Mesh概念被提出以前，国内有些公司已经实现了基于Proxy的类似Service Mesh的结构，如唯品会的OSP Local Proxy，以及新浪的WeiboMesh，这两款产品都是在服务治理框架上增加代理层来降级升级和多语言成本。在ServiceMesh出来之后，又有一些大型互联网企业紧密跟进，如华为的CSE Mesher、美团的OCTOMesh、蚂蚁的SOFA Mesh、阿里的Dubbo Mesh，以及Google、IBM、Lyft联合开发的Istio。</p>
<h4 id="开元产品"><a href="#开元产品" class="headerlink" title="开元产品"></a>开元产品</h4><p>Service Mesh的开源产品比较多，有以数据平面为代表的Linkerd和Envoy，另外还有Istio、Conduit、Weibo Mesh、SOFA Mesh、Dubbo Mesh等。</p>
<h4 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h4><p>Mixer 同样是一个可拓展的模块，其负责遥感数据的采集以及集成了一些后端服务（BAAS），Sidecar 会不断向 Mixer 报告自己的流量情况， Mixer 对流量情况进行汇总，以可视化的形式展现，此外 Sidecar 可以调用 Mixer 提供的一些后端服务能力，例如鉴权、登录、日志等等， Mixer 通过适配器的方式对接各种后端服务。</p>
<p>ServiceMesh其实并不是什么新东西，本质就是上面提到的服务发现模式三~主机独立进程模式，这个模式很早就有公司在探索和实践，但是一直没有普遍流行起来，说明这个模式也是存在落地挑战的。从表面上看，模式三是模式一和模式二的折中，同时解决了模式一和模式二存在的问题，但是在每个主机上独立部署一个代理进程，是有很大运维管理开销的，一方面是规模化部署的问题(考虑服务很多，机器也很多的场景)；另一方面是如何监控治理的问题，代理挂了怎么办？你的团队是否具备自动化运维和监控的能力？另外开发人员在服务调试的时候，会依赖于这个独立的代理，调试排错比较麻烦，这个问题怎么解决？</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1．性能Service Mesh方式的服务调用相比服务框架的直接调用增加了与Service Mesh中数据平面Sidecar的交互，虽然是本地网络通信，但性能上的损耗还是非常明显的，这也给Service Mesh大规模落地带来了困难。2．可用性Service Mesh通过单独的进程的方式来为应用程序提供服务，虽然它相对于应用程序来说比较透明，但其实也在整个服务调用链上增加了故障点，势必导致可用性问题。在落地的过程中，这是一个不小的挑战，因此需要对Service Mesh的整体设计提出更高的要求来保证服务的可用性。3．运维治理Service Mesh在运维治理上也存在一些难题，主要是三个方面的问题：首先是规模化部署的问题，特别是大型互联网公司，线上运行实例非常多，这些实例上都需要部署Sidecar；其次是如何监控治理的问题，如果Sidecar进程“挂了”怎么办？需要具备自动化运维和监控的能力；最后是开发人员在本地环境开发调试的时候，也需要依赖Sidecar，难道每个开发机器上也需要安装相关的Sidecar，并且在测试前先启动Sidecar进程？当然，如果类似Istio方案，借助K8S基础设施，那么前两个问题就不存在了，但目前还是存在很多公司没有完全使用K8S的情况。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27a742e349f7">微服务之-ServiceMesh</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0620(%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84)/" data-id="cld1bs9t3001ifynh12644l72" data-title="每日一问0620(服务架构)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0701(布隆过滤器)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0701(%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0701(%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)/">每日一问0701(布隆过滤器)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器(Bloom Filter)"></a>布隆过滤器(Bloom Filter)</h1><p><img src="https://bkimg.cdn.bcebos.com/pic/7acb0a46f21fbe09b5f6ad4467600c338744ad32?x-bce-process=image/crop,x_125,y_0,w_1087,h_717/watermark,g_7,image_d2F0ZXIvYmFpa2UxNTA=,xp_5,yp_5" alt="avatar"><br>你好，我叫孟康。</p>
<p> 晚上和朋友开黑，他用的布隆，操作carry全场，不过我说的这个布隆的格挡技术不亚于这个英雄。</p>
<p> 先来讲一个香皂盒的故事。</p>
<p> 联合利华引进了一条香皂包装生产线，结果发现这条生产线有个缺陷：常常会有盒子里没装入香皂。总不能把空盒子卖给顾客啊，他们只得请了一个学自动化的博士后设计一个方案来分拣空的香皂盒。博士后拉起了一个十几人的科研攻关小组，综合采用了机械、微电子、自动化、X射线探测等技术，花了几十万，成功解决了问题。每当生产线上有空香皂盒通过，两旁的探测器会检测到，并且驱动一只机械手把空皂盒推走。<br>  中国南方有个乡镇企业也买了同样的生产线，老板发现这个问题后大为发火，找了个小工来说:你他妈给老子把这个搞定，不然你给老子爬出去。小工很快想出了办法：他在生产线旁边放了台风扇猛吹，空皂盒自然会被吹走。</p>
<p> 其实做软件开发的时候我们也会遇到很多类似的情况。</p>
<h2 id="解决啥问题"><a href="#解决啥问题" class="headerlink" title="解决啥问题"></a>解决啥问题</h2><p>  我们的应用通常可以抽象成三部分，由请求处理、计算逻辑和数据存取三部分。根据性能瓶颈的侧重点不同，偏向计算逻辑<br>的 叫<code>CPU密集型</code>应用，数据存取逻辑的是<code>IO密集型</code>。所以以前我在考虑架构优化的侧重点也就在计算逻辑，和数据存取最多。<br>这种优化的方式 往往是从CPU计算的结构算法复杂度，或者是数据存储的类型，减少磁盘操作等等的优化。这些都是偏向于技术方面的。</p>
<p>但是从业务角度出发，往往有些场景，用特定的手段可以取到意想不到的效果。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p> 比如查询用户的信息，有些用户可能并不存在，那我们可能把基本信息查询放在了最前边(代码的第一行)，如果不存在就直接返回，就会避免后边的数据拼接和其他的IO查询。<br>但是一个用户基本信息的数据库查询 还是会走一次IO。</p>
<p>在生产环境中，往往我们会对一些热点用户信息做缓存，但是也免不了恶意用户，抓住漏洞，大量请求不存在的用户信息，这些用户不存在缓存中，全部走磁盘IO 会给数据库带来非常大的压力。也就是造成了<code>缓存击穿</code></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>回写空值</li>
<li>过滤器</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>可以在最外层根据用户ID 做一层缓存，把所有用户信息都放到缓存层，请求进来先经过缓存，发现没有该用户，则直接返回，那所有用户ID的缓存需要的空间应该会不少吧。</p>
<h4 id="内存计算"><a href="#内存计算" class="headerlink" title="内存计算"></a>内存计算</h4><p>为了方便计算内存占用，先来回顾一下 计算机存储的基础知识。</p>
<ul>
<li><p>1KB&#x3D;1024字节</p>
</li>
<li><p>1024K&#x3D;1M</p>
</li>
<li><p>1024M&#x3D;1G</p>
</li>
<li><p>一个字节(KB)占8位</p>
</li>
<li><p>char是 2个字节 16位，char 最大值 65535</p>
</li>
<li><p>int 是4 个字节 32位 int 最大值 2147483647</p>
</li>
</ul>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>如果我们的数据量是千万级以内，我们可以用哈希表，利用hashMap 的的一些优势，碰撞扩容，拉链法解决冲突，然后演变红黑二叉树等等。我们甚至可以记录出现次数等额外信息。</p>
<h3 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a>连续数组</h3><p>但是如果我们有一亿的用户量。将用户的信息放到缓存，还要支持快速查找，该怎么处理呢？</p>
<p>快速查找的方案有很多，比如放到数组里排好序，每个指针指向一个ID，二分法查找 ，时间复杂度 log n,<br>用什么数据结构存储呢，我们都知道 char 的取值范围是65535，所以最少要用int （最大2147483647）， int 是32位，4个字节，一亿个ID 耗费的内存就是 4亿&#x2F;1000&#x2F;1000 &#x3D;400M，（大约估算）</p>
<h3 id="位图BitMap"><a href="#位图BitMap" class="headerlink" title="位图BitMap"></a>位图BitMap</h3><p>有没有更好的方法呢，再来分析一下我们的业务需求，要判断某个用户ID在一亿个数的集合中是否存在，先来分析用户的ID的取值范围，如果用int定义的用户ID的话，那最大是21 4748 3647，二十亿的大小，<br>我们可以开辟一个 20亿（大约）个连续内存空间，每一个空间表示一个用户ID，属性只有存在 和不存在,我们使用最小的内存 bit(位)(0:不存在，1:存在)存储<br>这样的内存大小就是 20亿&#x2F;8 &#x2F;1000&#x2F;1000&#x3D;250M,而查找效率都用下标指针取值，一次取值 n1 就可以，这种方案明显就比上边的方案要好。(真的好吗？)</p>
<p>怎么来实现呢。这个时候我们的问题就变成了 怎么用最小的内存空间bit(位)来标记一个数字。下来我们就用到了 <code>位图</code>的结构。</p>
<p>位图：数据结构</p>
<p> 内部维护数组   char [M] [N];</p>
<p> 位图在内部维护了一个M×N维的数组char[M][N]，在这个数组里面每个字节占8位，因此可以存储M×N×8个数据。假如要存储的数据范围为0～15，则只需使用M&#x3D;1, N&#x3D;2的数据进行存储。<br> 在我们要存储的数据为{1,3,6,10,15}时，只需将有数据的位设置为1，表示该位存在数据，将其他位设置为0 ，如图所示<br> <img src="/../../ImgSource/bulong_bitmap.png" alt="avatar"></p>
<p> 具体为啥要用char ，我也不知道。 存40亿 位的数 大概需要 40亿&#x2F;8&#x2F;M&#x2F;&#x3D;N 的大小</p>
<p> 然后来看看 怎么初始化 ？怎么设置值？怎么取值？</p>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p> 这里会涉及到一些位操作 </p>
<ul>
<li>&amp; : 0&amp;1&#x3D;0 ，0&amp;0&#x3D;0，1&amp;1&#x3D;1</li>
<li>| : 0|1&#x3D;1，0|0&#x3D;0，1|1&#x3D;1</li>
<li><code>&lt;&lt;</code> : 左移，高位舍去，如果高位舍去的是零相当于乘以2的N(左移位数)次， 1&lt;&lt;3 就是 0000 0001 变成 0000 1000 </li>
<li><code>&gt;&gt;</code> : 右移，低位舍去，如果低位舍去的是零相当于除以2的N(右移位数)次， 7&gt;&gt;3 就是 1111 1111 变成 0001 1111</li>
</ul>
<p> 位图中设置一个值也就是要设置一个char(16位)中的一位，要用到位运算  <code>a|1&lt;&lt;n</code> a代表原来的char ,n 代表第几位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  我们想设置char 中某一位 为1,可以与该位为1其他位都是0的一个二进制进行或运算</span><br><span class="line">比如: 0000 0001 中想设置第三位 为1 则 用0000 1000 | 0000 0001=0000 1001</span><br><span class="line"></span><br><span class="line">怎么得到某一位为1 其他位都是0 的数 可以用 1&lt;&lt; 左移，</span><br><span class="line">1=0000 0001 </span><br><span class="line">1&lt;&lt;3=000 1000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p> 这样实现基本的用位图过滤就实现了，那我们再深入了解一下需求，如果我们的ID不是连续的 而是非常<code>离散稀疏</code>的呢，举个极端的例子 比如我们只有少量用户 ，一个ID是1，一个id是999 999 999 。<br>  这样是不是造成了非常大的空间浪费，再比如 我们的ID是Long 类型 64bit 的数据，大小&#x3D;2048PB&#x3D;2EB，这个量级的数据已经不是硬件(内存)所能承担的了。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>然后我们来讲到工业级的实现: 布隆过滤器</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>布隆过滤器的实现原理其实跟生活中的某些事很像，考试我们不可能每次都考满分，做事也不一定能百分之百的做好，但是能做到百分之七八十 也是能够得到别人的认可。所以他的原理就是用可能会存在一定的<code>误差率</code>的形式来最大限度的减少内存的使用。</p>
<p>怎么实现的其实上边已经解释了大部分内容，但是由于内存空间有限，为了解决空间问题，它使用了地址hash的方式，你了解HashMap 的存储原理，这块也就不难理解。</p>
<p>比如我们有1-20 20个数，想用一个10位长度的数组去做过滤，怎么最大限度的实现？就是通过根据数组长度取余的方式，1和11放到第一位，9和19放到用一个空间表示。<br>这样虽然有一定误差，但如果是上亿的数据量，存储空间可以折半（或者是根据误差率，算出其存储空间）</p>
<p>这样的话如果判断出来某个数存在，那他存在的概率有一半，如果判断出来不存在，那就是百分之百不存在了，这一点在过滤数据上还是很靠谱的。</p>
<p>另外，布隆过滤器 为了解决这个误差率，采用了多个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 具体的误差率怎么来计算的，（我下来再补充）有兴趣的朋友可以自己了解一下。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>由于布隆过滤器的这些特性，他的缺点也是呼之欲出。</p>
<ul>
<li>误差率算一个</li>
<li>由于hash碰撞，他的每个存储空间可能表示多个值，所以不支持删除，删除后它判断某元素不存在有100%准确的特性就不存在了。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p> 只有优缺点都掌握了，我们才可以更好的使用一门技术 ，布隆过滤器 比较适用的部分场景（待补充）</p>
<ul>
<li>网页爬虫对URL的去重，避免爬去相同的URL地址。</li>
<li>垃圾邮件过滤，从数十亿个垃圾邮件列表中判断某邮箱是否是杀垃圾邮箱。</li>
<li>解决数据库缓存击穿，黑客攻击服务器时，会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的时候，频繁的数据库查询会导致挂机。</li>
<li>秒杀系统，查看用户是否重复购买。</li>
<li>给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法？<br><code>思路：精确算法利用位图来实现  近似算法利用布隆过滤器实现，将一个文件的中100亿个query放在一个布隆过滤器中，另个一个文件中的数据到布隆过滤器中去查找，若查找到则说明是这两个文件的交集。</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0701(%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8)/" data-id="cld1bs9t3001jfynhe0k9b8dz" data-title="每日一问0701(布隆过滤器)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0710(规则引擎)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0710(%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0710(%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E)/">每日一问0710(规则引擎)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h1><p>我们接到一个折扣策略需求，针对于某些应用使用更低的折扣。而且总会有类似的需求，比如某些应用不能使用该折扣，某范围内的应用可以使用，或者是多重条件某些应用 和某些服务商可以应用特定折扣等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">when 条件A then  </span><br><span class="line">     条件B then </span><br><span class="line">     条件C then </span><br><span class="line">     条件D then</span><br><span class="line">     条件E&amp;&amp;条件F then </span><br><span class="line">    条件G||条件I then</span><br></pre></td></tr></table></figure>
<h2 id="为什么需要规则引擎"><a href="#为什么需要规则引擎" class="headerlink" title="为什么需要规则引擎"></a>为什么需要规则引擎</h2><p>我们之前的解决方案：<br>由于考虑到时间成本和实现复杂度，就直接在代码里硬编码，这样做的优点：</p>
<ul>
<li>可以快速实现产品功能，时间成本低</li>
<li>实现难度低<br>缺点:</li>
<li>针对于频繁变更的需求，每次都需要重新编码</li>
<li>多次实现不同的逻辑，时间久了 分支太多 不好维护(可以用策略设计模式)</li>
<li>每种策略都有自己的编写格式，可读性差</li>
<li>碰到有冲突的策略，重构难度高</li>
<li>每次要重新部署</li>
</ul>
<p>我们讨论了一番，有人说考虑一下存储过程，将变化的策略放在存储过程里维护，这样至少修改了策略，不用部署原来的应用！但有人回了一句:”不行！不行！用存储过程可读性更差，而且性能还不好！更可怕的是，如果你用的是MySQL，调试存储过程是会要人命的！”</p>
<p>后来我们整理了一下<strong>需求</strong>:</p>
<ul>
<li>简化策略结构，让业务逻辑和数据分离!</li>
<li>分离出的业务逻辑必须要易于编码，至少单独编写这些业务逻辑，要比写代码快！</li>
<li>分离出的业务逻辑必须要比原来代码更容易读懂!</li>
<li>分离出的业务逻辑必须比原来的易于维护，至少改动这些逻辑，应用不需要重启。</li>
</ul>
<p>大家问道”有满足这样需求的中间件么？”</p>
<p>有的，那就是 <em>规则引擎</em>!</p>
<h2 id="什么是规则引擎"><a href="#什么是规则引擎" class="headerlink" title="什么是规则引擎"></a>什么是规则引擎</h2><h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>企业级管理者可能会在系统生产过程中调整生产策略、物料采购策略等，因此对企业IT系统的开发有着如下的要求：</p>
<ul>
<li>为提高效率，管理流程必须自动化，即使现代商业规则异常复杂。</li>
<li>市场要求业务规则经常变化，IT系统必须依据业务规则的变化快速、低成本的更新。</li>
<li>为了快速、低成本的更新，业务人员应能直接管理IT系统中的规则，不需要程序开发人员参与。</li>
</ul>
<p>而项目开发人员则碰到了以下问题:</p>
<ul>
<li>程序&#x3D;算法+数据结构，有些复杂的商业规则很难推导出算法和抽象出数据模型</li>
<li>软件工程要求从需求-&gt;设计-&gt;编码，然而业务规则常常在需求阶段可能还没有明确，在设计和编码后还在变化，业务规则往往嵌在系统各处代码中</li>
<li>对程序员来说，系统已经维护、更新困难，更不可能让业务人员来管理。</li>
</ul>
<p>因此迫切需要分离商业决策者的商业决策逻辑和应用开发者的技术决策。把这些商业决策放在中心数据库或其他统一的地方，让它们能在运行时（即商务时间）可以动态地管理和修改从而提供软件系统的柔性和适应性。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据规则做出业务决策。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>规则引擎可以在系统工作时，<em>将外部的业务规则加载到系统中</em>，并使得系统按照该业务规则进行工作。接下来我们分别进行介绍。<br>注: 如果之前的场景可能是在数据库层做的筛选，那规则引擎是需要将所有规则 加载到<em>内存</em>中去运行规则，他更多的是逻辑运算，所以说 规则引擎的项目是一个CPU密集型应用，最好是单独部署，和常见的IO密集型应用分开。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="*****基本概念"></a>*****基本概念</h3><h4 id="业务规则-rule"><a href="#业务规则-rule" class="headerlink" title="业务规则 (rule)"></a>业务规则 (rule)</h4><p>一个业务规则包含一组条件和在此条件下执行的操作，它们表示业务规则应用程序的一段业务逻辑。业务规则通常应该由业务分析人员和策略管理者开发和修改，但有些复杂的业务规则也可以由技术人员使用面向对象的技术语言或脚本来定制。业务规则的理论基础是:<em>设置一个或多个条件，当满足这些条件时会触发一个或多个操作。</em></p>
<h4 id="规则引擎-engine"><a href="#规则引擎-engine" class="headerlink" title="规则引擎 (engine)"></a>规则引擎 (engine)</h4><p>规则引擎 就像容器,是将数据 在规则中运行的逻辑，它至少包含以下API:</p>
<ul>
<li>加载和卸载规则集的API；</li>
<li>数据操作的API；</li>
<li>引擎执行的API。</li>
</ul>
<p>规则与规则之间如何执行，这个涉及到规则属性的定义，用于修改和增强标准的规则行为。</p>
<ul>
<li>优先级（salience）：可以设置规则执行顺序，优先级高的优先执行</li>
<li>同步分组（agenda-group）： 同一个分组的规则要么都执行要么都不执行</li>
<li>互斥分组（activation-group）：同一个分组只有一条被执行，其他不执行</li>
</ul>
<h4 id="事实-数据-facts"><a href="#事实-数据-facts" class="headerlink" title="事实 数据(facts)"></a>事实 数据(facts)</h4><p>也就是你要进行运行规则的数据。</p>
<h2 id="规则引擎选型"><a href="#规则引擎选型" class="headerlink" title="规则引擎选型"></a>规则引擎选型</h2><table>
<thead>
<tr>
<th>名称</th>
<th>github start</th>
<th>github地址</th>
</tr>
</thead>
<tbody><tr>
<td>drools</td>
<td>* 3.1k</td>
<td><a target="_blank" rel="noopener" href="https://github.com/kiegroup/drools">https://github.com/kiegroup/drools</a></td>
</tr>
<tr>
<td>easy-rules</td>
<td>* 2.4k</td>
<td><a target="_blank" rel="noopener" href="https://github.com/j-easy/easy-rules">https://github.com/j-easy/easy-rules</a></td>
</tr>
<tr>
<td>Aviator</td>
<td>* 1.8K</td>
<td><a target="_blank" rel="noopener" href="https://github.com/killme2008/aviator">https://github.com/killme2008/aviator</a></td>
</tr>
<tr>
<td>MVEL</td>
<td>* 703</td>
<td></td>
</tr>
</tbody></table>
<p>drools 特点</p>
<ol>
<li>完整的实现了Rate算法；</li>
<li>提供了强大的Eclipse Plugin开发支持；</li>
<li>通过使用其中的DSL(Domain Specific Language)，可以实现用自然语言方式来描述业务规则，使得业务分析人员也可以看懂业务规则代码；</li>
<li>提供了基于WEB的BRMS——Guvnor，Guvnor提供了规则管理的知识库，通过它可以实现规则的版本控制，及规则的在线修改与编译，使得开发人员和系统管理人员可以在线管理业务规则。</li>
</ol>
<p>easy-rules的特点</p>
<ol>
<li>轻量级类库和容易上手</li>
<li>基于POJO的开发与注解的编程模型</li>
<li>基于MVEL表达式的编程模型（适用于极简单的规则，一般不推荐）</li>
<li>支持根据简单的规则创建组合规则</li>
<li>方便且适用于java的抽象的业务模型规则</li>
</ol>
<p>个人理解 ，drools 适合做海量多级规则的业务场景 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">规则流程</span><br><span class="line">when A then</span><br><span class="line">          when a1 then</span><br><span class="line">          when a2 then  </span><br><span class="line">     B then </span><br><span class="line">          when  b1 then</span><br><span class="line">          when  b2 then</span><br><span class="line">     C then</span><br><span class="line">          when  c1 then</span><br><span class="line">          when  c2 then</span><br></pre></td></tr></table></figure>
<p>，原因是它有特定的编程语法(DSL)会增加一定的学习成本，如果是海量频繁规则变动维护的场景这些投入是可接受的，第二点是完整实现了Rate 算法，在海量规则，还有多级规则中有一定的优化。</p>
<h2 id="规则引擎架构"><a href="#规则引擎架构" class="headerlink" title="规则引擎架构"></a>规则引擎架构</h2><p>一、 简单架构 </p>
<ol>
<li>直接业务代码中嵌入</li>
<li>规则通过引入外部模板形式</li>
<li>运行时加载规则，进行计算</li>
</ol>
<p>二、 优化</p>
<ol>
<li>由于是CPU密集型应用 ，可以独立出来单独部署，对外提供服务</li>
<li>加载规则的方式，可以改成动态加载 ，自定义规则模板 ，模板数据保存在 JSON，XML，数据库中</li>
<li>规则引擎在内存中 对数据进行规则匹配，由于规则的变化性不大，可以将动态生成的规则放入缓存，更新的时候，同时更新缓存</li>
</ol>
<p>三、参考美团 Maze 框架</p>
<ol>
<li>MazeQL核心主要由3部分构成：配置中心、MazeQL引擎和平台。<br><img src="https://p0.meituan.net/travelcube/7119b70635731c94f45871ad788a3289400155.png" alt="avatar"></li>
<li>规则配置<br><img src="https://p1.meituan.net/travelcube/b648dab4d847848593cac4fa18c1cbf9212164.png" alt="avatar"></li>
</ol>
<p>具体可参考 美团技术文档 : <a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/06/09/maze-framework.html">从0到1：构建强大且易用的规则引擎</a></p>
<h2 id="easy-rules-概念"><a href="#easy-rules-概念" class="headerlink" title="easy-rules 概念"></a>easy-rules 概念</h2><h2 id="规则引擎-应用场景"><a href="#规则引擎-应用场景" class="headerlink" title="规则引擎 应用场景"></a>规则引擎 应用场景</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>***** <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9b67ab434795">再见了 ! if-else ！拥抱规则引擎</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0710(%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E)/" data-id="cld1bs9t4001kfynha2w4huv6" data-title="每日一问0710(规则引擎)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0713(easy-rule)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0713(easy-rule)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0713(easy-rule)/">每日一问0713(easy-rule)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Easy-Rule"><a href="#Easy-Rule" class="headerlink" title="Easy Rule"></a>Easy Rule</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h2 id="几种通用的rule"><a href="#几种通用的rule" class="headerlink" title="几种通用的rule"></a>几种通用的rule</h2><h3 id="ActivationRuleGroup"><a href="#ActivationRuleGroup" class="headerlink" title="ActivationRuleGroup"></a>ActivationRuleGroup</h3><p>多个rule 只有一个 rule匹配则 action</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean evaluate(Facts facts) &#123;</span><br><span class="line">    for (Rule rule : rules) &#123;</span><br><span class="line">        if (rule.evaluate(facts)) &#123;</span><br><span class="line">            selectedRule = rule;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void execute(Facts facts) throws Exception &#123;</span><br><span class="line">    if (selectedRule != null) &#123;</span><br><span class="line">        selectedRule.execute(facts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConditionalRuleGroup"><a href="#ConditionalRuleGroup" class="headerlink" title="ConditionalRuleGroup"></a>ConditionalRuleGroup</h3><p>获取一个最高priority 的 作为 condition ,它命中，才进行下边的规则匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean evaluate(Facts facts) &#123;</span><br><span class="line">       successfulEvaluations = new HashSet&lt;&gt;();</span><br><span class="line">       conditionalRule = getRuleWithHighestPriority();</span><br><span class="line">       if (conditionalRule.evaluate(facts)) &#123;</span><br><span class="line">           for (Rule rule : rules) &#123;</span><br><span class="line">               if (rule != conditionalRule &amp;&amp; rule.evaluate(facts)) &#123;</span><br><span class="line">                   successfulEvaluations.add(rule);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public void execute(Facts facts) throws Exception &#123;</span><br><span class="line">       conditionalRule.execute(facts);</span><br><span class="line">       for (Rule rule : sort(successfulEvaluations)) &#123;</span><br><span class="line">           rule.execute(facts);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   private Rule getRuleWithHighestPriority() &#123;</span><br><span class="line">       List&lt;Rule&gt; copy = sort(rules);</span><br><span class="line">       // make sure we only have one rule with the highest priority</span><br><span class="line">       Rule highest = copy.get(0);</span><br><span class="line">       if (copy.size() &gt; 1 &amp;&amp; copy.get(1).getPriority() == highest.getPriority()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;Only one rule can have highest priority&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return highest;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="UnitRuleGroup"><a href="#UnitRuleGroup" class="headerlink" title="UnitRuleGroup"></a>UnitRuleGroup</h3><p>匹配所有的rules  所有的都成功才会执行 rule 的action</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean evaluate(Facts facts) &#123;</span><br><span class="line">        if (!rules.isEmpty()) &#123;</span><br><span class="line">            for (Rule rule : rules) &#123;</span><br><span class="line">                if (!rule.evaluate(facts)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Facts facts) throws Exception &#123;</span><br><span class="line">        for (Rule rule : rules) &#123;</span><br><span class="line">            rule.execute(facts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0713(easy-rule)/" data-id="cld1bs9t4001lfynhakbzc5zj" data-title="每日一问0713(easy-rule)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2022/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0922(%E6%9E%B6%E6%9E%84)/">每日一问0922(架构)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2022/%E8%BF%B0%E8%81%8C%E6%A8%A1%E6%9D%BF/">述职模板</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E7%A7%AF%E7%B4%AF/">英文单词积累</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%9C%B0%E5%9D%80/">好玩的地址</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/">摄影后期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>