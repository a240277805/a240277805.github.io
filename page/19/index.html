<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/19/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2019/每日一问0428(Springbean初始化过程)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(Springbean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(Springbean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B)/">每日一问0428(Springbean初始化过程)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="Spring-bean-初始化过程"><a href="#Spring-bean-初始化过程" class="headerlink" title="Spring bean 初始化过程"></a>Spring bean 初始化过程</h1><p>问题</p>
<ul>
<li>1.bean 是如何被初始化 在 IOC容器中的</li>
<li>2.bean 是如何销毁的</li>
<li>3.bean 初始化后保存在哪</li>
<li>4.bean bean 怎么延迟初始化的</li>
<li>5.通过main 方法怎么实现一个 bean</li>
</ul>
<p>在理解任何技术之前，我都会问自己一个问题：它的产生是为了解决什么样的问题，以及如何解决这些问题？希望你能在本篇文章中找到答案……</p>
<h3 id="怎么将自己的对象注入Spring"><a href="#怎么将自己的对象注入Spring" class="headerlink" title="怎么将自己的对象注入Spring"></a>怎么将自己的对象注入Spring</h3><ul>
<li>@bean</li>
<li>ApplicationContext.beanFactory.register…</li>
<li>FactoryBean 注入对象 生成defination 放入 map（BeanDefinationMap里增加自己对象的class）</li>
</ul>
<p><code>classLoader 加载有注解的类 ，生成 define,放入BeanDefinationMap,当用到的时候，从define 查找，拿出来初始化。</code></p>
<p>知识点收集：</br><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#160;上面的生命周期流程图，时候的时候注意调用先后顺序，避免属性被覆盖的现象。</p>
<ul>
<li>BeanFactoryPostProcessor 主要是在Spring刚加载完配置文件，还没来得及初始化Bean的时候做一些操作。比如篡改某个Bean在配置文件中配置的内容。</li>
<li>InstantiationAwareBeanPostProcessorAdapter 基本没什么鸟用，Bean初始化后，还没有设置属性值时调用，和BeanFactoryPostProcessor一样，可以篡改配置文件加载到内存中的信息。 </li>
<li>ApplicationContextAware:用处很大，注入了ApplicationContext到Bean中。</li>
<li>InitializingBean:有用处，可以在Bean属性全部改完之后，再做一些定制化操作。</li>
<li>BeanPostProcessor：没什么用，Spring框架内部使用的比较猛，像什么AOP，动态代理，都是在这搞事。后期有时间和大家分析。</li>
<li>其他的像什么init-method，destroy方法，基本都是个摆设。。我是没怎么用过，只知道有这么回事。</li>
</ul>
<p><strong>问：?ApplicationContextAware:用处很大，注入了ApplicationContext到Bean中。   ApplicationContext 是啥</strong></p>
<p>  【Spring】BeanFactory 解析 bean 详解 <a target="_blank" rel="noopener" href="https://juejin.im/post/5b9f707ce51d450e3f6b8244">https://juejin.im/post/5b9f707ce51d450e3f6b8244</a><br>    1.XmlBeanFactory 加载 bean  这是初级操作， 在企业开发中一般是使用功能更完善的 ApplicationContext</p>
<p>XmlBeanFactory 的实现 ：<br>  实现了 DefaultListableBeanFactory 	，他是注册加载bean 的默认实现，是bean加载的核心部分。<br>  XmlBeanFactory 不同的是 替换了自定义的 xml 读取器</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/593386ca2f301e00584f8036">https://juejin.im/post/593386ca2f301e00584f8036</a></p>
</blockquote>
<p>顺便增加了 对IOC的理解，<strong>就是叫你不用去管对象的生命周期，而关注到对象的使用上</strong></br><br>IOC 常用的有两种方式：</p>
<blockquote>
<p>构造方法注入和setter注入</p>
</blockquote>
<p>ApplicationContext 容器 ，可以认为是BeanFactory的一种扩展。</p>
<ul>
<li>BeanFactory 默认采用延迟 初始化策略( lazy-load)  ?还有啥初始化策略，</li>
<li>BeanDefinition Bean生成 Bean定义的地方  （读取配置 reader 读取 ，property 读取 ，然后生成对象相关的定义，并未真正初始化）</li>
<li>BeanDefinitionRegistry bean的注册中心 （将对象的定义 注册上）（注册的时候 会生成一个注册码）</li>
<li>BeanFactory 可以取到任意定义过的Bean  （对象的出口，有就拿走，没有就生成）</li>
</ul>
<h2 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h2><p>初始是通过 beanFactory的 getBean()时才进行的。</p>
<ul>
<li>对象不是new出来的 其实这里用到了AOP机制，生成了其代理对象，通过 反射机制 生成接口对象，或者是通过CGLIB生成子对象</li>
<li>beanWrapper 实现了bean 具体装载过程（它继承了PropertyAccessor （可以对属性进行访问）、PropertyEditorRegistry 和TypeConverter接口 （实现类型转换））</li>
<li>BeanPostprocessor 可以帮助 初始化之前和之后的完成一些必要工作 ，比如 参数解密。</li>
<li>在完成postProcessor 之后，则会看对象是否定义了InitializingBean 接口  或者 spring还提供了另外一种指定初始化的方式，即在bean定义中指定init-method 。</li>
</ul>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext 拥有BeanFactory的所有功能，但应用方法略有不同</p>
<ul>
<li><p>bean的加载方式</p>
</li>
<li><p>BeanFactory提供BeanReader来从配置文件中读取bean配置。相应的ApplicationContext也提供几个读取配置文件的方式 xxxxxxreader.xml</p>
</li>
<li><p>ApplicationContext采用的非懒加载方式 	它会在启动阶段完成所有的初始化，并不会等到getBean()才执行。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(Springbean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B)/" data-id="cld1buvue003vbjoph196a9uu" data-title="每日一问0428(Springbean初始化过程)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0430(Spring boot 启动篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Spring%20boot%20%E5%90%AF%E5%8A%A8%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Spring%20boot%20%E5%90%AF%E5%8A%A8%E7%AF%87)/">每日一问0430(Spring boot 启动篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring-boot-启动篇"><a href="#Spring-boot-启动篇" class="headerlink" title="Spring boot 启动篇"></a>Spring boot 启动篇</h1><h2 id="Spring-中的概念"><a href="#Spring-中的概念" class="headerlink" title="Spring 中的概念"></a>Spring 中的概念</h2><h3 id="1-BeanDefinition"><a href="#1-BeanDefinition" class="headerlink" title="1.BeanDefinition"></a>1.BeanDefinition</h3><p>描述Bean的信息，配置Bean的方式有三种:</p>
<ul>
<li>XML 配置文件</li>
<li>Java 注解 @Service,@Component</li>
<li>Java Config  注入Bean</li>
</ul>
<p>Spring 在启动时，会将Bean配置信息加载成BeanDefintion对象</p>
<h3 id="2-BeanDefinitionRegistry"><a href="#2-BeanDefinitionRegistry" class="headerlink" title="2.BeanDefinitionRegistry"></a>2.BeanDefinitionRegistry</h3><p>是BeanDefination的容器，所有BeanDefination 都会注册到这个对象中。<br>可以通过Spring的扩展机制往Registry中注册 BeanDefination对象</p>
<h3 id="3-BeanFactory"><a href="#3-BeanFactory" class="headerlink" title="3.BeanFactory"></a>3.BeanFactory</h3><p>Bean 工厂，负责Bean的创建和属性注入。同时他也是个Bean的容器，通过BeanDefination对象创建Bean实例，<code>所有的单例Bean都会注册到BeanFactory 中。</code></p>
<h3 id="4-BeanFactoryProcessor"><a href="#4-BeanFactoryProcessor" class="headerlink" title="4.BeanFactoryProcessor"></a>4.BeanFactoryProcessor</h3><p>Spring 提供的扩展机制，用于在所有Bean配置信息解析完成后修改Bean工厂信息。解析所有Bean完成之后，<code>会调用所有BeanFactoryPostProcessor实现类的postProcessBeanFactory()方法。</code></p>
<h3 id="5-importBeanDefinationRegistor"><a href="#5-importBeanDefinationRegistor" class="headerlink" title="5. importBeanDefinationRegistor"></a>5. importBeanDefinationRegistor</h3><p>在定义容器中注入定义的一个东西。该接口的实现类作用于Spring解析Bean的配置阶段，当解析@Configuration注解时，可以通过ImportBeanDefinitionRegistrar接口的实现类想，Bean定义的容器(BeanDefinitionRegistry)中，添加BeanDefinition对象。</p>
<p>ImportBeanDefinitionRegistrar接口实现类的registerBeanDefinitions()方法会在Spring解析@Configuration注解时调用。ImportBeanDefinitionRegistrar接口需要配合@Import注解使用，importingClassMetadata参数为@Import所在注解的配置信息，registry参数为BeanDefinition容器。</p>
<h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>Bean 初始化方法调用前后，会执行Processor中定义的拦截逻辑。</p>
<ul>
<li>postProcessBeforeInitialization() 初始化之前</li>
<li>postProcessAfterInitialization() 初始化之后</li>
</ul>
<h3 id="7-ClassPathBeanDefinationScanner"><a href="#7-ClassPathBeanDefinationScanner" class="headerlink" title="7.ClassPathBeanDefinationScanner"></a>7.ClassPathBeanDefinationScanner</h3><p>是BeanDefination扫描器，能够对指定包下的Class进行自定义扫描，将Class信息转换为BeanDefination注册到BeanDefinationRegistry容器中。</p>
<h3 id="8-FactoryBean"><a href="#8-FactoryBean" class="headerlink" title="8.FactoryBean"></a>8.FactoryBean</h3><p>不能作为普通Bean使用，而是作为单个对象的工厂。当通过Bean名称获取FactoryBean 实例时，实际是getObject()返回的。获得自定义的Bean，OpenFeign就是用这个来实现的。   </p>
<h2 id="Spring-容器启动过程"><a href="#Spring-容器启动过程" class="headerlink" title="Spring 容器启动过程"></a>Spring 容器启动过程</h2><p><img src="/../../ImgSource/WX20200430-175633.png" alt="avatar"></p>
<ol>
<li>解析所有Bean配置信息，生成BeanDefination对象，并注册到Registory.</li>
<li>先实例化实现了BeanFactoryPostProcessor接口的Bean（从容器中找出来实例化，）然后在postProcessBeanFactory()中<code>可以对Bean工厂信息进行修改</code>。</li>
<li>再实例化所有单例Bean，并对其属性进行填充</li>
<li>执行 before </li>
<li>初始化bean</li>
<li>执行after</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Spring%20boot%20%E5%90%AF%E5%8A%A8%E7%AF%87)/" data-id="cld1buvuf003wbjop0b3372rh" data-title="每日一问0430(Spring boot 启动篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0506(Spring boot 熔断)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(Spring%20boot%20%E7%86%94%E6%96%AD)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(Spring%20boot%20%E7%86%94%E6%96%AD)/">每日一问0506(Spring boot 熔断)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring-boot-熔断"><a href="#Spring-boot-熔断" class="headerlink" title="Spring boot 熔断"></a>Spring boot 熔断</h1><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p> 今天遇到一个线上问题，在发送 fengin 请求时，偶发一个问题 <code>could not be queued for execution and no fallback available.</code> 查了一下 发现是fegin 队列不够了。</p>
<h4 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h4><ol>
<li>为啥会队列不够，队列默认多少，怎么加入的队列 </li>
<li>怎个问题咋解决</li>
<li>关于熔断会不会有其他坑</li>
</ol>
<p> 遇到问题首先想到的肯定是如何去解决，我也一样，开始百度一下，很简单找到了答案，增加一段hystrix 配置   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(Spring%20boot%20%E7%86%94%E6%96%AD)/" data-id="cld1buvuf003xbjophgj7b8yq" data-title="每日一问0506(Spring boot 熔断)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0708(建表规范)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83)/">每日一问0708(建表规范)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h1><ol>
<li><p>【强制】表达是与否概念的字段，必须使用 xxx_flag 的方式命名，数据类型是 unsigned tinyint（1 表示是， 0 表示否）。<br>说明： 使用 xxx_flag 的方式而不是is_xxx的方式，避免一些公共框架使用get、set方式反射机制的时候出现问题。<br>正例： 表达逻辑删除的字段名 delete_flag， 1 表示删除， 0 表示未删除。</p>
</li>
<li><p>【强制】禁用保留字，如 desc、 range、 match、 delayed 等， 请参考 MySQL 官方保留字。<br>说明：可以组合其他实体信息与关键字一起使用。例如表达活动描述，可以使用字段名：activity_desc</p>
</li>
<li><p>【强制】 主键索引名为 pk_字段名； 唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名。<br>说明： pk_ 即 primary key； uk_ 即 unique key； idx_ 即 index 的简称。<br>正例： pk_id，uk_user_id，idx_create_time</p>
</li>
</ol>
<p>primary key pk_id(id),<br>unique key uk_user_id(user_id)</p>
<ol start="9">
<li>【强制】表必备三字段： id,create_time, update_time。<br>说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 create_time,update_time 的类型均为 date_time 类型。<br>正例：</li>
</ol>
<p>id bigint unsigned not null auto_increment comment ‘主键’,<br>……<br>create_time datetime not null default current_timestamp comment ‘创建时间’,<br>update_time datetime not null default current_timestamp on update current_timestamp comment ‘更新时间’</p>
<ol start="11">
<li><p>【推荐】库名与应用名称尽量一致。<br>说明：微服务单独使用一个库的时候尽量与应用名称一致，与其他微服务共用数据库实例的时候可以不遵循该规约。</p>
</li>
<li><p>【强制】除了 text、blob 类型，所有字段设置为not null，设置default值。<br>说明：所有字段设置为not null带来一定的成本，需要避免insert或者update的时候出现错误，例如：insert into xxx(col1,col2) values(‘1’, null)或者update xxx set col1&#x3D;null。但是字段存在null值产生更多问题：1）null与任何值的直接比较都为null，例如：null!&#x3D;null 不是返回false，判断需要采用is null操作符；2）sum函数对于字段全为null的情况返回null而不是0，对于返回可能存在NPE；3）对于查询出来的记录，处理不当容易NPE；4）存在null的列难以查询优化；5）联表查询的时候null值代表的意思模糊，join的null值代表不存在对应记录；</p>
</li>
<li><p>【补充】整型类型的字段，如果非负请使用unsigned<br>说明：无符号值可以避免误存负数， 且扩大了表示范围</p>
</li>
</ol>
<p>（二）索引规约<br>2. 【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时，<br>保证被关联的字段需要有索引。<br>说明： 即使双表 join 也要注意表索引、 SQL 性能。</p>
<ol start="4">
<li>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br>说明： 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索<br>引</li>
</ol>
<p>（三）SQL语句</p>
<ol>
<li><p>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)， count(</em>)是 SQL92 定义的标准统计行数的语法。<br>说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
</li>
<li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新， 即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群； 级联更新是强阻塞，存在数据库更新风暴的风险； 外键影响数据库的插入速度。</p>
</li>
<li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</li>
</ol>
<p>（四）ORM映射</p>
<ol>
<li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br>说明： 1） 增加查询分析器解析成本。 2） 增减字段容易与 resultMap 配置不一致。</p>
</li>
<li><p>【强制】sql.xml 配置参数使用： #{}， #param# 不要使用${} 此种方式容易出现 SQL 注入。</p>
</li>
<li><p>【强制】 iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<br>说明：其实现方式是在数据库取到 statementName对应的SQL语句的所有记录，再通过 subList取 start,size 的子集合。因此，建议自己在SQL中指定 limit start,size ，通过传参执行SQL<br>正例：</p>
</li>
</ol>
<p>Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();<br>map.put(“start”, start);<br>map.put(“size”, size);</p>
<ol start="8">
<li>【推荐】不要写一个大而全的数据更新接口。 传入 POJO 类，进行 update table set c1&#x3D;value1,c2&#x3D;value2,c3&#x3D;value3; 这是不对的。<br>说明：不要更新无改动的字段，一是易出错； 二是效率低； 三是增加 binlog 存储。针对一张表的业务逻辑编写多个更新SQL。<br>正例：例如更新订单状态：update order_info set status&#x3D;value1 where xxx</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83)/" data-id="cld1buvug003ybjop4zd3ey4l" data-title="每日一问0708(建表规范)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0709(工作述职)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0709(%E5%B7%A5%E4%BD%9C%E8%BF%B0%E8%81%8C)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0709(%E5%B7%A5%E4%BD%9C%E8%BF%B0%E8%81%8C)/">每日一问0709(工作述职)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0709(%E5%B7%A5%E4%BD%9C%E8%BF%B0%E8%81%8C)/" data-id="cld1buvug003zbjop0dpn6k02" data-title="每日一问0709(工作述职)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0801(树)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(%E6%A0%91)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(%E6%A0%91)/">每日一问0801(树)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的类型"><a href="#树的类型" class="headerlink" title="树的类型"></a>树的类型</h2><p>二叉树、完全二叉树、满二叉树、线索二叉树、霍夫曼树、二叉排序树、平衡二叉树、红黑树、B树</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="结点的度"><a href="#结点的度" class="headerlink" title="结点的度"></a>结点的度</h3><p>结点拥有的子树数目称为结点的度。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7043118-cfa7c45bb8f1e332.png" alt="avatar"></p>
<ul>
<li>结点子树的根结点为该结点的<code>孩子结点</code>。相应该结点称为孩子结点的<code>双亲结点</code>。</li>
<li>图2.2中，A为B的双亲结点，B为A的孩子结点。</li>
<li>同一个双亲结点的孩子结点之间互称<code>兄弟结点</code>。</li>
<li>图2.2中，结点B与结点C互为兄弟结点。</li>
</ul>
<h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><p>树中结点的最大层次数称为树的深度或高度</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>二叉树非最后一层的节点都有两个子节点</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只有最后一层不是满的，并且缺少的都是右子节点</p>
<h3 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。<br><img src="https://upload-images.jianshu.io/upload_images/7043118-3293242769696303.png" alt="avatar"></p>
<p><code>顺序存储</code>一般适用于完全二叉树。<code>其他的会出现空间浪费情况</code></p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>可以将结点数据结构定义为一个数据和两个指针域</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7043118-95cd18e8cc20316e.png" alt="avatar"><br><img src="https://upload-images.jianshu.io/upload_images/7043118-73ae201506a7adc9.png" alt="avatar"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><blockquote>
<p>前序遍历 父节点-&gt;左子树-&gt;右子树<br><br> 中序遍历 左子树-&gt;父节点-&gt;右子树<br><br> 后序遍历 左子树 -&gt; 右子树 -&gt;父节点<br><br> 层序遍历   从第一层 依次往下一层遍历</p>
</blockquote>
<p><code> 各种遍历的优缺点是啥？？？</code></p>
<p>##二叉树的基本性质</p>
<blockquote>
<p>(1) 在非空二叉树中，第i层的结点总数不超过  , i&gt;&#x3D;1；<br><br>(2) 深度为h的二叉树最多有 个结点(h&gt;&#x3D;1)，最少有h个结点；<br><br>(3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0&#x3D;N2+1；<br><br>(4) 具有n个结点的完全二叉树的深度为  <br><br>(5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<br><br>           若I为结点编号则 如果I&gt;1，则其父结点的编号为I&#x2F;2；<br><br>           如果2<em>I&lt;&#x3D;N，则其左儿子（即左子树的根结点）的编号为2*I；若2*I&gt;N，则无左儿子；<br><br>           如果2</em>I+1&lt;&#x3D;N，则其右儿子的结点编号为2<em>I+1；若2*I+1&gt;N，则无右儿子。<br><br>(6)给定N个节点，能构成h(N)种不同的二叉树。<br><br>           h(N)为卡特兰数的第N项。h(n)&#x3D;C(2</em>n，n)&#x2F;(n+1)。<br><br>(7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J&#x3D;I+2i<br><br><img src="http://dl.iteye.com/upload/picture/pic/90395/70fbf233-89b4-35b6-8582-61431b6fe025.jpg" alt="avatar"></p>
</blockquote>
<p>参考文章:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26222859/article/details/80631121">漫画：什么是b+树</a><br>B+树的特征：</p>
<ol>
<li><p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
</li>
<li><p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
</li>
</ol>
<p>B+树的优势：</p>
<ol>
<li><p>单一节点存储更多的元素，使得查询的IO次数更少。</p>
</li>
<li><p>所有查询都要查找到叶子节点，查询性能稳定。</p>
</li>
<li><p>所有叶子节点形成有序链表，便于范围查询。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(%E6%A0%91)/" data-id="cld1buvuh0040bjop94we5u6a" data-title="每日一问0801(树)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0823(Elastic原理篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0823(Elastic%E5%8E%9F%E7%90%86%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0823(Elastic%E5%8E%9F%E7%90%86%E7%AF%87)/">每日一问0823(Elastic原理篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>Elastic 原理篇</h1>
<h2>WHY</h2>

<p>此文章参照 infoQ陶文大师的文章<a href="%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%88%E4%B8%80%EF%BC%89">时间序列数据库的秘密</a>  根据自己的理解整理的 </p>
<h3>时间序列数据</h3>
* 1.第一类格式 
[metric_name] [timestamp] [value]
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT value FROM metric WHERE metric_name=”A” AND timestamp &gt;= B AND </span><br></pre></td></tr></table></figure>
这种模式两个弊端
* 1.无法快速响应变化: 如果需要的图表有变更，需要从上报的源头重新来一遍。而且要等新数据过来之后，才能查看这些新数据。
* 2.存储膨胀：总有一些数据是需要从不同的维度查询的需求，比如广告点击流数据，需要按省份聚合，按运营商聚合，按点击人喜好组合，这些维度交叉组合存储起来又会造成空间浪费。


<h3>如何快速检索？</h3>

<p>几个概念： <code>document docid  term </code></p>
<ul>
<li>term dictionary ：排好序的 term </li>
<li>term index : <code>类似于一本字典的章节列表</code> 标记了 term dictionay 位置（存储在磁盘中）  <code>体积小 存储在内存中</code>，<br> term index 是 一个tree 树: term 可以是任意的 byte 数组，然后每个 index 大小不一 这棵树不会包含所有的 </li>
<li>term，它包含的是 term 的一些前缀。通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。再加上一些压缩技术（搜索 Lucene Finite State Transducers） term index 的尺寸可以只有所有 term 的尺寸的几十分之一<br><img src="https://static001.infoq.cn/resource/image/e4/26/e4599b618e270df9b64a75eb77bfb326.jpg" alt="avatar"></li>
</ul>
<h3>ES 为什么比MySQL 快？</h3>

<p>Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。检索一个 term 需要若干次的 random access 的磁盘操作。</p>
<p>1）Lucence 有 term index 加速检索 </p>
<p>2） 还有 存储在内存中 </p>
<p>3）term index 以树的形式缓存在内存中。</p>
<p>了解<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiu0821/p/7688669.html">FST</a><br><img src="https://images2017.cnblogs.com/blog/504727/201710/504727-20171018202211834-1358126860.jpg" alt="avatar"></p>
<p>FST 为啥省内存??</p>
<p>   正因为，我们保证了所有的Key都是按照字典序加进来的，所以当加入一个新Key的时侯，我们可以先求出新加的Key和上一次输入的Key的公共前缀，然后就可以把 上一次输入的Key除去公共前缀剩下的部分存入文件中了。</p>
<p>如果想了解请查看Lucene4.0官方开源代码Builder.java 的add 方法。目前Lucene还支持FST的反映射，即通过Value找Key，以及前k小的Key（按照Value大小排序）。其实就是在FST上用<code>Dijikstra</code>求最短路。</p>
<p>额外值得一提的两点是：</p>
<ul>
<li>term index 在内存中是以 FST（finite state transducers）的形式保存的，其特点是非常节省内存。</li>
<li>Term dictionary 在磁盘上是以分 block 的方式保存的，一个 block 内部利用公共前缀压缩（也是公共前缀压缩？），比如都是 Ab 开头的单词就可以把 Ab 省去。这样 term dictionary 可以比 b-tree 更节约磁盘空间。</li>
</ul>
<h3 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h3><ol>
<li>新增的文档首先会放入内存的缓存中</li>
<li>当文档足够多，或者到达一定时间点，就会对缓存进行commit</li>
</ol>
<ul>
<li>生成一个新的segment,并写入磁盘</li>
<li>生成一个新的commit point ,记录当前所有可用的segment</li>
<li>等待所有数据都已吸入磁盘</li>
</ul>
<p>3、 打开新增segment,这样我们就可以对新增的文档进行搜索了。</p>
<p>4、 清空缓存，准备接受新的文档。</p>
<h3 id="数据的删除和更新"><a href="#数据的删除和更新" class="headerlink" title="数据的删除和更新"></a>数据的删除和更新</h3><ul>
<li>删除 是标记删除 ，维护.del 文件，查询是加过滤</li>
<li>更新是先删除再插入新的。</li>
</ul>
<h3 id="Refesh"><a href="#Refesh" class="headerlink" title="Refesh"></a>Refesh</h3><p>ES 一个特性是提供实时搜索。在提交数据时，写入磁盘速度太慢，就先写入文件缓存，然后打开可供查询，然后再逐渐将文件flush 到磁盘。默认refresh频率是一秒，插入后没有refresh 是搜不到的可以手动触发refresh.</p>
<h3 id="flush-与-translog"><a href="#flush-与-translog" class="headerlink" title="flush 与 translog"></a>flush 与 translog</h3><p>当新插入的数据写入文件缓存，如果断电会丢失，所以新增加了 translog,每次写入记录translog,当translog足够大，或者时间够就flush 到磁盘，清空translog.</p>
<h3>如何联合索引查询？</h3>

<p>所以给定查询过滤条件 age&#x3D;18 的过程就是先从 term index 找到 18 在 term dictionary 的大概位置，然后再从 term dictionary 里精确地找到 18 这个 term，然后得到一个 posting list 或者一个指向 posting list 位置的指针。然后再查询 gender&#x3D; 女 的过程也是类似的。最后得出 age&#x3D;18 AND gender&#x3D; 女 就是把两个 posting list 做一个<code>“与”</code>的合并。</p>
<p>如何合并两个 posting list </p>
<ol>
<li>使用 skip list 数据结构。同时遍历 gender 和 age 的 posting list，互相 skip；</li>
<li>使用 <code>bitset</code> 数据结构，对 gender 和 age 两个 filter 分别求出 bitset，对两个 bitset 做 AN 操作。<br><code>PostgreSQL 从 8.4 版本开始支持通过 bitmap 联合使用两个索引，就是利用了 bitset 数据结构来做到的。</code></li>
</ol>
<p><strong><code>Elasticsearch</code> 支持以上两种的联合索引方式，如果查询的 filter 缓存到了内存中（以 bitset 的形式），那么合并就是两个 bitset 的 AND。如果查询的 filter 没有缓存，那么就用 skip list 的方式去遍历两个 on disk 的 posting list。</strong></p>
<h4>利用 Skip List 合并</h4>

<p><img src="https://static001.infoq.cn/resource/image/ea/9f/eafa46683272ff1b2081edbc8db5469f.jpg" alt="avatar"></p>
<ol>
<li>从小到大排序，取最短的开始，然后跳过其他比这个小的；</li>
<li>跳跳跳</li>
<li>原理 ？？？？自己写的 ，跳表原来好像不同 需要了解</li>
</ol>
<p>多条序列</p>
<ol>
<li>从小到大排序，</li>
<li>取最短一条序列开始</li>
<li>确定多个序列的跳过位置0，确定初始值 （最短序列开始第一个值）</li>
<li>比较，更新跳过位置(规则:最小于接近于初始值的各个序列) ，寻找匹配  ， 更新初始位置（规则:比较各个跳过位置，取最大值）</li>
<li>重复4</li>
</ol>
<p>Lucene 自然会对这个 block 再次进行压缩。其压缩方式叫做 <code>Frame Of Reference</code> 编码 <em><code>Frame Of Reference？？？？是个啥</code></em></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>如何利用索引和主存储，是一种两难的选择。</p>
<ul>
<li>选择不使用索引，只使用主存储：除非查询的字段就是主存储的排序字段，否则就需要顺序扫描整个主存储。</li>
<li>选择使用索引，然后用找到的 row id 去主存储加载数据：这样会导致很多碎片化的随机读操作。</li>
</ul>
<p>没有所谓完美的解决方案。MySQL 支持索引，一般索引检索出来的行数也就是在 1~100 条之间。<code>如果索引检索出来很多行，很有可能 MySQL 会选择不使用索引而直接扫描主存储</code>，<code>这就是因为用 row id 去主存储里读取行的内容是碎片化的随机读操作，这在普通磁盘上很慢。</code></p>
<p><code>Opentsdb</code> 是另外一个极端，<code>它完全没有索引，只有主存储</code>。使用 Opentsdb 可以按照主存储的排序顺序快速地扫描很多条记录。但是访问的不是按主存储的排序顺序仍然要面对随机读的问题。</p>
<p>Elasticsearch&#x2F;Lucene 的解决办法是让主存储的随机读操作变得很快，从而可以充分利用索引，而不用惧怕从主存储里随机读加载几百万行带来的代价。</p>
<h4 id="Opentsdb-的弱点"><a href="#Opentsdb-的弱点" class="headerlink" title="Opentsdb 的弱点"></a>Opentsdb 的弱点</h4><p>Opentsdb 没有索引，主存储是 <code>Hbase</code>。所有的数据点按照时间顺序排列存储在 Hbase 中。Hbase 是一种支持排序的存储引擎，其排序的方式是根据每个 row 的 rowkey（就是关系数据库里的主键的概念）。MySQL 存储时间序列的最佳实践是利用 MySQL 的 Innodb 的 clustered index 特性，使用它去模仿类似 Hbase 按 rowkey 排序的效果。所以 Opentsdb 的弱点也基本适用于 MySQL。</p>
<h4 id="DocValues-为什么快？"><a href="#DocValues-为什么快？" class="headerlink" title="DocValues 为什么快？"></a>DocValues 为什么快？</h4><p>DocValues 是一种按列组织的存储格式</p>
<p>按列存储的话会把一个文件分成多个文件，每个列一个。对于每个文件，都是按照 docid 排序的。这样一来，只要知道 docid，就可以计算出这个 docid 在这个文件里的偏移量。也就是对于每个 docid 需要一次随机读操作。</p>
<p>那么这种排列是如何让随机读更快的呢？秘密在于 Lucene 底层读取文件的方式是基于 memory mapped byte buffer 的，也就是 mmap。这种文件访问的方式是由操作系统去缓存这个文件到内存里。这样在内存足够的情况下，访问文件就相当于访问内存。那么随机读操作也就不再是磁盘操作了，而是对内存的随机读。</p>
<p>那么为什么按行存储不能用 mmap 的方式呢？因为按行存储的方式一个文件里包含了很多列的数据，这个文件尺寸往往很大，超过了操作系统的文件缓存的大小。而按列存储的方式把不同列分成了很多文件，<code>可以只缓存用到的那些列</code>，而不让很少使用的列数据浪费内存。</p>
<p><img src="https://static001.infoq.cn/resource/image/aa/a5/aab78e64a7ec5c36fe347991110ed6a5.jpg" alt="avatar"></p>
<h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><h4 id="分布式聚合如何做得快"><a href="#分布式聚合如何做得快" class="headerlink" title="分布式聚合如何做得快"></a>分布式聚合如何做得快</h4><p>Elasticsearch&#x2F;Lucene 从最底层就支持数据分片，查询的时候可以自动把不同分片的查询结果合并起来。</p>
<p>Elasticsearch 的 document 都有一个 uid，<code>默认策略是按照 uid 的 hash 把文档进行分片</code>。<br>对于聚合查询，其处理是分两阶段完成的：</p>
<ul>
<li>Shard 本地的 Lucene Index 并行计算出局部的聚合结果；</li>
<li>收到所有的 Shard 的局部聚合结果，聚合出最终的聚合结果。</li>
</ul>
<p>这种两阶段聚合的架构使得每个 shard 不用把原数据返回，而只用返回数据量小得多的聚合结果</p>
<p>除此之外 Elasticsearch 还有另外一个减少聚合过程中网络传输量的优化，那就是 <code>Hyperloglog</code> 算法，Hyperloglog 算法<code>以一定的误差做为代价</code>，可以用很小的数据量保存这个 set，从而减少网络传输消耗。</p>
<p><code>这里有些解释 关于降维聚合不懂，大概讲的是查询一个时间的 最大的数的和，先做聚合 再降维，以后再看</code></p>
<h3 id="第五篇-Protobuf-有没有比-JSON-快-5-倍？"><a href="#第五篇-Protobuf-有没有比-JSON-快-5-倍？" class="headerlink" title="第五篇 Protobuf 有没有比 JSON 快 5 倍？"></a>第五篇 Protobuf 有没有比 JSON 快 5 倍？</h3><p>这个比较了一下 protobuf 和JSON  编解码性能问题<br>大致就是 long double 整形 protobuf 要快78倍，String字符串 或者 整数列表的话性能差不多。<br>还有一些存储细节 char[] byte[]。</p>
<p>Elasticsearch 将要发布的 2.0 版本的最重量级的新特性是 Pipeline Aggregation，它支持数据在聚合之后再做聚合。类似 SQL 的子查询和 Having 等功能都将被支持。</p>
<h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><h3 id="ES是如何分片的"><a href="#ES是如何分片的" class="headerlink" title="ES是如何分片的"></a>ES是如何分片的</h3><p>  ES的路由机制是通过<code>哈希算法</code>，将具有相同哈希值的文档放在同一分片中，通过这个哈希算法做负载均衡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  计算公式:</span><br><span class="line">`shard = hash(routing) % number_of_primary_shards`　</span><br><span class="line">routing 值是一个任意字符串，它默认是_id但也可以自定义。这个routing 字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)</span><br></pre></td></tr></table></figure>
<h4 id="指定个性化路由"><a href="#指定个性化路由" class="headerlink" title="指定个性化路由"></a>指定个性化路由</h4><p>在插入和查询的时候根据业务需要指定分片(可以使多个)，可以减少资源消耗，但是使用不当会造成文档分布不均匀，某些分片较大</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903569015963656#comment">高效管理 Elasticsearch 中基于时间的索引</a><br><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/blog/managing-time-based-indices-efficiently">高效管理 Elasticsearch 中基于时间的索引 english</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0823(Elastic%E5%8E%9F%E7%90%86%E7%AF%87)/" data-id="cld1buvui0041bjopdnl6fcg6" data-title="每日一问0823(Elastic原理篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0824(ElasticSearch概念)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0824(ElasticSearch%E6%A6%82%E5%BF%B5)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0824(ElasticSearch%E6%A6%82%E5%BF%B5)/">每日一问0824(ElasticSearch概念)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ElasticSearch概念"><a href="#ElasticSearch概念" class="headerlink" title="ElasticSearch概念"></a>ElasticSearch概念</h1><p>在读下边文章的时候 ，就越接近使用了，然后需要了解几个概念</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>节点是单个服务器实例</p>
<p>云里面的每个白色正方形的盒子代表一个节点——Node。<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSktOK6nnSfk9QGQMOJLZOMMl2wlYKd1uiaEibFsLjuQtEBeL8RyBa0Az7Zg/640" alt="avatar"></p>
<h3 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index 索引"></a>Index 索引</h3><p>索引是具有相似特性的文档集合</p>
<p>索引由名称（必须全部为小写）标识</p>
<p>正排索引：从文档角度看其中的单词，表示每个文档都含有哪些单词，以及每个单词出现了多少次（词频）及其出现位置（相对于文档首部的偏移量）。</p>
<p>倒排索引：从单词角度看文档，标识每个单词分别在那些文档中出现(文档ID)，以及在各自的文档中每个单词分别出现了多少次（词频）及其出现位置（相对于该文档首部的偏移量）。</p>
<p>简单理解，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正排索引：id ---&gt; value</span><br><span class="line">倒排索引：value ---&gt; id</span><br></pre></td></tr></table></figure>


<p>在一个或者多个节点直接，多个绿色小方块组合在一起形成一个ElasticSearch的索引。<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSkt7UsZDh1aXDyoRbWWa8oHibZd8vubYzovV8qKvhgVT7lON9ErMztVIDQ/640" alt="avatar"></p>
<h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><p>在索引中，可以定义一个或多个类型。类型是索引的逻辑类别&#x2F;分区，其语义完全取决于您。一般来说，类型定义为具有公共字段集的文档。例如，假设你运行一个博客平台，并将所有数据存储在一个索引中。在这个索引中，您可以为用户数据定义一种类型，为博客数据定义另一种类型，以及为注释数据定义另一类型。</p>
<h3 id="Document文档"><a href="#Document文档" class="headerlink" title="Document文档"></a>Document文档</h3><p>文档是可以被索引的信息的基本单位</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>一个分片shard是一个最小级别的工作单元，仅保存了索引中所有数据的一部分。<br>分片就是一个Lucene实例，并且它本身就是一个完整的搜索引擎。<br>文档存储在分片中，并且在分片中被索引，但是程序不会直接与分片通信，而是与索引通信。<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSktlFXc08okMNZY3Sf0VnW3sA4XqL4OuOcpf9s2rezuiaNgibjCic4Fz6FOQ/640" alt="avatar"><br>Shard＝Lucene Index<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSkt28GbibzNzQrNFeew94C5ick9vibJeEDibx25icX1lBsySicibnXtcIKicEHxNA/640" alt="avatar"></p>
<h3 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h3><p>在Lucene里面有很多小的segment，我们可以把它们看成Lucene内部的mini-index。</p>
<p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSktnicias3h1GlKBYMJlvhMgf4Px4IMibv6JA1wZ9odDITPVm40rKqqTWNPA/640" alt="avatar"></p>
<h3 id="Segment内部"><a href="#Segment内部" class="headerlink" title="Segment内部"></a>Segment内部</h3><p>有着许多数据结构</p>
<ul>
<li>Inverted Index 倒排索引</li>
<li>Stored Fields </li>
<li>Document Values  存储库</li>
<li>Cache<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSktmeru4dTVXOWCibzCmDeCAM1EPf9jaliaNu5EiaqzyNN1xy3EmTWykiclYQ/640" alt="avatar"></li>
</ul>
<h3 id="最最重要的Inverted-Index"><a href="#最最重要的Inverted-Index" class="headerlink" title="最最重要的Inverted Index"></a>最最重要的Inverted Index</h3><p>Inverted Index主要包括两部分：</p>
<ul>
<li>一个有序的数据字典Dictionary（包括单词Term和它出现的频率）。</li>
<li>与单词Term对应的Postings（即存在这个单词的文件）。<br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffrWx0A45Her9bZODhNsSktuhD1d9NU7HIcG3jr5x5DRTiczLW0lK9Gob4rYUyndiaoZAiafEuTGwo1g/640" alt="avatar"></li>
</ul>
<h2 id="elasticsearch的写入流程"><a href="#elasticsearch的写入流程" class="headerlink" title="elasticsearch的写入流程"></a>elasticsearch的写入流程</h2><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><p>es接收数据请求时先存入内存中，默认每隔一秒会从内存buffer中将数据写入filesystem cache，这个过程叫做refresh；</p>
<h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h3><p>translog会每隔5秒或者在一个变更请求完成之后执行一次fsync操作，将translog从缓存刷入磁盘，这个操作比较耗时，如果对数据一致性要求不是跟高时建议将索引改为异步，如果节点宕机时会有5秒数据丢失;</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>es默认每隔30分钟会将filesystem cache中的数据刷入磁盘同时清空translog日志文件，这个过程叫做flush。</p>
<p><img src="https://img-blog.csdn.net/20180831120934971?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JfUF9K/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p>
<h3 id="ES数据类型"><a href="#ES数据类型" class="headerlink" title="ES数据类型"></a>ES数据类型</h3><p><img src="https://img-blog.csdn.net/20171030202032340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFveWFuZzM2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0824(ElasticSearch%E6%A6%82%E5%BF%B5)/" data-id="cld1buvui0042bjop6w1k79xf" data-title="每日一问0824(ElasticSearch概念)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0825(时序数据库)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0825(%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0825(%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93)/">每日一问0825(时序数据库)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="时序数据库"><a href="#时序数据库" class="headerlink" title="时序数据库"></a>时序数据库</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>时序数据库结构</li>
<li>时序数据库与结构性数据库对比</li>
<li>时序数据库适用场景</li>
<li>时序数据库应避免的问题</li>
<li>时序数据库之间的比较</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0825(%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93)/" data-id="cld1buvuj0043bjop0dwvgryd" data-title="每日一问0825(时序数据库)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0826(正则表达式Regex)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0826(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.730Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0826(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex)/">每日一问0826(正则表达式Regex)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0826(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex)/" data-id="cld1buvuj0044bjop5xto1hgt" data-title="每日一问0826(正则表达式Regex)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>