<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021/每日一问0421(Prometheus)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(Prometheus)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(Prometheus)/">每日一问0421(Prometheus)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(Prometheus)/" data-id="cld1buvtn002bbjop53zh2grx" data-title="每日一问0421(Prometheus)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0422(一致性hash)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0422(%E4%B8%80%E8%87%B4%E6%80%A7hash)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0422(%E4%B8%80%E8%87%B4%E6%80%A7hash)/">每日一问0422(一致性hash)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-swlqfutq-wq.html">一致性哈希（Consistent Hashing）的实现</a></p>
<p><a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-xryhhuag-hp.html">http://www.javashuo.com/article/p-xryhhuag-hp.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0422(%E4%B8%80%E8%87%B4%E6%80%A7hash)/" data-id="cld1buvto002cbjop83158hwu" data-title="每日一问0422(一致性hash)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0706(Springboot注解)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0706(Springboot%E6%B3%A8%E8%A7%A3)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0706(Springboot%E6%B3%A8%E8%A7%A3)/">每日一问0706(Springboot注解)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Springboot-注解"><a href="#Springboot-注解" class="headerlink" title="Springboot 注解"></a>Springboot 注解</h1><table>
<thead>
<tr>
<th>注解</th>
<th>作用概述</th>
<th>作用</th>
<th>使用方式</th>
<th>参考</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableAutoConfiguration</td>
<td>自动装配</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>@import</td>
<td></td>
<td>@Import注解是用来导入配置类或者一些需要前置加载的类.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@ComponentScan</td>
<td></td>
<td><code>扫描被</code>@Component<code> (</code>@Service<code>,</code>@Controller<code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除</code>TypeExcludeFilter<code>和</code>AutoConfigurationExcludeFilter&#96;。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IbV0dTmZBQuQvjD5B4AQFA">https://mp.weixin.qq.com/s/IbV0dTmZBQuQvjD5B4AQFA</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0706(Springboot%E6%B3%A8%E8%A7%A3)/" data-id="cld1buvto002dbjopefgo5niy" data-title="每日一问0706(Springboot注解)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0707(oauth2.0)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0707(oauth2.0)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0707(oauth2.0)/">每日一问0707(oauth2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="OAuth-2-0-的四种方式"><a href="#OAuth-2-0-的四种方式" class="headerlink" title="OAuth 2.0 的四种方式"></a>OAuth 2.0 的四种方式</h1><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">上一篇文章</a>介绍了 OAuth 2.0 是一种授权机制，主要用来颁发令牌（token）。本文接着介绍颁发令牌的实务操作。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040901.jpg" alt="img"></p>
<p>下面我假定，你已经理解了 OAuth 2.0 的含义和设计思想，否则请先阅读这个系列的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">上一篇文章</a>。</p>
<blockquote>
<p>进入正文之前，插播一则活动消息。</p>
<p>4月22日（周一）到4月29日（下周一），每天晚上八点都有两小时的免费直播课，体系化介绍高级前端开发知识，网易云课堂主办。<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html#support">详细介绍</a>请看本文结尾，欢迎关注。</p>
</blockquote>
<h2 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h2><p>OAuth 2.0 的标准是 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p>
<blockquote>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
</blockquote>
<p>这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong>然后，RFC 6749 接着写道：</p>
<blockquote>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
</blockquote>
<p>也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p>
<blockquote>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
</blockquote>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h2 id="第一种授权方式：授权码"><a href="#第一种授权方式：授权码" class="headerlink" title="第一种授权方式：授权码"></a>第一种授权方式：授权码</h2><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  redirect_uri=<span class="variable constant_">CALLBACK_URL</span>&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img"></p>
<p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>code</code>参数就是授权码。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img"></p>
<p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line"> client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp;</span><br><span class="line"> redirect_uri=<span class="variable constant_">CALLBACK_URL</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img"></p>
<p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040905.jpg" alt="img"></p>
<h2 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  redirect_uri=<span class="variable constant_">CALLBACK_URL</span>&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p>
<p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040906.jpg" alt="img"></p>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h2 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h2><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=<span class="variable constant_">USERNAME</span>&amp;</span><br><span class="line">  password=<span class="variable constant_">PASSWORD</span>&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p>
<p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<h2 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h2><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p>
<p>第一步，A 应用在命令行向 B 发出请求。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  client_secret=<span class="variable constant_">CLIENT_SECRET</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p>
<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p>
<p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;</span><br><span class="line">  client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;</span><br><span class="line">  refresh_token=<span class="variable constant_">REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0707(oauth2.0)/" data-id="cld1buvtp002ebjopcwhi5b8z" data-title="每日一问0707(oauth2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0708(分布式ID)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%88%86%E5%B8%83%E5%BC%8FID)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%88%86%E5%B8%83%E5%BC%8FID)/">每日一问0708(分布式ID)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="数据库主键自增"><a href="#数据库主键自增" class="headerlink" title="数据库主键自增"></a>数据库主键自增</h4><p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9QNQWDjhib1xw6k7MwxOlUsIWfRTZbne8GS7mkao1AtiaW3Xm0IWXcA8A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `sequence_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `stub` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `stub` (`stub`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给<code>stub</code> 字段创建了唯一索引，保证其唯一性。</p>
<p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">REPLACE INTO sequence_id (stub) VALUES (&#x27;stub&#x27;);</span><br><span class="line">SELECT LAST_INSERT_ID();</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p>
<p>1)第一步：尝试把数据插入到表中。</p>
<p>2)第二步：如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</p>
<p>这种方式的优缺点也比较明显：</p>
<ul>
<li><strong>优点</strong> ：实现起来比较简单、ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ：支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li>
</ul>
<h4 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h4><p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p>
<p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p>
<p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<strong>Tinyid</strong>[1] 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `sequence_id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `current_max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的长度&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type`    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p><code>current_max_id</code> 字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为：<code>current_max_id ~ current_max_id+step</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9saOqSOq4Csfq6icvJe4JgV6lzGa5V8NEKzL5LgLibPkiboVHImOYM6PLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>version</code> 字段主要用于解决并发问题（乐观锁）,<code>biz_type</code> 主要用于表示业余类型。</p>
<p><strong>2.先插入一行数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)</span><br><span class="line">VALUES</span><br><span class="line"> (1, 0, 100, 0, 101);</span><br></pre></td></tr></table></figure>

<p><strong>3.通过 SELECT 获取指定业务下的批量唯一 ID</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id current_max_id step version biz_type</span><br><span class="line">1 0 100 1 101</span><br></pre></td></tr></table></figure>

<p><strong>4.不够用的话，更新之后重新 SELECT 即可。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101</span><br><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id current_max_id step version biz_type</span><br><span class="line">1 100 100 1 101</span><br></pre></td></tr></table></figure>

<p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p>
<p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p>
<p><strong>数据库号段模式的优缺点:</strong></p>
<ul>
<li><strong>优点</strong> ：ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！）</li>
</ul>
<h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9JghiaeHx8iajibRsuSicbyDQ5xt8kjlPEzfUtrM2JW7Q428QAF1mvAU3tA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set sequence_id_biz_type 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr sequence_id_biz_type</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get sequence_id_biz_type</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p>
<p>除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案<strong>Codis</strong>[2]（大规模集群比如上百个节点的时候比较推荐）。</p>
<p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file, AOF）</strong>。并且，Redis 4.0 开始支持 <strong>RDB 和 AOF 的混合持久化</strong>（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <strong>JavaGuide 对于 Redis 知识点的总结</strong>[3]。</p>
<p><strong>Redis 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ：性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ：和数据库主键自增方案的缺点类似</li>
</ul>
<p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR91iaPzcniaVbSSfITGzMsf5Uia9rgQsbSho7FNL3a1UMNOKtMVOSTuINXA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MongoDB ObjectId 一共需要 12 个字节存储：</p>
<ul>
<li>0~3：时间戳</li>
<li>3~6：代表机器 ID</li>
<li>7~8：机器进程 ID</li>
<li>9~11 ：自增值</li>
</ul>
<p><strong>MongoDB 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ：性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ：需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p>
<p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa</span><br><span class="line">UUID.randomUUID()</span><br></pre></td></tr></table></figure>

<p><strong>RFC 4122</strong>[4] 中关于 UUID 的示例是这样的：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9hb4yCgtROOcJSNR2sR7QE8iaRWYkY3ia7eRZ2ibbclYbaN8OOThafZyjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p>
<p>5 种不同的 Version(版本)值分别对应的含义（参考<strong>维基百科对于 UUID 的介绍</strong>[5]）：</p>
<ul>
<li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li>
<li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li>
<li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li>
<li><strong>版本 4</strong> : UUID 使用<strong>随机性</strong>[6]或<strong>伪随机性</strong>[7]生成。</li>
</ul>
<p>下面是 Version 1 版本下生成的 UUID 的示例：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9N72mDd5gBRVAnNiccfxmZlF2HwfEvx1VqVzZjOich2FkiaN6WB3gRRrpg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的 UUID 的版本默认为 4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID uuid = UUID.randomUUID();</span><br><span class="line">int version = uuid.version();// 4</span><br></pre></td></tr></table></figure>

<p>另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p>
<p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。</p>
<p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p>
<p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p>
<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>
<ul>
<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li>
<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> （面试的时候可能会被问到的哦！） :</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、简单易用</li>
<li><strong>缺点</strong> ：存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li>
</ul>
<h4 id="Snowflake-雪花算法"><a href="#Snowflake-雪花算法" class="headerlink" title="Snowflake(雪花算法)"></a>Snowflake(雪花算法)</h4><p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>
<ul>
<li><strong>第 0 位</strong>：符号位（标识正负），始终为 0，没有用，不用管。</li>
<li><strong>第 1~41 位</strong> ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li>
<li><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群&#x2F;机房的节点。</li>
<li><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 &#x3D; 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9Lr5GfpSRB929XFOAibctzXnwjno6VPiaxeQ7HWfytRCSEFeya3JxY5ibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p>
<p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p>
<p>我们再来看看 Snowflake 算法的优缺点 ：</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li>
<li><strong>缺点</strong> ：需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li>
</ul>
<h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><h4 id="UidGenerator-百度"><a href="#UidGenerator-百度" class="headerlink" title="UidGenerator(百度)"></a>UidGenerator(百度)</h4><p><strong>UidGenerator</strong>[8] 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>
<p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9UhU3GE3jpD6DV7TQFBpNuhLvEmicd2aJIZcBpOcqG1OkLjQk5UdyTRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p>
<p>UidGenerator 官方文档中的介绍如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9BRTfT1lGQQgTvkk6EpuEdjibibtxxekKAk86J198RnoBDQmA8qLYjoFA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <strong>UidGenerator 的官方介绍</strong>[9]。</p>
<h4 id="Leaf-美团"><a href="#Leaf-美团" class="headerlink" title="Leaf(美团)"></a>Leaf(美团)</h4><p><strong>Leaf[10]</strong> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9mSsiaicEyM1cJd5hCIZ5bYNnxM0PQ1d0MG46mUI5rM3GCQjsRqFPLF3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p>
<p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p>
<p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<strong>《Leaf——美团点评分布式 ID 生成系统》</strong>[11]）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9uODg10puicse6nXFzUwzsSedn5H2mIkTwicCzthGbJxPUdKLcRPVuuXA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w&#x2F;s，TP999 1ms。</p>
<h4 id="Tinyid-滴滴"><a href="#Tinyid-滴滴" class="headerlink" title="Tinyid(滴滴)"></a>Tinyid(滴滴)</h4><p><strong>Tinyid</strong>[12] 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p>
<p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p>
<p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<strong>《Tinyid 原理介绍》</strong>[13]）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9e0lPpXDib598vd44sqZVwaEOgLZBCI6HrU2dvo9XJtbfJibxyagyzMvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p>
<p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p>
<ul>
<li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li>
<li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li>
</ul>
<p>除此之外，HTTP 调用也存在网络开销。</p>
<p>Tinyid 的原理比较简单，其架构如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxvGG82TFKGlhEkVE6zILR9Eshe53ynColhf5QuphPFK8N1U0bkSzyia7mFib7amZJQrHPdxLwqwzww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p>
<ul>
<li><strong>双号段缓存</strong> ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li>
<li><strong>增加多 db 支持</strong> ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li>
<li><strong>增加 tinyid-client</strong> ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li>
</ul>
<p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。</p>
<h2 id="分布式-ID-生成方案总结"><a href="#分布式-ID-生成方案总结" class="headerlink" title="分布式 ID 生成方案总结"></a>分布式 ID 生成方案总结</h2><p>这篇文章中，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。</p>
<p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。<strong>没有银弹，一定要结合实际项目来选择最适合自己的方案。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]Tinyid: <em><a target="_blank" rel="noopener" href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D</a></em>[2]Codis: <em><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></em>[3]JavaGuide 对于 Redis 知识点的总结: <em><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all">https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all</a></em>[4]RFC 4122: <em><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4122">https://tools.ietf.org/html/rfc4122</a></em>[5]维基百科对于 UUID 的介绍: <em><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81</a></em>[6]随机性: <em><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7">https://zh.wikipedia.org/wiki/随机性</a></em>[7]伪随机性: <em><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7">https://zh.wikipedia.org/wiki/伪随机性</a></em>[8]UidGenerator: <em><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator">https://github.com/baidu/uid-generator</a></em>[9]UidGenerator 的官方介绍: <em><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></em>[10]Leaf: <em><a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">https://github.com/Meituan-Dianping/Leaf</a></em>[11]《Leaf——美团点评分布式 ID 生成系统》: <em><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></em>[12]Tinyid: <em><a target="_blank" rel="noopener" href="https://github.com/didi/tinyid">https://github.com/didi/tinyid</a></em>[13]《Tinyid 原理介绍》: <em><a target="_blank" rel="noopener" href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0708(%E5%88%86%E5%B8%83%E5%BC%8FID)/" data-id="cld1buvtp002fbjopcb8ldynd" data-title="每日一问0708(分布式ID)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0712(clickhouse)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0712(clickhouse)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0712(clickhouse)/">每日一问0712(clickhouse)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h1><h2 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h2><p>Hbase、HP Vertica、EMC Greenplum等分布式数据库采用列式存储，当然这些数据库也有对行式存储的支持比如HP Vertica。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>行式数据库因为存贮数据是一行行的来存贮，而每一行数据的差异性太大，所以压缩比很小。列式数据库则不同，因为是按照一列列来存贮，每一列的数据的相同性极高，这就为压缩埋下了很好的种子，压缩比可以达到很大，可以达到5～20倍以上。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Ø 1.真正的面向列的DBMS</p>
<p>Ø 2.数据高效压缩</p>
<p>Ø 3.磁盘存储的数据</p>
<p>Ø 4.多核并行处理</p>
<p>Ø 5.在多个服务器上分布式处理</p>
<p>Ø 6.SQL语法支持</p>
<p>Ø 7.向量化引擎</p>
<p>Ø 8.实时数据更新</p>
<p>Ø 9.索引</p>
<p>Ø 10.适合在线查询</p>
<p>Ø 11.支持近似预估计算</p>
<p>Ø 12.支持嵌套的数据结构</p>
<p>Ø 支持数组作为数据类型</p>
<p>Ø 13.支持限制查询复杂性以及配额</p>
<p>Ø 14.复制数据复制和对数据完整性的支持</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/350b59e8ea68">ClickHouse概述</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0712(clickhouse)/" data-id="cld1buvtq002gbjopf41qgmc6" data-title="每日一问0712(clickhouse)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0714(面试词汇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0714(%E9%9D%A2%E8%AF%95%E8%AF%8D%E6%B1%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0714(%E9%9D%A2%E8%AF%95%E8%AF%8D%E6%B1%87)/">每日一问0714(面试词汇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面试词汇"><a href="#面试词汇" class="headerlink" title="面试词汇"></a>面试词汇</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>千方科技，智道网联科技(北京)有限公司</p>
<h2 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h2><p>云平台， kubernetes , 公有云 私有云，多云迁移工作</p>
<p>负责蘑菇智行运营平台的中台技术架构，包括网关(auth认证，限流，路由)</p>
<p>nacos 动态配置</p>
<p>微服务监控(admin,skywalking)</p>
<p>熔断监控（hystrix dashboard）</p>
<p>elck 日志采集</p>
<p>skywalking  链路监控，重写traceID</p>
<p>xxl-job 分布式任务调度接入</p>
<p>jenkins 重写二次开发 ，权限重写，pipeline 流水线自动生成。</p>
<p>minio 分布式对象存储服务二次开发</p>
<p>harbor 重写二次开发</p>
<p>ABTest实验平台，APM性能检测平台。</p>
<p>数字孪生</p>
<p>核心功能开发（抽奖算法，）</p>
<h3 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h3><p>kafka 优化 kafka 消费数据QPS 优化到 30w;</p>
<p>8分片 +8消费者 + broker4_副本4</p>
<p>EMQ</p>
<h2 id="做过的项目"><a href="#做过的项目" class="headerlink" title="做过的项目"></a>做过的项目</h2><p> 云平台 ，云监控 ，公有云私有云打通， 公有云写操作流量转发到私有云，公有云 只读</p>
<h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>截止到目前日均学习人数已达30W+</p>
<p>熟悉常见容器编排系统 如k8s及相关生态,Mesos，Openshift等。熟悉国内外多家容器云平台。</p>
<p>擅长端到端的DevOps,4年以上一线DevOps项目架构与运维经验，并具备较强的实施能力。</p>
<p>了解ServiceMesh,使用过Lstio等。</p>
<p>了解SOA及微服务（Spring Cloud）等架构</p>
<p>通过技术和研发提升效率。</p>
<p>利用Terraform和ansible技术栈研发了自动化的资源编排系统，使服务器资源上线耗时提升到分钟级别。</p>
<p>利用python研发了自动化的发布脚本，使发布时间达到分钟级，发布成功率达到了99%以上。</p>
<p>利用zabbix和openfaicon以及二次开发对生产环境系统进行用户角度和技术角度的全方位的监控和报警；</p>
<p>利用jenkins系统支撑每天数十次到上百次的持续集成与发布。</p>
<p>常年活跃在社区，开源爱好者</p>
<ol>
<li>技术先进性，实现redis使用aep介质上云，性能提升2.5倍，成本降低50%。</li>
<li>通过cgroup绑定cpu核,实现mysql写能力提升2.8倍，读能力提升1倍。</li>
<li>完成容器服务存储的监控功能、存储运维功能、自动扩容功能。</li>
<li>解决IOHang问题，并添加监控Latency&#x2F;IOHang告警,完成云存储可观测性。</li>
<li>完成 read-slave功能，写性能提升4倍。</li>
</ol>
<p>将业务迁移至容器k8s集群，有数千台容器级管理经验，从发布，日志，监控形成闭环。</p>
<p>从0到1独立完成CI&#x2F;CD,灾备系统，CMDB，基础设施即代码等多个运维自动化平台。</p>
<p>负责团队技术成长，曾多次参与技术分享与培训。</p>
<p>负责监督故障排查，解决以及复盘。</p>
<p>参与的K8s容器化项目，上线以来减少了故障率，提升了交付速度，节省了大量的人力，物力成本。获得了公司年度优秀项目</p>
<p>帮助团队解决技术难题，提升团队技术能力</p>
<p>协助总监指定部门相关流程，制度和规划，协调其他部门和本部门之间的工作。</p>
<p>负责生产环境稳定运行以及故障排查，解决，优化运维生产架构。</p>
<p>在容器化推广过程中，受到内部表扬，并给于现金奖励</p>
<p>保障..期间网站稳定。活动前梳理架构，整理应急预案，调整优化单点故障，升级硬件配置，集群横向扩展以及热备等，活动后整理相关数据，复盘，落地成文档。期间网站日活跃度达到500万UV</p>
<p>目标管理和绩效管理，定义分解团队的目标到个人，周期性考核。</p>
<p>团队之间协作，以服务的心态同其他部门们合作。</p>
<p>使各个产品服务在保障SLO在99.9%以上的情况下的最大化迭代速度（客户端每个月可以发布？次，服务端可以每周发布此书）</p>
<p>通过需求预测，容量规划，弹性伸缩使资源利用率维持在60-70%左右。</p>
<p>技术栈：Kubernetes,Github(gitlab)，Maven,Nexus,Harbor，Jenkins,SonarQube,Spinnaker，Argo,Teerafor吗，EFK，Prometheus，Skywalking,Jmeter,JIRA,Confluence, RocketMQ, Grafana</p>
<p>开发语言 ：java,javascript,shell,python,</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0714(%E9%9D%A2%E8%AF%95%E8%AF%8D%E6%B1%87)/" data-id="cld1buvtq002hbjopc4izez6b" data-title="每日一问0714(面试词汇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0716(AQS)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(AQS)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(AQS)/">每日一问0716(AQS)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="AQS-（AbstractQueuedSynchronizer）"><a href="#AQS-（AbstractQueuedSynchronizer）" class="headerlink" title="AQS （AbstractQueuedSynchronizer）"></a>AQS （AbstractQueuedSynchronizer）</h1><h2 id="啥是AQS"><a href="#啥是AQS" class="headerlink" title="啥是AQS"></a>啥是AQS</h2><ul>
<li><p>AQS 是 AbstractQueuedSynchronizer  的缩写</p>
</li>
<li><p>AbstractQueuedSynchronizer 是一个抽象类</p>
</li>
<li><p>AbstractQueued<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Sync">Sync</a>hronizer类继承AbstractOwnableSynchronizer</p>
</li>
<li><p>其有2个内部类，分别为Node和ConditionObject</p>
</li>
<li><p>有一个int 成员变量 表示同步状态，保证该成员变量的可见性 （voletile）</p>
</li>
<li><ul>
<li>Node  是队列同步其中的组成类，是放线程队列<strong>CLH（FIFO）队列</strong>（双向链表）的一个节点，</li>
</ul>
</li>
<li><p>有一个实现类 ，Sync ;Sync 来实现加锁逻辑</p>
</li>
<li></li>
</ul>
<h2 id="实现-锁需要具备以下几个核心要素"><a href="#实现-锁需要具备以下几个核心要素" class="headerlink" title="实现 锁需要具备以下几个核心要素"></a>实现 锁需要具备以下几个核心要素</h2><p>① 需要一个state变量，标记该锁的状态。state变量至少有两个值：0、1。对state变量的操作，要确保线程安全，也就是会用到CAS。</p>
<p>② 需要记录当前是哪个线程持有锁。</p>
<p>③ 需要底层支持对一个线程进行阻塞或唤醒操作。</p>
<p>④ 需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到CAS。</p>
<p>&#x3D;&#x3D;实现依赖：&#x3D;&#x3D;</p>
<ul>
<li><p>State  是 int 4个字节 32位；它是多线程可见的； 可以分为高16位，低16位，用来区分读写锁，一般写锁用一位(最多一个线程获取写锁),读锁 看自己实现 （可获取多把读锁） exclusiveOwnerThread&#x3D;该线程</p>
</li>
<li><p>针对要素③，在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是&#x3D;&#x3D;park&#x2F;unpark&#x3D;&#x3D;。有一个LockSupport的工具类，对这一对原语做了简单封装</p>
</li>
<li><p>CAS 操作</p>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>Syncronized重入的实现原理<br>任意一把Syncronized锁对象，使用java -c xx.class 编译以后会产生两个指令monitorEnter和monitorExit，这两个指令代表锁的获取和锁的释放，多出来的monitorExit是程序异常的时候，可以正常的释放锁。<br>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程指针当执行moniterenter时，如果目标锁对象的计数器为零，那么说明他没有被其他线程持有，java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1，在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么java虚拟机计数器可以加1否则需要等待，直至持有线程释放锁。当执行monitorexit时，java虚拟机则将锁对象的计数器减1，计数器为0说明锁已经释放<br>ReentrantLock可重入锁实现原理<br>实现加锁次数和释放锁次数不一致由于加锁次数和释放锁次数不一致，第二个线程始终无法获取到锁，导致一直等待正常情况下，加锁几次就要解锁几次.<br>ReentrantLock锁少释放的问题： 导致其他线程获取不到锁，程序会一直阻塞</p>
<h4 id="AQS作用"><a href="#AQS作用" class="headerlink" title="AQS作用"></a>AQS作用</h4><ul>
<li>加锁会导致阻塞，有阻塞就会排队，实现排队必然需要有某种形式的队列来进行管理</li>
</ul>
<h4 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h4><p>AQS为实现阻塞锁，<strong>依赖先进先出的一个等待依靠一个原子int值来表示状态</strong>，通过占用和释放方法，改变状态值AQS使用一个volatile的int类型的成员变量来表示同步状态，<strong>通过内置的FIFO队列来表示完成获取资源的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配</strong>，通过CAS完成对State值得修改</p>
<h4 id="AQS的变量"><a href="#AQS的变量" class="headerlink" title="AQS的变量"></a>AQS的变量</h4><ul>
<li>state变量： 判断是否阻塞<ul>
<li>阻塞需要排队（前提：自旋如果达到一定时间），实现排队必须需要队列</li>
</ul>
</li>
<li>Node节点的变量<ul>
<li>队列中每个队列的个体也就是Node</li>
</ul>
</li>
</ul>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>condition 是 lock 的内部类， condition 必须和lock 一起使用，</p>
<p>功能：定义线程阻塞 唤醒的条件</p>
<p>java.util.concurrent.locks.Condition是JUC提供的与Java的Object中wait&#x2F;notify&#x2F;notifyAll类似功能的一个接口，通过此接口，&#x3D;&#x3D;线程可以在某个特定的条件下等待&#x2F;唤醒。&#x3D;&#x3D;</p>
<p><strong>此外一把互斥锁可以绑定多个Condition，这意味着在同一把互斥锁上竞争的线程可以在不同的条件下等待，唤醒时可以根据条件来唤醒线程，这是Object中的wait&#x2F;notify&#x2F;notifyAll不具备的机制</strong></p>
<p>JUC中Condition接口的主要实现类是AQS的内部类ConditionObject，它内部维护了一个队列，我们可以称之为&#x3D;&#x3D;条件队列&#x3D;&#x3D;(有点像规则引擎)，在某个Condition上等待的线程被signal&#x2F;signalAll后，ConditionObject会将对应的节点转移到外部类AQS的等待队列中，线程需要获取到AQS等待队列的锁，才可以继续恢复执行后续的用户代码。</p>
<p>ConditionObject的firstWaiter&#x2F;lastWaiter以及AQS.Node的nextWaiter都是没有volatile修饰的。这是因为ConditionObject假设在await&#x2F;signal&#x2F;signalAll等方法的调用是已经持有互斥锁的。</p>
<p>最简单的处理方式是，对于不持锁的请求抛出异常，不应该依靠await -&gt; fullyRelease这一步来抛出异常，此时按照流程已经调用过addConditionWaiter了。可以在await这类方法前面与signal&#x2F;signalAll一样预检查一次持锁情况:</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44624375/article/details/110133306">深入理解 AQS 底层实现原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(AQS)/" data-id="cld1buvtq002ibjop860ie79j" data-title="每日一问0716(AQS)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0716(RocketMQ)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(RocketMQ)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(RocketMQ)/">每日一问0716(RocketMQ)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>优点：设计简单，把所有相同延迟时间的消息都先放到一个队列中，定时扫描，可以保证消息消费的有序性</p>
<p>缺点：定时器采用了timer，timer是单线程运行，如果延迟消息数量很大的情况下，可能单线程处理不过来，造成消息到期后也没有发送出去的情况</p>
<p>改进点：可以在每个延迟队列上各采用一个timer，或者使用timer进行扫描，加一个线程池对消息进行处理，这样可以提供效率</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8068221-37191def50a029aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c6a4ede528a8">rocketmq实现延时队列</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0716(RocketMQ)/" data-id="cld1buvtr002jbjop8yjm2ovm" data-title="每日一问0716(RocketMQ)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0719(开发遇到的坑)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0719(%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0719(%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91)/">每日一问0719(开发遇到的坑)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="开发过程中遇到的坑"><a href="#开发过程中遇到的坑" class="headerlink" title="开发过程中遇到的坑"></a>开发过程中遇到的坑</h1><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol>
<li>mybatis 一级缓存，查出的do如果被修改，那同一个线程第二次查询会查到修改后的值，</li>
</ol>
<p>​     怎么解决：</p>
<ol start="2">
<li><p>hystrix 默认 线程池默认10个线程,并发高了,就会报熔断的异常</p>
<p>解决: 调整核心线程数</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0719(%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91)/" data-id="cld1buvtr002kbjop175fg6nu" data-title="每日一问0719(开发遇到的坑)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>