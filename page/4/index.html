<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021/每日一问1101(垃圾回收)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/">每日一问1101(垃圾回收)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="带有垃圾回收的语言"><a href="#带有垃圾回收的语言" class="headerlink" title="带有垃圾回收的语言"></a>带有垃圾回收的语言</h2><ul>
<li><p>Lisp</p>
</li>
<li><p>Java</p>
</li>
<li><p>Ruby</p>
</li>
<li><p>Python</p>
</li>
<li><p>Perl</p>
</li>
<li><p>Haskell</p>
</li>
<li><p>go</p>
</li>
</ul>
<h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>我们将对象中保存对象本身信息的部分称为“头”。</p>
<p>我们把对象使用者在对象中可访问的部分称为“域”。</p>
<p>指针</p>
<p>mutator</p>
<p>分配（allocation）指的是在内存空间中分配对象。</p>
<p>堆指的是用于动态（也就是执行程序时）存放对象的内存空间。</p>
<h2 id="评价GC算法的性能时，我们采用以下4个标准。"><a href="#评价GC算法的性能时，我们采用以下4个标准。" class="headerlink" title="评价GC算法的性能时，我们采用以下4个标准。"></a>评价GC算法的性能时，我们采用以下4个标准。</h2><ul>
<li>吞吐量（在单位时间内的处理能力）</li>
<li>最大暂停时间 （“因执行GC而暂停执行mutator的最长时间）</li>
<li>堆使用效率</li>
<li>访问的局部性</li>
</ul>
<p><img src="/../../ImgSource/image-20211102174303616.png" alt="image-20211102174303616"></p>
<h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>（如何分配内存）第2行的pickup_chunk()函数用于遍历$free_list，寻找大于等于size的分块。它不光会返回和size大小相同的分块，还会返回比size大的分块。如果它找到和size大小相同的分块，则会直接返回该分块；如果它找到比size大的分块，则会将其分割成size大小的分块和去掉size后剩余大小的分块，并把剩余的分块返回&#x3D;&#x3D;空闲链表&#x3D;&#x3D;。如果此函数没有找到合适的分块，则会返回NULL。返回NULL时分配是不会进行的。为了处理这种情况，我们在代码清单2.5中调用了之前在1.6节提到的allocation_fail()函数。</p>
<ul>
<li>first-fit  选择最先</li>
<li>best-fit 选择最佳</li>
<li>Worst-fit 选择最差</li>
</ul>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>碎片化</li>
<li>与标记-压缩，复制算法不兼容</li>
<li>分配速度慢 》由于分块是不连续的，因此每次分配都要遍历整个空闲链表，找到足够大的内存块，最糟的情况就是每次进行分配都得把空闲链表遍历到最后。</li>
<li>与&#x3D;&#x3D;写时复制技术&#x3D;&#x3D;不兼容</li>
</ol>
<h3 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h3><p>查找三个大小的分块只需遍历一次</p>
<p><img src="/../../ImgSource/image-20211115095756139.png" alt="image-20211115095756139"></p>
<p>要多少个空闲链表合适呢？我们通常会给分块大小设定一个上限，分块如果大于等于这个大小，就全部采用一个空闲链表处理。</p>
<h3 id="BI-BOP-法"><a href="#BI-BOP-法" class="headerlink" title="BI-BOP 法"></a>BI-BOP 法</h3><p>把堆分割成固定大小的块，让每个块只能配置同样大小的对象。这就是BiBOP法。</p>
<h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。像这样集合了用于标记的位的表格称为“位图表格”（bitmap table），利用这个表格进行标记的行为称为“位图标记”。位图表格的实现方法有多种，例如散列表和树形结构等。</p>
<h2 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h2><p>可以减少暂停时间     </p>
<p>因为延迟清除法不是一下遍历整个堆，它只在分配时执行必要的遍历，所以可以压缩因清除操作而导致的mutator的暂停时间。这就是“延迟”清除操作的意思。         </p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>优点：</p>
<ul>
<li>可即刻回收垃圾</li>
<li>最大暂停时间短</li>
</ul>
<p>缺点：</p>
<ul>
<li>计数器值的增减处理繁重</li>
<li>计数器需要占用很多位</li>
<li>实现烦琐复杂</li>
</ul>
<h2 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h2><p>优点： 在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了因根引用频繁发生变化而导致的计数器增减所带来的额外负担。</p>
<p> 缺点： 为了延迟计数器值的增减，垃圾不能马上得到回收，这样一来垃圾就会压迫堆，我们也就失去了引用计数法的一大优点——可即刻回收垃圾。 </p>
<p>要搜索的对象就越多，妨碍mutator运作的时间也就越长。</p>
<h2 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h2><p>然而事实上有很多研究表明，很多对象一生成马上就死了（详情请参考第7章）。也就是说，在很多情况下，计数器的值会在0到1的范围内变化，鲜少出现5位计数器溢出这样的情况。</p>
<p>对于计数器溢出的对象，我们可以这样处理：不再增减计数器的值，就把它放着，什么也不做。用其他算法回收</p>
<h2 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h2><p>回收不了 ，引用溢出，和循环引用的对象</p>
<h2 id="部分标记-清除算法"><a href="#部分标记-清除算法" class="headerlink" title="部分标记-清除算法"></a>部分标记-清除算法</h2><p>​	只回收循环引用对象，</p>
<p>部分标记-清除算法的优点，就是把要搜索的对象限定在阴影对象及其子对象，也就是“可能是循环垃圾的对象群”中</p>
<p>1．黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）</p>
<p>2．白（WHITE）：绝对是垃圾的对象</p>
<p>3．灰（GRAY）：搜索完毕的对象</p>
<p>4．阴影（HATCH）：可能是循环垃圾的对象</p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>优点：</p>
<ul>
<li>因为GC复制算法只搜索并复制活动对象，所以跟一般的GC标记-清除算法相比，它能在较短时间内完成GC。也就是说，其吞吐量优秀。尤其是堆越大，差距越明显。</li>
<li>可实现高速分配：GC复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。</li>
<li>不会发生碎片化</li>
<li>与缓存兼容</li>
</ul>
<p>缺点： </p>
<ul>
<li>堆使用效率低下</li>
<li>不兼容保守式GC算法 因为会移动对象</li>
<li>递归调用函数  因为在每次递归调用时都会消耗栈，所以还有栈溢出的可能。</li>
</ul>
<h3 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a>Cheney的GC复制算法</h3><p>Fenichel和Yochelson的GC复制算法采用的是深度优先搜索，而Cheney的复制算法采用的则是广度优先搜索。</p>
<p>优点： </p>
<p>Fenichel和Yochelson的GC复制算法是递归算法，而Cheney的GC复制算法是迭代算法，因此它可以抑制调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜索的内存空间这一点，实在是令人赞叹。</p>
<p>缺点：</p>
<p>没法沾缓存的光 因此我们没法说Cheney的GC复制算法兼容缓存，只能说它比GC标记-清除算法和引用计数法要好一些而已。</p>
<h4 id="近似深度优先算法"><a href="#近似深度优先算法" class="headerlink" title="近似深度优先算法"></a>近似深度优先算法</h4><p>这是因为此算法采用的不是完整的广度优先搜索，而是在每个页面上分别进行广度优先搜索。这里利用了我们在4.5.1节中提到的广度优先搜索的性质，即在搜索一开始把有引用关系的对象安排在同一个页面中。</p>
<p><img src="/../../ImgSource/image-20211115142356100.png" alt="image-20211115142356100"></p>
<p>![image-20211115142257041](..&#x2F;..&#x2F;ImgSource&#x2F;image-20211115142257041.png                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>
<p><img src="/../../ImgSource/image-20211115142334139.png" alt="image-20211115142334139"></p>
<h4 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h4><p>我们不把堆分成2份，而是分成10份，其中需要拿出2块空间分别作为From空间和To空间来执行GC复制算法。反正无论如何都要空出1块空间来当To空间，那我们就把这个额外负担降到整体的1&#x2F;10就行了。</p>
<p>多空间复制算法说白了就是把堆N等分，对其中2块空间执行GC复制算法，对剩下的（N-2）块空间执行GC标记-清除算法，也就是把这2种算法组合起来使用。</p>
<p>首先在第2行调查参数obj是否在From空间里。如果在From空间里，那么它就是GC复制算法的对象。这时就通过copy()函数复制obj，返回新空间的地址。如果obj不在From空间里，它就是GC标记-清除算法的对象。这时要设置标志位，对其子对象递归调用mark_or_copy()函数。最后不要忘了返回obj。</p>
<p>优点：</p>
<p>多空间复制算法没有将堆二等分，而是分割成了更多块空间，从而更有效地利用了堆。以往的GC复制算法只能使用半个堆，而多空间复制算法仅仅需要空出一个分块，不能使用的只有1&#x2F;N个堆。</p>
<p>缺点：</p>
<p>执行GC复制算法的只有N等分中的两块空间，对于剩下的（N-2）块空间执行的是GC标记-清除算法。因此就出现了GC标记-清除算法固有的问题——分配耗费时间、分块碎片化等。</p>
<h2 id="GC标记-压缩算法"><a href="#GC标记-压缩算法" class="headerlink" title="GC标记-压缩算法"></a>GC标记-压缩算法</h2><p>不过它跟GC复制算法不同，不用牺牲半个堆。</p>
<p>压缩阶段由以下3个步骤构成。</p>
<p>1．设定forwarding指针</p>
<p>2．更新指针</p>
<p>3．移动对象</p>
<p>优点：</p>
<ul>
<li>GC标记-压缩算法和其他算法相比而言，堆利用效率高。</li>
<li>GC标记-压缩算法不会出现GC复制算法那样只能利用半个堆的情况。GC标记-压缩算法可以在整个堆中安排对象，堆使用效率几乎是GC复制算法的2倍。用“几乎”这个词，是因为要留出用于forwarding指针的空间，所以严格来说不到2倍。</li>
</ul>
<p>缺点： </p>
<p>压缩花费计算成本 </p>
<p>在本节介绍的Lisp2算法的压缩中，必须对整个堆进行3次搜索。也就是说，执行该算法所花费的时间是和堆大小成正比的。GC标记-压缩算法的吞吐量要劣于其他算法。</p>
<h4 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a>Two-Finger算法</h4><p>优点： 压缩所带来的搜索次数只有2次，比Lisp2算法少1次，在吞吐量方面占优势。</p>
<p>缺点：我们基本上也无法期待这个算法能沾缓存的光。</p>
<p>此外该算法还有一个限制条件，那就是所有对象的大小必须一致。</p>
<h4 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h4><p>优点： 这是因为在表格算法中，可以通过缓存来提高对象的访问速度。</p>
<h4 id="ImmixGC算法"><a href="#ImmixGC算法" class="headerlink" title="ImmixGC算法"></a>ImmixGC算法</h4><p>这个算法虽然以GC标记-清除算法为基础，不过根据情况也会执行压缩。</p>
<p>这个算法不是以对象为单位，而是以线为单位回收垃圾的。</p>
<h2 id="种类指的是“保守式GC”和“准确式GC”"><a href="#种类指的是“保守式GC”和“准确式GC”" class="headerlink" title="种类指的是“保守式GC”和“准确式GC”"></a>种类指的是“保守式GC”和“准确式GC”</h2><h4 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h4><p>不能识别指针和非指针的GC</p>
<p>在采用GC标记-清除算法的情况下，一找到貌似指针的非指针，程序就会将非指针指向的对象错误地识别为活动对象，对其进行标记。因为被错误识别的对象不会被废弃而会被保留，所以遵守了GC的原则——“不废弃活动对象”。像这样，在运行GC时采取的是一种保守的态度，即“把可疑的东西看作指针，稳妥处理”，所以我们称这种方法为“保守式GC”。	</p>
<p>不明确时候怎么回收？当基于不明确的根运行GC时，我们就要从对象的头部获取对象的类型信息。</p>
<p>缺点：</p>
<ul>
<li>识别指针和非指针需要付出成本</li>
<li>错误识别指针会压迫堆</li>
<li>能够使用的GC算法有限</li>
</ul>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>在对象中导入了“年龄”的概念，通过优先回收容易成为垃圾的对象，提高垃圾回收的效率。</p>
<p>大部分的对象在生成后马上就变成了垃圾，很少有对象能活得很久。在对象中导入了“年龄”的概念，经历过一次GC后活下来的对象年龄为1岁。</p>
<p>我们将对新对象执行的GC称为新生代GC（minor GC）</p>
<p>分代垃圾回收不是跟GC标记-清除算法和GC复制算法并列在一起供我们选择的算法，而是需要跟这些基本算法一并使用。</p>
<h3 id="Ungar的分代垃圾回收"><a href="#Ungar的分代垃圾回收" class="headerlink" title="Ungar的分代垃圾回收"></a>Ungar的分代垃圾回收</h3><p>我们总共需要利用4个空间，分别是生成空间、2个大小相等的幸存空间以及老年代空间，并分别用$new_start、$survivor1_start、$survivor2_start、$old_start这4个变量引用它们的开头。</p>
<p>此外我们准备出一个和堆不同的数组，称为记录集（remembered set），设为$rs。</p>
<p><img src="/../../ImgSource/image-20211115153449169.png" alt="image-20211115153449169"></p>
<h4 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h4><p>在记录集里不会记录引用的目标对象，而是记录发出引用的对象。</p>
<p><img src="/../../ImgSource/image-20211115154148157.png" alt="image-20211115154148157"></p>
<h4 id="写入屏障（write-barrier）"><a href="#写入屏障（write-barrier）" class="headerlink" title="写入屏障（write barrier）"></a>写入屏障（write barrier）</h4><p>老年代GC中利用了GC标记-清除算法</p>
<h3 id="新生代GC"><a href="#新生代GC" class="headerlink" title="新生代GC"></a>新生代GC</h3><p><img src="/../../ImgSource/image-20211115154908723.png" alt="image-20211115154908723"></p>
<p>注意： 幸存空间满了怎么办？</p>
<p>&#x3D;&#x3D;当发生这种情况时，稳妥起见只能把老年代空间作为复制的目标空间。当然，如果频繁发生这种情况，分代垃圾回收的优点就会淡化。&#x3D;&#x3D;</p>
<p>优点：</p>
<ul>
<li>通过使用分代垃圾回收，可以改善GC所花费的时间（吞吐量）。正如Ungar所说的那样：“据实验表明，分代垃圾回收花费的时间是GC复制算法的1&#x2F;4。”可见分代垃圾回收的导入非常明显地改善了吞吐量。</li>
<li>分代垃圾回收来缩减mutator最大暂停时间</li>
</ul>
<p>缺点：</p>
<ul>
<li>在部分程序中会起到反作用</li>
<li>写入屏障导致的额外负担降低了吞吐量。</li>
</ul>
<h4 id="卡片标记"><a href="#卡片标记" class="headerlink" title="卡片标记"></a>卡片标记</h4><h4 id="页面标记"><a href="#页面标记" class="headerlink" title="页面标记"></a>页面标记</h4><h2 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h2><p>分代数量越多，对象变成垃圾的机会也就越大，所以这个方法确实能减少活到最老代的对象。但是我们也不能过度增加分代数量。分代数量越多，每代的空间也就相应地变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。</p>
<h2 id="列车垃圾回收"><a href="#列车垃圾回收" class="headerlink" title="列车垃圾回收"></a>列车垃圾回收</h2><p>列车垃圾回收中将老年代空间按照一定大小划分，每个划分出来的空间称为车厢，由1个以上的车厢连接成的东西就叫作列车。这就是列车垃圾回收名字的由来。1次老年代GC是以1个车厢作为GC对象的。</p>
<p>每个列车和每个车厢都按其产生的顺序被赋予了编号，互相连接。车厢就是以这个顺序作为GC对象的。</p>
<p>新生代GC ：第10行的obj_to_car()函数会返回参数obj所属的车厢，get_last_car()则会返回参数car所属列车的&#x3D;&#x3D;最后一节车厢&#x3D;&#x3D;。</p>
<p>老年代GC：</p>
<p><img src="/../../ImgSource/image-20211115161508835.png" alt="image-20211115161508835"></p>
<p> &#x3D;&#x3D;从第一节车厢开始，老年代GC是以开头列车的开头车厢作为GC对象的。第一节车厢，剩下的对象会被copy 到最后一节车厢，如果to_car装不下这些对象，那么我们就新连接一节空车厢。&#x3D;&#x3D;</p>
<p>列车垃圾回收之所以能回收跨多个块（在这里也就是车厢）的大型垃圾，是因为列车垃圾回收会把互相引用的对象安排在同一辆列车上。</p>
<p>不过对于比车厢大的对象，需要将其安排到新生代空间和老年代空间以外的堆，使用跟列车垃圾回收不同的方法来执行GC。</p>
<p><img src="/../../ImgSource/image-20211115160905022.png" alt="image-20211115160905022"></p>
<p>注意：记录集的溢出</p>
<p>本来记录集满了就意味着此车厢里挤满了受欢迎（也就是被引用数非常大）的对象。这样的对象很难成为垃圾，每次执行GC都需要对其进行复制操作。为了省去花费在这项复制操作上的时间，我们有个办法，那就是索性把车厢C排除到GC对象的范围之外去。这看上去像是白白浪费了一个车厢，不过考虑到车厢C中大多数对象都会在执行GC后存活下来，所以一开始就不对其执行GC可能要更为划算些。</p>
<h2 id="增量式垃圾回收（Incremental-GC）"><a href="#增量式垃圾回收（Incremental-GC）" class="headerlink" title="增量式垃圾回收（Incremental GC）"></a>增量式垃圾回收（Incremental GC）</h2><p><img src="/../../ImgSource/image-20211115161630235.png" alt="image-20211115161630235"></p>
<p>三色标记法</p>
<p>· 白色：还未搜索过的对象</p>
<p>· 灰色：正在搜索的对象</p>
<p>· 黑色：搜索完成的对象</p>
<p>增量式垃圾回收不是一口气运行GC，而是和mutator交替运行的，因此不会长时间妨碍到mutator的运行。增量式垃圾回收适合那些比起提高吞吐量，更重视缩短最大暂停时间的应用程序。</p>
<h2 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h2><h4 id="合并性引用计数法"><a href="#合并性引用计数法" class="headerlink" title="合并性引用计数法"></a>合并性引用计数法</h4><p>于是人们开发出了一种方法，就是把注意力放在某一时期最初和最后的状态上，在该期间内不进行计数器的增减。这就是合并型引用计数法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/" data-id="cld1buvtx002vbjop0v1fdbgk" data-title="每日一问1101(垃圾回收)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1102(go学习)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/">每日一问1102(go学习)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="go-学习"><a href="#go-学习" class="headerlink" title="go 学习"></a>go 学习</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>学习目的</p>
</li>
<li><p>可以做什么</p>
</li>
<li><p>特性 </p>
<p>协程</p>
<p>语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高）</p>
</li>
<li><p>适用于哪些场景</p>
</li>
</ol>
<p> 它适合做网络编程，服务器编程，分布式系统，数据库系统，云平台，等。</p>
<ol>
<li>学习方法</li>
</ol>
<p>《A Tour of Go（Go语言之旅）》 (最新官方英文：<a href="https://link.zhihu.com/?target=https://tour.golang.org/">https://tour.golang.org/</a>，第三方中文翻译：<a href="https://link.zhihu.com/?target=https://tour.go-zh.org/">https://tour.go-zh.org/</a>) </p>
<p>《Effective Go（实效Go编程）》 (最新官方英文：<a href="https://link.zhihu.com/?target=https://golang.org/doc/effective_go">https://golang.org/doc/effective_go</a>，第三方中文翻译：<a href="https://link.zhihu.com/?target=https://go-zh.org/doc/effective_go.html">https://go-zh.org/doc/effective_go.html</a>)</p>
<ol>
<li>框架</li>
<li>高级</li>
<li>周边</li>
<li>就业方向</li>
<li>学到什么程度</li>
<li>问题</li>
</ol>
<p>  用 go 是不是会造成学习多门 都不精的情况？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/" data-id="cld1buvtx002wbjop8kni8s2i" data-title="每日一问1102(go学习)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1107(linux)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/">每日一问1107(linux)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="服务器对比"><a href="#服务器对比" class="headerlink" title="服务器对比"></a>服务器对比</h2><table>
<thead>
<tr>
<th></th>
<th>Ubuntu</th>
<th>CentOS</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>CentOS（Community Enterprise Operating System，社区企业操作系统</td>
</tr>
<tr>
<td></td>
<td></td>
<td>相比Ubuntu, CentOS拥有更高的稳定性，但是用户界面相对欠缺。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>systemctl是一个系统管理守护进程、工具和库的集合，用于取代System V、service和chkconfig命令，初始进程主要负责控制systemd系统和服务管理器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/" data-id="cld1buvty002xbjopbci25hum" data-title="每日一问1107(linux)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1108(云原生)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/">每日一问1108(云原生)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><p>随着物联网设备的大爆发，必然会产生大量的数据，以及随之而来的数据处理和数据安全等需求，而这些已经无法通过传统云计算的集中式处理方式来满足（比如带宽、实时性、隐私以及能耗等），于是就产生了边缘计算。边缘计算的核心目的就是拉近云端和物联网终端的距离，降低网络延迟，提供新的服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/" data-id="cld1buvty002ybjop9kh11f4s" data-title="每日一问1108(云原生)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1111(Quakus)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/">每日一问1111(Quakus)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Quakus"><a href="#Quakus" class="headerlink" title="Quakus"></a>Quakus</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/" data-id="cld1buvty002zbjopfswk1tve" data-title="每日一问1111(Quakus)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1112(docker概念篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1112(docker%E6%A6%82%E5%BF%B5%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1112(docker%E6%A6%82%E5%BF%B5%E7%AF%87)/">每日一问1112(docker概念篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="docker概念篇"><a href="#docker概念篇" class="headerlink" title="docker概念篇"></a>docker概念篇</h1><h1 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h1><p>支持Linux的IoT设备越来越多，比如流行的树莓派、香蕉派、LattePanda。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1112(docker%E6%A6%82%E5%BF%B5%E7%AF%87)/" data-id="cld1buvtz0030bjop4wbi2s2p" data-title="每日一问1112(docker概念篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1118(kafka概念篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1118(kafka%E6%A6%82%E5%BF%B5%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1118(kafka%E6%A6%82%E5%BF%B5%E7%AF%87)/">每日一问1118(kafka概念篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="kafka-概念篇"><a href="#kafka-概念篇" class="headerlink" title="kafka 概念篇"></a>kafka 概念篇</h1><h2 id="kafka-集群结构"><a href="#kafka-集群结构" class="headerlink" title="kafka 集群结构"></a>kafka 集群结构</h2><p><img src="/../../ImgSource/640" alt="avatar"></p>
<p>从图上可以看出</p>
<ul>
<li>Producer 是单独的多个</li>
<li>多了zookeeper 集群，用来收发消息</li>
<li>kafka 的工作单元是 broker ，它会在 zk上注册</li>
<li>消费者可以有 组 group,group 内的消费者可以并行消费，但不会重复消费</li>
</ul>
<h3 id="为什么分区-Partition-能保证并行消费"><a href="#为什么分区-Partition-能保证并行消费" class="headerlink" title="为什么分区(Partition)能保证并行消费"></a>为什么分区(Partition)能保证并行消费</h3><p><img src="/../../ImgSource/640" alt="avatar"><br>如果有两个分区，最多两个消费者同时消费，消费的速度肯定会更快。分区的设计大大的提升了kafka的吞吐量！！<br><img src="/../../ImgSource/640" alt="avatar"></p>
<p>从这个图可以看出什么？</p>
<ul>
<li>一个partition只能被同组的一个consumer消费（图中只会有一个箭头指向一个partition）</li>
<li>同一个组里的一个consumer可以消费多个partition（图中第一个consumer消费Partition 0和3）</li>
<li>消费效率最高的情况是partition和consumer数量相同。这样确保每个consumer专职负责一个partition。</li>
<li>consumer数量不能大于partition数量。由于第一点的限制，当consumer多于partition时，就会有consumer闲置。</li>
</ul>
<p>5、consumer group可以认为是一个订阅者的集群，其中的每个consumer负责自己所消费的分区</p>
<h3 id="副本怎么高可用"><a href="#副本怎么高可用" class="headerlink" title="副本怎么高可用"></a>副本怎么高可用</h3><p>一个topic 下有多个分区 ，每个分区可以有多个副本 ，分区下都是副本 ，但只有一个leader 其他的是 follower，<br>工作流程:小心进来 先进入leader replica,然后从leader 复制到 follower。<code>只有复制完成时，consumer 才可以消费此消息</code>，这是为了确保意外发生，数据可以恢复</p>
<h3 id="“如果不同partition的leader-replica在kafka集群的broker上分布不均匀，就会造成负载不均衡。”-怎么理解这句话？"><a href="#“如果不同partition的leader-replica在kafka集群的broker上分布不均匀，就会造成负载不均衡。”-怎么理解这句话？" class="headerlink" title="“如果不同partition的leader replica在kafka集群的broker上分布不均匀，就会造成负载不均衡。” 怎么理解这句话？"></a>“如果不同partition的leader replica在kafka集群的broker上分布不均匀，就会造成负载不均衡。” 怎么理解这句话？</h3><p>先看下图<br><img src="/../../ImgSource/640" alt="avatar"></p>
<ul>
<li>broker 注册在  zk 上，是最小的工作单元</li>
<li>每个broker 上可以有多个 分区，</li>
<li>如果有多个分区，每个分区有一个leader replica ，在 broker上分布的越均匀，负载就越好。</li>
</ul>
<h3 id="怎么保证leader-replica-均匀分布在broker-上呢？"><a href="#怎么保证leader-replica-均匀分布在broker-上呢？" class="headerlink" title="怎么保证leader replica 均匀分布在broker 上呢？"></a>怎么保证leader replica 均匀分布在broker 上呢？</h3><p>kafka通过轮询算法保证leader replica是均匀分布在多个broker上。</p>
<ul>
<li>Replica均匀分配在Broker上，同一个partition的replica不会在同一个borker上</li>
<li>同一个partition的Replica数量不能多于broker数量。多个replica为了数据安全，一台server存多个replica没有意义。server挂掉，上面的副本都要挂掉。</li>
<li>分区的leader replica均衡分布在broker上。此时集群的负载是均衡的。这就叫做分区平衡</li>
</ul>
<h4 id="怎么实现分区平衡？"><a href="#怎么实现分区平衡？" class="headerlink" title="怎么实现分区平衡？"></a>怎么实现分区平衡？</h4><ul>
<li>AR  分区中的所有副本统称为AR（Assigned Replicas）</li>
<li>PR (优先 replica) 在分区平衡时 可做参照，优先选择 leader 的 副本。一开始PR是和Leader replica 一致的，当leader 宕机，换了以后，一段时间再进行分区平衡时，就会以这个做参照。</li>
<li>ISR 同步最新的副本情况。每个patition 都有自己的 ISR ;所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas）</li>
</ul>
<p>分区平衡步骤：<br>当一开始进行分区选举 是平衡的；过一段时间 leader 宕机，follower 当上了leader ，此时应该是不平衡的；一会原来的replica 恢复了，但此时只能做小弟；<br>kafka 会定时触发分区加平衡操作，也可以主动触发；触发后重新通过选举 ，然后 PR里的有优先选举权，之前的replica又恢复了leader ,平衡操作就是让leader副本归位。</p>
<h3 id="Partition的读和写"><a href="#Partition的读和写" class="headerlink" title="Partition的读和写"></a>Partition的读和写</h3><p><img src="/../../ImgSource/640" alt="avatar"></p>
<ul>
<li>producer 采用round-robin算法 ，轮训往 partition里写入</li>
<li>每个 consumer 都维护了自己的 offset ，就是消费到了 patition什么位置，一个patition可以供多个consumer 消费，</li>
</ul>
<ol>
<li><p>每个分区是由多个Segment组成，当Kafka要写数据到一个partition时，它会写入到状态为active的segment中。如果该segment被写满，则一个新的segment将会被新建，然后变成新的“active” segment。</p>
</li>
<li><p>偏移量：分区中的每一条消息都会被分配的一个连续的id值，该值用于唯一标识分区中的每一条消息。</p>
</li>
<li><p>每个segment中则保存了真实的消息数据。每个Segment对应于一个索引文件与一个日志文件。segment文件的生命周期是由Kafka Server的配置参数所决定的。比如说，server.properties文件中的参数项log.retention.hours&#x3D;168就表示7天后删除老的消息文件。</p>
</li>
</ol>
<h3 id="kafka-实现高吞吐的原理"><a href="#kafka-实现高吞吐的原理" class="headerlink" title="kafka 实现高吞吐的原理"></a>kafka 实现高吞吐的原理</h3><ul>
<li>读写文件依赖OS文件系统的页缓存，而不是在JVM内部缓存数据，利用OS来缓存，内存利用率高</li>
<li>sendfile技术（零拷贝），避免了传统网络IO四步流程</li>
<li>支持End-to-End的压缩</li>
<li>顺序IO以及常量时间get、put消息</li>
<li>Partition 可以很好的横向扩展和提供高并发处理</li>
</ul>
<h3 id="kafka-怎么保证不重复消费"><a href="#kafka-怎么保证不重复消费" class="headerlink" title="kafka 怎么保证不重复消费"></a>kafka 怎么保证不重复消费</h3><ul>
<li>正常情况下 ,kafka 有 offset ，记录 patition 当前消费的位置</li>
<li>异常情况，offset 没更新宕机了，这时要在业务里加幂等性判断。</li>
</ul>
<h2 id="Kafka中的消息是否会丢失和重复消费："><a href="#Kafka中的消息是否会丢失和重复消费：" class="headerlink" title="Kafka中的消息是否会丢失和重复消费："></a>Kafka中的消息是否会丢失和重复消费：</h2><h3 id="消息是否会重复消费："><a href="#消息是否会重复消费：" class="headerlink" title="消息是否会重复消费："></a>消息是否会重复消费：</h3><p>   Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p>
<blockquote>
<p><em>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制； <em><strong>*不存在消息丢失*</strong></em></em></p>
<p><em>High-level API：封装了对parition和offset的管理，使用简单；           <em><strong>*会存在消息丢失*</strong></em></em></p>
</blockquote>
<p>​    如果使用****高级接口High-level API***<em>，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“</em>诡异*”的消失了； </p>
<h3 id="kafka的负载均衡算法"><a href="#kafka的负载均衡算法" class="headerlink" title="kafka的负载均衡算法"></a>kafka的负载均衡算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. A=(partition数量/同组内消费者总个数) </span><br><span class="line">2. M=对上面所得到的A值小数点第一位向上取整 </span><br><span class="line">3. 计算出该消费者拉取数据的patition合集：Ci = [P(M*i )~P((i + 1) * M -1)]</span><br></pre></td></tr></table></figure>

<h3 id="offset（位移管理）"><a href="#offset（位移管理）" class="headerlink" title="*** offset（位移管理）****"></a>*** offset（位移管理）****</h3><p>​    老版本的位移是提交到zookeeper中的，但是zookeeper其实并不适合进行大批量的读写操作，尤其是写操作。因此kafka提供了另一种解决方案：增加__consumeroffsets topic，将offset信息写入这个topic，摆脱对zookeeper的依赖(指保存offset这件事情)。__consumer_offsets中的消息保存了每个consumer group某一时刻提交的offset信息。</p>
<p> ****早期版本的 kafka 用 zk 做 meta 信息存储*<em><strong>，consumer 的消费状态，group 的管理以及 offse t的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，</strong></em>*新版本中确实逐渐弱化了zookeeper的作用****。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖。</p>
<h3 id="（7）Zookeeper-在-Kafka-中的作用"><a href="#（7）Zookeeper-在-Kafka-中的作用" class="headerlink" title="*（7）Zookeeper 在 Kafka 中的作用*"></a><em><strong>*（7）Zookeeper 在 Kafka 中的作用*</strong></em></h3><p>   (1.0版本)kafaka集群的 broker，和 Consumer 都需要连接 Zookeeper。Producer 直接连接 Broker，Topic 分区被放在不同的 Broker 中，保证 Producer 和 Consumer 错开访问 Broker，避免访问单个 Broker造成过度的IO压力，使得负载均衡。</p>
<h3 id="partition是如何与group对应的"><a href="#partition是如何与group对应的" class="headerlink" title="partition是如何与group对应的"></a>partition是如何与group对应的</h3><p>原理:Zookeerper中保存这每个topic下的每个partition在每个group中消费的offset 。<em><strong>*新版kafka把这个offsert保存到了一个__consumer_offsert的topic下*</strong></em> ，这个__consumer_offsert 有50个分区，通过将****group的id哈希值%50的值来确定要保存到那一个分区****。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算方法：（放到哪个分区）</span><br><span class="line">int hashCode=Math.abs(&quot;$&#123;group_name&#125;&quot;.hashCode())</span><br><span class="line">int partition= hashCode%50</span><br><span class="line">先计算group的hashCode ,再取余50，可以得到 partition的值</span><br></pre></td></tr></table></figure>

<h2 id="生产者的负载均衡"><a href="#生产者的负载均衡" class="headerlink" title="生产者的负载均衡"></a>生产者的负载均衡</h2><p> 使用Zookeeper进行负载均衡，由于****每个Broker启动*<em><strong>时，都会完成</strong></em>*Broker注册过程*<em><strong>，生产者会通过该</strong></em>*节点的变化来动态地感知到Broker服务器列表的变更*<em><strong>，这样就可以实现</strong></em>*动态的负载均衡机制****。</p>
<h3 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h3><p>与生产者类似，Kafka中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的Broker服务器上接收消息，每个消费者分组包含若干消费者，<strong>每条消息都只会发送给分组中的一个消费者</strong>，不同的消费者分组消费自己特定的Topic下面的消息，互不干扰。</p>
<h2 id="在集群负载均衡方面"><a href="#在集群负载均衡方面" class="headerlink" title="在集群负载均衡方面"></a>在集群负载均衡方面</h2><p>​     kafka采用zookeeper对集群中的broker、consumer进行管理，可以****注册topic到zookeeper上*<em><strong>；通过</strong></em>*zookeeper的协调机制****，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。</p>
<h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><ol>
<li>Partition的多个replica中一个为Leader，其余为follower</li>
<li>Producer只与Leader交互，把数据写入到Leader中</li>
<li>Followers从Leader中拉取数据进行数据同步</li>
<li>Consumer只从Leader拉取数据</li>
</ol>
<h3 id="kafka-幂等性"><a href="#kafka-幂等性" class="headerlink" title="kafka 幂等性"></a>kafka 幂等性</h3><p>参考 <strong>Kafka 事务性之幂等性实现</strong></p>
<h2 id="不利的地方"><a href="#不利的地方" class="headerlink" title="不利的地方"></a>不利的地方</h2><ul>
<li>重复消息。Kafka 只保证每个消息至少会送达一次，虽然几率很小，但一条消息有可能会被送达多次。 </li>
<li>消息乱序。虽然一个Partition 内部的消息是保证有序的，但是如果一个Topic 有多个Partition，Partition 之间的消息送达不保证有序。 </li>
<li>复杂性。Kafka需要zookeeper 集群的支持，Topic通常需要人工来创建，部署和维护较一般消息队列成本更高</li>
</ul>
<p><img src="/../../ImgSource/v2-f2b0e154b566e2bb573de4c9ff88544f_b.jpg" alt="img"></p>
<h2 id="kafka零拷贝"><a href="#kafka零拷贝" class="headerlink" title="kafka零拷贝"></a>kafka零拷贝</h2><p><img src="/../../ImgSource/FOi-gjZVgAQdG9B" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>微信读书：深入理解KAFKA：核心设计与实践原理1.1</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1118(kafka%E6%A6%82%E5%BF%B5%E7%AF%87)/" data-id="cld1buvtz0031bjopcaxzaq7u" data-title="每日一问1118(kafka概念篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1224(HashMap)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(HashMap)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(HashMap)/">每日一问1224(HashMap)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HashMap-TreeMap-LinedHashMap"><a href="#HashMap-TreeMap-LinedHashMap" class="headerlink" title="HashMap ,TreeMap,LinedHashMap"></a>HashMap ,TreeMap,LinedHashMap</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(HashMap)/" data-id="cld1buvu00032bjop0i639aya" data-title="每日一问1224(HashMap)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2022/代码质量和安全性检测" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2022/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%B5%8B/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2022/">2022</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2022/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%B5%8B/">代码质量和安全性检测</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="代码质量和安全性检测"><a href="#代码质量和安全性检测" class="headerlink" title="代码质量和安全性检测"></a>代码质量和安全性检测</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ETVA5WVZpYmlhMWRTNXJpYWF2ZHBMaHpiSEZCTlRKblNtSEM0MzFLQjBIaWJCS0w0R0prVjk0enI4eklpYXhrMkdzSEVvWXdjMGhMemliQW9RQW41RW5sWTZrQS82NDA?x-oss-process=image/format,png" alt="img"></p>
<ol>
<li>最佳实践：通过 @iceworks&#x2F;eslint-plugin-best-practices 分析项目，提出符合当前工程特征（对 ice 和 Rax项目友好）的最佳实践及阻塞问题发布卡口，帮助开发者优化项目性能，避免潜在 bug 。</li>
<li>安全实践：通过 @iceworks&#x2F;eslint-plugin-security-practices 扫码代码检测工程中可能存在的安全风险，包含 url 、敏感成词、明文账密信息及 npm 包证书检测，降低项目安全风险，守卫项目安全。</li>
<li>阿里代码规范：这一维度主要反馈开发人员对于 eslint-config-ali 阿里开发规约的遵守程度。</li>
<li>可维护度：通过 typhonjs-escomplex 对文件进行扫码，得出每个文件的可维护度，可读性及复杂度评分。针对得分较差的文件可以进行深度分析帮助开发者更好的重构复杂代码。</li>
<li>重复度：通过 jscpd 计算重复出现的代码区块占比，计算出 clone 分数。并逐一列举重复的代码，方便开发者快速定位重复代码，将其封装成公共的方法或者组件。</li>
</ol>
<h2 id="Sorna"><a href="#Sorna" class="headerlink" title="Sorna"></a>Sorna</h2><ul>
<li>Sornalint</li>
<li>sornaQube</li>
</ul>
<p> SonarQube 是开源的代码质量管理平台，以 web 页面形式（即<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Sonar&spm=1001.2101.3001.7020">Sonar</a> Dashboard）可视化形式检查代码质量；SonarLint 是 SonarQube 提供的插件，可以安装在各个 IDE 工具。</p>
<p>Sonar 可以从七个维度检测代码质量：</p>
<ul>
<li>代码规则——sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写；</li>
<li>潜在的缺陷——通过PMD，CheckStyle，Findbugs 等代码规则检测工具检测出潜在的缺陷；</li>
<li>复杂度——无论对于类还是方法，都不宜过长，长意味着复杂，问题丛生……。</li>
<li>重复——sonar会检查重复片段，此时需要重构并提取共有逻辑；</li>
<li>注释不足或者过多——关键的代码片段不能没有注释，注释得简洁有意义，且需要及时更新；</li>
<li>单元测试——sonar可以很方便地统计并展示单元测试覆盖率；</li>
<li>架构与设计——通过sonar可以找出循环，展示包与包、类与类之间相互依赖关系，可以检测自定义的架构规则 通过sonar可以管理第三方的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测耦合。</li>
</ul>
<h2 id="Alibaba-coding-guiding"><a href="#Alibaba-coding-guiding" class="headerlink" title="Alibaba coding guiding"></a>Alibaba coding guiding</h2><p>提供 IDEA 插件 Alibaba java coding guideline，方便集成在IDEA，实时发现并修改不规范代码。有一份详细的 pdf 文档《码出高效：阿里巴巴 Java 开发手册》解释编码规范；</p>
<h2 id="Simian"><a href="#Simian" class="headerlink" title="Simian"></a>Simian</h2><p>冗余代码检查工具，非免费，支持语言： C#，C，C++，，COBOL，Ruby，JSP，ASP，HTML，XML，Visual Basic等。<br>支持Windows。</p>
<h2 id="SourceMonitor"><a href="#SourceMonitor" class="headerlink" title="SourceMonitor"></a>SourceMonitor</h2><p>代码度量工具，免费，针对不同的语言（包括但不限于 C、C++、C#、Java、VB、Delphi和HTML），输出不同的代码度量值。SourceMonitor从几个不同的视图层次，如项目视图、检查点(checkpoint)视图和函数视图，展示如下度量值：</p>
<ol>
<li>总行数(Lines)：包括空行在内的代码行数；</li>
<li>语句数(Statements)：在C语言中，语句是以分号结尾的。</li>
<li>分支语句if，循环语句for、while，跳转语句goto都被计算在内，预处理语句#include、#define#undef也被计算在内，对其他的预处理语句则不作计算，在#else和#endif、#elif和#endif之间的语句将被忽略；</li>
<li>分支语句比例(Percent Branch Statements)：该值表示分支语句占语句数目的比例，分支语句 指的是使程序不顺序执行的语句，包括if、else、for、while和switch；</li>
<li>注释比例(Percent Lines with Comments)：该值指示注释行（包括&#x2F;* *&#x2F;和&#x2F;&#x2F;形式）占总行数的比例；</li>
<li>函数数目(Functions)：指示函数的数量；</li>
</ol>
<h2 id="代码审查（code-review）工具"><a href="#代码审查（code-review）工具" class="headerlink" title="代码审查（code-review）工具"></a>代码审查（code-review）工具</h2><ul>
<li>Review Board</li>
<li>jArchitect</li>
<li>RhodeCode</li>
<li>Codebrag</li>
<li>Crucible</li>
<li>Malevich</li>
<li>Gerrit</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2022/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8C%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%B5%8B/" data-id="cld1buvu00033bjop00rzhhny" data-title="代码质量和安全性检测" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2022/异常规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2022/%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2022/">2022</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2022/%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83/">异常规范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h1><h2 id="接入规范"><a href="#接入规范" class="headerlink" title="接入规范"></a>接入规范</h2><ol>
<li>gitlab 创建Springboot 脚手架 项目 </li>
<li>向管理人员申请 两位 项目code码</li>
<li>本项目中 创建 BusinessExceptionEnum  如下图:</li>
<li><img src="/../../ImgSource/image-20221108183803673.png" alt="image-20221108183803673"></li>
<li>按九位异常code码规范 定义自己系统的异常code码</li>
<li>可以在本系统创建 BusinessException 继承 BaseExcepion 类，然后实现 抛出 BusinessExceptionEnum   中定义的异常信息 如下图</li>
<li><img src="/../../ImgSource/image-20221108185011195.png" alt="image-20221108185011195"></li>
<li>系统触发异常时，抛出BusinessException 异常</li>
</ol>
<h2 id="九位异常code-码规范"><a href="#九位异常code-码规范" class="headerlink" title="九位异常code 码规范"></a>九位异常code 码规范</h2><p>0 | 0|0| 00| 0000</p>
<h3 id="第一位：-是否发邮件"><a href="#第一位：-是否发邮件" class="headerlink" title="第一位： 是否发邮件"></a>第一位： 是否发邮件</h3><p>取值：1-9</p>
<ul>
<li><p>9-表示:发邮件异常</p>
</li>
<li><p>其他-通用异常 无处理</p>
</li>
</ul>
<h3 id="第二位：预定义异常，本框架提前定义好的几种异常类型"><a href="#第二位：预定义异常，本框架提前定义好的几种异常类型" class="headerlink" title="第二位：预定义异常，本框架提前定义好的几种异常类型"></a>第二位：预定义异常，本框架提前定义好的几种异常类型</h3><p>取值：0-9</p>
<ul>
<li>9-系统异常</li>
<li>8-业务异常</li>
<li>7-数据库操作条数异常</li>
<li>6-权限错误</li>
<li>5-会话失效</li>
<li>其他-通用异常 无处理</li>
</ul>
<h3 id="第三位：前端弹窗、跳转等交互类型"><a href="#第三位：前端弹窗、跳转等交互类型" class="headerlink" title="第三位：前端弹窗、跳转等交互类型"></a>第三位：前端弹窗、跳转等交互类型</h3><p>取值：0-9</p>
<ul>
<li>9- 异常错误 （红色弹框）</li>
<li>8-警告错误  （黄色弹窗）</li>
<li>7-提醒错误  </li>
<li>1- 表示跳转到登录页</li>
<li>0- 无弹窗</li>
</ul>
<h3 id="第四五位：微服务唯一标识code"><a href="#第四五位：微服务唯一标识code" class="headerlink" title="第四五位：微服务唯一标识code"></a>第四五位：微服务唯一标识code</h3><p>取值：00-99</p>
<p>例子: </p>
<ul>
<li>01- 《运行评价》微服务 ；</li>
<li>02-《系统设置》微服务</li>
</ul>
<h3 id="第六七八九位：-业务自定义异常code码"><a href="#第六七八九位：-业务自定义异常code码" class="headerlink" title="第六七八九位： 业务自定义异常code码"></a>第六七八九位： 业务自定义异常code码</h3><p>取值：0000-9999</p>
<p>例子:</p>
<ul>
<li>9998- 查找用户信息不存在</li>
<li>9997-数据库连接失败</li>
<li>0001-账号密码错误</li>
</ul>
<h3 id="总体例子"><a href="#总体例子" class="headerlink" title="总体例子"></a>总体例子</h3><ul>
<li>999019997 表示：发邮件，系统异常，前端红色弹框，运行评价 微服务  数据库连接失败</li>
<li>189020001 表示：不发邮件，业务异常，前端红色弹框，系统设置 微服务  账号密码错误</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2022/%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83/" data-id="cld1buvu10034bjopenqjc9sw" data-title="异常规范" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>