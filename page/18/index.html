<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/18/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020/每日一问0426(Spring)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0426(Spring)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0426(Spring)/">每日一问0426(Spring)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="框架结构图"><a href="#框架结构图" class="headerlink" title="框架结构图"></a>框架结构图</h3><p><img src="/../../ImgSource/spring_jiegou.png" alt="avatar"></p>
<p>● Spring核心容器（Core）：提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（IoC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开；<br>● Spring上下文（Context）：Spring上下文是一个配置文件，为Spring框架提供上下文信息。Spring上下文包括企业服务，例如JNDI、EJB、电子邮件、国际化、校验和调度功能；<br>● Spring AOP：通过配置管理特性，Spring AOP模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务，通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中；<br>● Spring DAO：JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO的面向JDBC的异常遵从通用的DAO异常层次结构；<br>● Spring ORM：在Spring框架中插入了若干个ORM框架，从而提供了ORM的对象关系工具，其中包括JDO、Hibernate、iBatis SQL Map和TopLink。所有这些都遵从Spring的通用事务和DAO异常层次结构；<br>● Spring Web模块：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供上下文。所以，Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求，以及将请求参数绑定到域对象的工作；<br>● Spring MVC框架：Spring的MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变为可高度配置的，MVC容纳了大量视图技术，其中包括JSP、Velocity、Tiles、iText和POI。</p>
<h2 id="Spring组件包详解"><a href="#Spring组件包详解" class="headerlink" title="Spring组件包详解"></a>Spring组件包详解</h2><p><img src="/../../ImgSource/spring_baojiegou.png" alt="avatar"><br><img src="/../../ImgSource/spring_baojiegou2.png" alt="avatar"><br><img src="/../../ImgSource/spring_baojiegou3.png" alt="avatar"><br><img src="/../../ImgSource/spring_baojiegou4.png" alt="avatar"><br><img src="/../../ImgSource/spring_baojiegou5.png" alt="avatar"><br><img src="/../../ImgSource/spring_baojiegou6.png" alt="avatar"></p>
<h2 id="IOC-依赖注入"><a href="#IOC-依赖注入" class="headerlink" title="IOC 依赖注入"></a>IOC 依赖注入</h2><p><img src="/../../ImgSource/spring_ioc_code.png" alt="avatar"></p>
<h3 id="利用反射机制实现IOC"><a href="#利用反射机制实现IOC" class="headerlink" title="利用反射机制实现IOC"></a>利用反射机制实现IOC</h3><p>我们可以把IoC模式看做是工厂模式的升华，IoC好比是是一个大工厂，只不过在这个大工厂里生成的对象都是在XML文件中给出定义，然后利用Java的“反射”编程，并根据XML中给出的类名生成的。</p>
<p>反射是一种强大的工具，但也存在一些不足，其一个主要的缺点就是对性能有影响。使用反射基本上是一种解释操作，你可以告诉JVM希望做什么并且它将满足你的要求。这类操作总是慢于只直接执行的相同的操作。不过这一点在JDK1.5中已经得到了改善，你可以放心的使用IoC容器的反射机制。</p>
<p>###依赖注入的3种类型</p>
<ul>
<li>接口注入<br><img src="/../../ImgSource/spring_zhuru1.png" alt="avatar"></li>
<li>构造注入<br><img src="/../../ImgSource/spring_zhuru2.png" alt="avatar"></li>
<li>设值注入<br><img src="/../../ImgSource/spring_zhuru3.png" alt="avatar"></li>
</ul>
<h3 id="PostConstruct-注解"><a href="#PostConstruct-注解" class="headerlink" title="@PostConstruct 注解"></a>@PostConstruct 注解</h3><p>@PostConstruct该注解被用来修饰一个非静态的void（）方法。</p>
<p>Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtils</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MyUtils</span>          <span class="variable">staticInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyUtils</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyMethorClassService    myService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        staticInstance.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">invokeBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> staticInstance.myService.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0426(Spring)/" data-id="cld1bs9su0012fynh5xhm6e9n" data-title="每日一问0426(Spring)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0427(redis原理篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0427(redis%E5%8E%9F%E7%90%86%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0427(redis%E5%8E%9F%E7%90%86%E7%AF%87)/">每日一问0427(redis原理篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="redis-原理-Redis-设计与实现"><a href="#redis-原理-Redis-设计与实现" class="headerlink" title="redis 原理(Redis 设计与实现)"></a>redis 原理(Redis 设计与实现)</h1><h2 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>结构 ：</p>
<ul>
<li>字符长度，</li>
<li>未使用空间</li>
<li>字节数组</li>
</ul>
<p>优点:</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时，所需的内存重分配次数</li>
<li>兼容部分C字符串函数</li>
</ul>
<h3 id="SDS-内存预分配策略"><a href="#SDS-内存预分配策略" class="headerlink" title="SDS 内存预分配策略"></a>SDS 内存预分配策略</h3><p>为了防止 合并字符串，截取字符串造成内存重新分配带来的开销</p>
<p>小于1M，多分配一倍，大于1M 多分配一M （另外会多加一字节空字符标识字符结束）</p>
<h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>惰性空间释放主要用于优化SDS字符串的缩短操作。不是立即释放多出来的字节，而是用free属性，将多出来的记录下来。避免了内存重分配操作，并且为将来有可能增长操作提供了优化。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串必须符合某种编码(ASCll)，并且尾端不能有空字符串，这样会被认为是字符末尾，这些限制使得C字符串不能保存像图片、音视频之类的二进制数据。<br>SDS是采用二进制安全的(binary-safe)，处理二进制方式处理数据，怎么存的怎么取。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="字典-HashMap"><a href="#字典-HashMap" class="headerlink" title="字典 HashMap"></a>字典 HashMap</h4><ul>
<li>拉链法解决hash冲突（插入是头插法，因为单线程，索引没有死循环问题）</li>
</ul>
<h5 id="rehash-过程-（渐进式Rehash）-扩容"><a href="#rehash-过程-（渐进式Rehash）-扩容" class="headerlink" title="rehash 过程 （渐进式Rehash） 扩容"></a>rehash 过程 （渐进式Rehash） 扩容</h5><ul>
<li>有 A——map 进行 rehash , 首先分配 A长度*2 的 B-Map，</li>
<li>将A值copy到 B<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渐进式Rehash 是在rehash 期间 增删改查 在两个字典上，分批次不断的copy到B Map,（增加操作只在BMap也就是新Map中）</span><br></pre></td></tr></table></figure></li>
<li>将B设置为A </li>
<li>将A 释放</li>
</ul>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>多级索引，遍历链表</p>
<p>如果一个有序集合包含的<strong>元素数量比较多</strong>,又或者有序集合中元素的<strong>成员是比较长的字符串</strong>时, Redis就会使用跳跃表来作为有序集合健的底层实现。</p>
<p><img src="https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="跳跃表"></p>
<ul>
<li>跳跃表基于单链表加索引的方式实现</li>
<li>跳跃表以空间换时间的方式提升了查找速度</li>
<li>Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现</li>
<li>Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点</li>
<li>Redis每个跳跃表节点的层高都是1至32之间的随机数</li>
<li>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。</li>
</ul>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><ul>
<li>整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作,不支持降级操作。</li>
</ul>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><h3 id="redis-过期健删除策略"><a href="#redis-过期健删除策略" class="headerlink" title="redis 过期健删除策略"></a>redis 过期健删除策略</h3><p>可能的删除策略有 定时删除、惰性删除、定期删除<br>但是定时删除会抢CPU资源，惰性删除对内存不友好，所以采用 惰性删除+定期删除。</p>
<p>惰性删除: 所有Redis 读写命令 都会调用expireIfNeeded 函数，如果过期，先删除键，再执行下边操作。</p>
<p>定期随机删除: 全局变量记录检查进度，每次从一定数据数据库中随机删除。</p>
<p>另外 过期的键也不会写入 RDB中。</p>
<h2 id="RDB和-AOF"><a href="#RDB和-AOF" class="headerlink" title="RDB和 AOF"></a>RDB和 AOF</h2><ul>
<li>RDB 全量复制 ，有阻塞和非阻塞 两种 （<code>同步刷盘和异步刷盘</code>），非阻塞是新开子进程，进行复制。</li>
<li>AOF 是 增量复制  增量日志</li>
</ul>
<ol>
<li>Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</li>
<li>RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</li>
<li>Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。</li>
<li>AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。</li>
<li>Redis 针对 AOF文件大的问题，提供重写的瘦身机制。</li>
<li>若只打算用Redis 做缓存，可以关闭持久化。</li>
<li>若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/11268067.html">redis结构-整数集合</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0427(redis%E5%8E%9F%E7%90%86%E7%AF%87)/" data-id="cld1bs9sv0013fynh7gm3fgpy" data-title="每日一问0427(redis原理篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0428(负载均衡)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)/">每日一问0428(负载均衡)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="常见负载均衡算法"><a href="#常见负载均衡算法" class="headerlink" title="常见负载均衡算法"></a>常见负载均衡算法</h2><ul>
<li>简单轮训法</li>
<li>源地址哈希法</li>
<li>随机法</li>
<li>加权轮训法</li>
<li>加权随机法</li>
<li>最小连接数法</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html">常见负载均衡算法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0428(%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)/" data-id="cld1bs9sv0014fynh2gquazdq" data-title="每日一问0428(负载均衡)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0430(Mybatis)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Mybatis)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Mybatis)/">每日一问0430(Mybatis)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><ul>
<li>SQL  </li>
<li>ScriptRunner</li>
<li>SqlRunner</li>
<li>MetaObject<br><img src="/../../ImgSource/mybatis.png" alt="avatar"></li>
</ul>
<h2 id="SqlSession执行-Mapper-过程"><a href="#SqlSession执行-Mapper-过程" class="headerlink" title="SqlSession执行 Mapper 过程"></a>SqlSession执行 Mapper 过程</h2><p>MyBatis中Mapper的配置分为两部分，分别为Mapper接口和Mapper SQL配置。MyBatis通过动态代理的方式创建Mapper接口的代理对象，MapperProxy类中定义了Mapper方法执行时的拦截逻辑，通过MapperProxyFactory创建代理实例，MyBatis启动时，会将MapperProxyFactory注册到Configuration对象中。另外，MyBatis通过MappedStatement类描述Mapper SQL配置信息，框架启动时，会解析Mapper SQL配置，将所有的MappedStatement</p>
<p>对象注册到Configuration对象中。通过Mapper代理对象调用Mapper接口中定义的方法时，会执行MapperProxy类中的拦截逻辑，将Mapper方法的调用转换为调用SqlSession提供的API方法。在SqlSession的API方法中通过Mapper的Id找到对应的MappedStatement对象，获取对应的SQL信息，通过StatementHandler操作JDBC的Statement对象完成与数据库的交互，然后通过ResultSetHandler处理结果集，将结果返回给调用者。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>一级缓存:基于SqlSession，一级缓存默认开启，不能关闭 当前会话中有效，执行sqlSession commit()、close()、clearCache()操作会清除缓存。</li>
<li>二级缓存: 基于Mapper，需要手工开启，全局级别缓存,与mapper namespace相关。</li>
</ul>
<h3 id="一级缓存使用"><a href="#一级缓存使用" class="headerlink" title="一级缓存使用"></a>一级缓存使用</h3><p>MyBatis提供了一个配置参数localCacheScope，用于控制一级缓存的级别，该参数的取值为SESSION、STATEMENT，当指定localCacheScope参数值为SESSION时，缓存对整个SqlSession有效，只有执行DML语句（更新语句）时，缓存才会被清除。当localCacheScope值为STATEMENT时，缓存仅对当前执行的语句有效，当语句执行完毕后，缓存就会被清空。</p>
<h3 id="一级缓存事务相关"><a href="#一级缓存事务相关" class="headerlink" title="一级缓存事务相关"></a>一级缓存事务相关</h3><ul>
<li>不开启事务，一级缓存失效(数据库会话关闭)</li>
<li>开启事务，一级缓存有效(会话未提交)</li>
<li>事务里一级缓存的坑：多次查询相同的条件，第一次修改了返回值（未与数据库进行交互）,后几次查询都是修改后的值，</li>
<li>避免坑 localCacheScope 设置为 STATEMENT</li>
</ul>
<h3 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h3><ul>
<li><p>BlockingCache：阻塞版本的缓存装饰器，能够保证同一时间只有一个线程到缓存中查找指定的Key对应的数据。</p>
</li>
<li><p>FifoCache：先入先出缓存装饰器，FifoCache内部有一个维护具有长度限制的Key键值链表（LinkedList实例）和一个被装饰的缓存对象，Key值链表主要是维护Key的FIFO顺序，而缓存存储和获取则交给被装饰的缓存对象来完成</p>
</li>
<li><p>LoggingCache：为缓存增加日志输出功能，记录缓存的请求次数和命中次数，通过日志输出缓存命中率。</p>
</li>
<li><p>LruCache：最近最少使用的缓存装饰器，当缓存容量满了之后，使用LRU算法淘汰最近最少使用的Key和Value。LruCache中通过重写LinkedHashMap类的removeEldestEntry()方法获取最近最少使用的Key值，将Key值保存在LruCache类的eldestKey属性中，然后在缓存中添加对象时，淘汰eldestKey对应的Value值。具体实现细节读者可参考LruCache类的源码。</p>
</li>
<li><p>ScheduledCache：自动刷新缓存装饰器，当操作缓存对象时，如果当前时间与上次清空缓存的时间间隔大于指定的时间间隔，则清空缓存。清空缓存的动作由getObject()、putObject()、removeObject()等方法触发。</p>
</li>
<li><p>SerializedCache：序列化缓存装饰器，向缓存中添加对象时，对添加的对象进行序列化处理，从缓存中取出对象时，进行反序列化处理。</p>
</li>
<li><p>SoftCache：软引用缓存装饰器，SoftCache内部维护了一个缓存对象的强引用队列和软引用队列，缓存以软引用的方式添加到缓存中，并将软引用添加到队列中，获取缓存对象时，如果对象已经被回收，则移除Key，如果未被回收，则将对象添加到强引用队列中，避免被回收，如果强引用队列已经满了，则移除最早入队列的对象的引用。</p>
</li>
<li><p>SynchronizedCache：线程安全缓存装饰器，SynchronizedCache的实现比较简单，为了保证线程安全，对操作缓存的方法使用synchronized关键字修饰。</p>
</li>
<li><p>TransactionalCache：事务缓存装饰器，该缓存与其他缓存的不同之处在于，TransactionalCache增加了两个方法，即commit()和rollback()。当写入缓存时，只有调用commit()方法后，缓存对象才会真正添加到TransactionalCache对象中，如果调用了rollback()方法，写入操作将被回滚</p>
</li>
<li><p>WeakCache：弱引用缓存装饰器，功能和SoftCache类似，只是使用不同的引用类型。</p>
</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p> CachingExecutor 二级缓存执行类</p>
<p> ，CachingExecutor类中维护了一个TransactionalCacheManager实例，TransactionalCacheManager用于管理所有的二级缓存对象</p>
<p> cacheEnabled属性值为true（开启了二级缓存）</p>
<h3 id="二级缓存工作流程"><a href="#二级缓存工作流程" class="headerlink" title="二级缓存工作流程"></a>二级缓存工作流程</h3><p>在CachingExecutor的query()方法中，首先调用createCacheKey()方法创建缓存Key对象，然后调用MappedStatement对象的getCache()方法获取MappedStatement对象中维护的二级缓存对象。然后尝试从二级缓存对象中获取结果，如果获取不到，则调用目标Executor对象的query()方法从数据库获取数据，再将数据添加到二级缓存中。当执行更新语句后，同一命名空间下的二级缓存将会被清空。 </p>
<h3 id="缓存回收策略"><a href="#缓存回收策略" class="headerlink" title="缓存回收策略"></a>缓存回收策略</h3><p>eviction: 缓存回收策略，有这几种回收策略</p>
<ul>
<li>LRU - （<code>默认</code>）最近最少回收，移除最长时间不被使用的对象</li>
<li>FIFO - 先进先出，按照缓存进入的顺序来移除它们</li>
<li>SOFT - 软引用，移除基于垃圾回收器状态和软引用规则的对象</li>
<li>WEAK - 弱引用，更积极的移除基于垃圾收集器和弱引用规则的对象</li>
</ul>
<h3 id="二级缓存注意事项"><a href="#二级缓存注意事项" class="headerlink" title="二级缓存注意事项"></a>二级缓存注意事项</h3><ul>
<li>缓存是以namespace为单位的，不同namespace下的操作互不影响。</li>
<li>insert,update,delete操作会清空所在namespace下的全部缓存。</li>
<li>通常使用MyBatis Generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。</li>
<li>多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。</li>
</ul>
<h2 id="Mybatis-使用"><a href="#Mybatis-使用" class="headerlink" title="Mybatis 使用"></a>Mybatis 使用</h2><ul>
<li>一对多 使用Collection 配置 A，B 实现一对多</li>
<li>多对一 resultMap标签中配置<association></association>标签关联所属的用户实体</li>
</ul>
<p>参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/62c3207071a4957c62cf0b7kc81322c012c81e728d9d180">Mybatis 3 源码深度解析</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013018207">记一次 Mybatis 一级缓存清理无效引起的源码走读</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0430(Mybatis)/" data-id="cld1bs9sw0015fynhayznhyy5" data-title="每日一问0430(Mybatis)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0501(算法)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0501(%E7%AE%97%E6%B3%95)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0501(%E7%AE%97%E6%B3%95)/">每日一问0501(算法)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="LRU-最少使用算法"><a href="#LRU-最少使用算法" class="headerlink" title="LRU 最少使用算法"></a>LRU 最少使用算法</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>左子节点：2i+1</li>
<li>右子节点：<img src="/../../ImgSource/image-20211231112533735.png" alt="image-20211231112533735">2i+2</li>
<li>父节点：(i-1)&#x2F;2</li>
<li>最后一个非叶子节点:(arr.length-1-1)&#x2F;2&#x3D;arr.length&#x2F;2-1</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>构建大顶堆，从最后一个非叶子结点开始，先比较左右子节点找到最大的，然后将最大的和父节点比较，看是否替换；一次比较完了，还要看替换的子节点下在进行一次相同的比较。</li>
<li>开始替换根节点和最后一个节点的值，再次进行构建大顶堆，范围比上一次少一个节点。</li>
</ol>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>步骤：</p>
<ol>
<li>从0开始，拿出值， 先从后边比较，再从开始比较，大于0的放后边小于零的放前边，最终找到0拿出来的值最合适的位置，将其置换</li>
<li>然后分成两部分，分别递归。</li>
</ol>
<h2 id="深度优先搜索和广度优先搜索"><a href="#深度优先搜索和广度优先搜索" class="headerlink" title="深度优先搜索和广度优先搜索"></a>深度优先搜索和广度优先搜索</h2><p>对象旁边的号码表示搜索顺序。</p>
<p><img src="/../../ImgSource/image-20211102174743175.png" alt="image-20211102174743175"></p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>思路  </p>
<ol>
<li><p>准备  待遍历数组 ，当前元素取值位置，预备结果集，是否使用过标识</p>
</li>
<li><p>遍历数组 ，每个数组元素进行一次 dfs ，填装结果集（可能进行深copy） </p>
</li>
<li><p>dfs 一次是 深度加1 ，然后递归</p>
</li>
<li><p>枝剪 ：结果集超了位置则进行回溯，（一般在dfs 递归调用下边）回溯退回一个元素，然后下边的继续遍历 终止条件 当深度足够或 结果集合适 则添加结果集</p>
</li>
</ol>
<p>每一次尝试都「复制」，则不需要回溯<br>如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么</p>
<p>在回到上一层结点的时候不需要「回溯」；<br>在递归终止的时候也不需要做拷贝。</p>
<p>做题的时候，建议 &#x3D;&#x3D;先画树形图&#x3D;&#x3D; ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：</p>
<p>分支如何产生；<br>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？<br>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p>
<h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><p>算法总结</p>
<ol>
<li><p>巧用递归，一定要设定终止位置 ，否则很危险</p>
</li>
<li><p>栈 可用来解决 对称 匹配 出战入栈 （「[{}]」）</p>
</li>
<li><p>队列 可用于各种结构按自定义顺序入队列 比如二叉树 根据遍历方式不同 入队列 广度优先遍历</p>
</li>
<li><p>可引入map（无重复），数组（下标对应）用空间换时间的方式做一些优化 统计个数的时候可以考虑用hashMap做去重</p>
</li>
<li><p>回溯法，动态规划法，双指针+排序</p>
</li>
<li><p>摩尔投票法 ，两两抵消 ，留下最多；</p>
</li>
<li><p>优先队列  用堆    前多少 个元素，后多少个元素， 只用跟对顶对比  ： 思路  堆未满 先填充，堆满了 跟堆顶比较 ，合适就进堆，不合适 下一个，最后输出堆。</p>
</li>
<li><p>算法中使用list 别忘了值传递 要用 深copy  new ArrayList&lt;&gt;(arr);</p>
</li>
<li><p>回溯算法思路  （<br> 0） 准备  待遍历数组，当前元素取值位置，预备结果集，是否使用过标识</p>
</li>
</ol>
<ol>
<li>遍历数组 ，每个数组元素进行一次 dfs ，填装结果集（可能进行深copy） </li>
<li>dfs 一次是 深度加1 ，然后递归<br>3） 枝剪 ：结果集超了位置则进行回溯，（一般在dfs 递归调用下边）回溯退回一个元素，然后下边的继续遍历 终止条件 当深度足够或 结果集合适 则添加结果集</li>
</ol>
<p>）</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><h3 id="1）回溯法总结-Backtracking（回溯法）"><a href="#1）回溯法总结-Backtracking（回溯法）" class="headerlink" title="1）回溯法总结 Backtracking（回溯法）"></a>1）回溯法总结 Backtracking（回溯法）</h3><p>场景<br>除了可以解决与集合排列、组合相关的问题，回溯法还能解决很多算法面试题。如果解决一个问题需要若干步骤，并且每一步都面临若干选项，当在某一步做了某个选择之后前往下一步仍然面临若干选项，那么可以考虑尝试用回溯法解决。通常，回溯法可以用递归的代码实现。</p>
<p>思路<br>8. 一般都是按步骤来，把一道题抽象成很多步骤组成。<br>2. 注意数据的copy 问题<br>3. 标记当前位置<br>7. 执行下一步所有可能情况。也就是转化成树的结构，然后深度遍历<br>4. 给定所有可用元素 一般  数字范围，数组 二维数组<br>5. 结果集 用来装所有结果<br>6. 重复判断 重复判断方式 可以用 map，set ,数组 位置</p>
<ol>
<li>list.remove() 进行回退，</li>
</ol>
<p>变种</p>
<p>分治、贪心、回溯和动态规划等算法思想，二分查找、深度优先遍历和广度优先遍历、双指针、滑动窗口、位运算、并查集等解题思路和技巧，以及通用解题“套路”和解题模板等内容</p>
<p>算法总结</p>
<ol>
<li>巧用递归，一定要设定终止位置 ，否则很危险</li>
<li>栈 可用来解决 对称 匹配 出战入栈 （「[{}]」）</li>
<li>队列 可用于各种结构按自定义顺序入队列 比如二叉树 根据遍历方式不同 入队列</li>
<li>可引入map（无重复），数组（下标对应）用空间换时间的方式做一些优化</li>
<li>回溯法，动态规划法，双指针+排序</li>
</ol>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ol>
<li>算法：二叉树给个头节点，求树高</li>
<li>数组只有一个元素出现一次，怎么找出来，时间和空间复杂度是多少</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0501(%E7%AE%97%E6%B3%95)/" data-id="cld1bs9sw0016fynhepl38m3t" data-title="每日一问0501(算法)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0506(动态代理)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)/">每日一问0506(动态代理)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="动态代理Fmy"><a href="#动态代理Fmy" class="headerlink" title="动态代理Fmy"></a>动态代理Fmy</h1><h2 id="Java-语言常用动态代理方式"><a href="#Java-语言常用动态代理方式" class="headerlink" title="Java 语言常用动态代理方式"></a>Java 语言常用动态代理方式</h2><h3 id="JDK内置动态代理"><a href="#JDK内置动态代理" class="headerlink" title="JDK内置动态代理"></a>JDK内置动态代理</h3><p>Java SDK代理面向的是一组接口</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>Java SDK动态代理的局限在于，它只能为接口创建代理，返回的代理对象也只能转换到某个接口类型，如果一个类没有接口，或者希望代理非接口中定义的方法，那就没有办法了。有一个第三方的类库cglib</p>
<p>cglib的实现机制与Java SDK不同，它是通过继承实现的，它也是动态创建了一个类，但这个类的父类是被代理的类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0506(%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)/" data-id="cld1bs9sx0017fynhgtnn55av" data-title="每日一问0506(动态代理)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0509(java性能问题定位)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0509(java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0509(java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D)/">每日一问0509(java性能问题定位)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="java-性能问题定位"><a href="#java-性能问题定位" class="headerlink" title="java 性能问题定位"></a>java 性能问题定位</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>top</li>
<li>vmstat</li>
<li>pidstat</li>
<li>jstack</li>
<li>jstat</li>
<li>jmap</li>
<li>mat内存工具</li>
</ul>
<h2 id="模拟环境准备"><a href="#模拟环境准备" class="headerlink" title="模拟环境准备"></a>模拟环境准备</h2><h3 id="CPU-高"><a href="#CPU-高" class="headerlink" title="CPU 高"></a>CPU 高</h3><p>方式: </p>
<ol>
<li>top 或者其他方式获取进程ID</li>
<li>进程ID获取 下边的线程列表信息 （top -Hp 32805） </li>
<li>线程ID转换成16进制</li>
<li>jstack 查询日志。定位相关行号</li>
</ol>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>jmap 分析</p>
<p>生成内存快照</p>
<p>jprofiler 分析</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0509(java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D)/" data-id="cld1bs9sx0018fynh0er9dxxb" data-title="每日一问0509(java性能问题定位)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0511(Sevlet)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0511(Sevlet)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0511(Sevlet)/">每日一问0511(Sevlet)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>多线程 单实例<br>doGet doPost<br>Config ,Request ,Response<br>实例初始化 可以配置 tomcat 启动时<load-on-startup>，也可以在第一次调用时。</p>
<h3 id="Servlet-3-0新特性"><a href="#Servlet-3-0新特性" class="headerlink" title="Servlet 3.0新特性"></a>Servlet 3.0新特性</h3><ul>
<li>引入注解配置 :@WebServlet(name &#x3D; “myFirstServlet”,urlPatterns &#x3D; {“&#x2F;aaaa”})</li>
<li>支持web模块化开发</li>
<li>程序异步处理</li>
<li>改进文件上传API</li>
<li>非阻塞式IO读取流</li>
<li>Websocket实时通信</li>
</ul>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1013528">Servlet3.0新特性</a></p>
<table>
<thead>
<tr>
<th align="right">title</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1、工时统计分析</td>
<td>项目管理者和部门管理者可基于任务的预估工时及填报工时，了解项目及人员实施表现情况</td>
</tr>
<tr>
<td align="right">2、项目关系调整</td>
<td>部门管理员可调整当前项目关系，修改子项目所属父项</td>
</tr>
<tr>
<td align="right">3、审批工时逻辑优化</td>
<td>工时审批增加驳回状态展示</td>
</tr>
<tr>
<td align="right">4、工时提交流程优化</td>
<td>工作台增加一键提交工时操作，缩短体检操作实施路径</td>
</tr>
<tr>
<td align="right">5、工时同步日志</td>
<td>审批人可查看审批工时在同步至工时系统时的日志</td>
</tr>
<tr>
<td align="right">6、其他优化</td>
<td>优化bug，提升性能</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0511(Sevlet)/" data-id="cld1bs9sy0019fynhhb01dlus" data-title="每日一问0511(Sevlet)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0512(Tomcat)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0512(Tomcat)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0512(Tomcat)/">每日一问0512(Tomcat)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="基于http-协议的服务器"><a href="#基于http-协议的服务器" class="headerlink" title="基于http 协议的服务器"></a>基于http 协议的服务器</h2><ul>
<li>Apche</li>
<li>IIS </li>
<li>Nginx</li>
<li>Tomcat </li>
<li>JBoss</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>connect container<br>一个containner 可以对应多个connector<br>多线程模型，</p>
<p>NIO</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="加载顺序："><a href="#加载顺序：" class="headerlink" title="加载顺序："></a>加载顺序：</h3><p>1.$java_home&#x2F;lib 目录下的java核心api </p>
<p>2.$java_home&#x2F;lib&#x2F;ext 目录下的java扩展jar包</p>
<p>3.java -classpath&#x2F;-Djava.class.path所指的目录下的类与jar包</p>
<p>4.$CATALINA_HOME&#x2F;common目录下按照文件夹的顺序从上往下依次加载</p>
<p>5.$CATALINA_HOME&#x2F;server目录下按照文件夹的顺序从上往下依次加载</p>
<p>6.$CATALINA_BASE&#x2F;shared目录下按照文件夹的顺序从上往下依次加载</p>
<p>7.我们的项目路径&#x2F;WEB-INF&#x2F;classes下的class文件</p>
<p>8.我们的项目路径&#x2F;WEB-INF&#x2F;lib下的jar文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0512(Tomcat)/" data-id="cld1bs9sz001afynhd6an15mr" data-title="每日一问0512(Tomcat)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0515(nginx)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0515(nginx)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.356Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0515(nginx)/">每日一问0515(nginx)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ul>
<li>轮询（默认算法）：每个请求按时间顺序分配到不同后端服务器，如果某个后端服务器宕机，能自动剔除掉。</li>
<li>加权轮询（平滑加权轮询算法）：nginx反向代理接收到客户端收到的请求后，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器配置进行配置的。比如说有些服务器的硬件配置高，比重就会比较大一点。</li>
<li>ip_hash：每个请求按照发起客户端ip的hash结果进行匹配，这样的算法每一个固定的ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</li>
<li>fair：智能调整调度算法，动态的根据后端服务器的请求处理器的请求处理响应的时间来进行均衡分配，响应时间短，处理效率高的服务器分配到请求的概率高，响应时间长，处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种算法，需要安装upstream_fair模块。</li>
<li>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0515(nginx)/" data-id="cld1bs9sz001bfynh5njx1zqz" data-title="每日一问0515(nginx)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/19/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2022/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0922(%E6%9E%B6%E6%9E%84)/">每日一问0922(架构)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2022/%E8%BF%B0%E8%81%8C%E6%A8%A1%E6%9D%BF/">述职模板</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E7%A7%AF%E7%B4%AF/">英文单词积累</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%9C%B0%E5%9D%80/">好玩的地址</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/">摄影后期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>