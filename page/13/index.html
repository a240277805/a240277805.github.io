<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020/每日一问0925(k8s)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(k8s)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(k8s)/">每日一问0925(k8s)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="如何搭建-k8s"><a href="#如何搭建-k8s" class="headerlink" title="如何搭建 k8s"></a>如何搭建 k8s</h2><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>pv PersistentVolume（PV）</p>
<p>PV是对底层网络共享存储的抽象，将共享存储定义为一种“资源”，比如Node也是一种容器应用可以“消费”的资源。PV由管理员创建和配置，它与共享存储的具体实现直接相关，例如GlusterFS、iSCSI、RBD或GCE或AWS公有云提供的共享存储，通过插件式的机制完成与共享存储的对接，以供应用访问和使用。</p>
<p>PVC PersistentVolumeClaim（PVC）</p>
<p>PVC则是用户对存储资源的一个“申请”。就像Pod“消费”Node的资源一样，PVC能够“消费”PV资源。PVC可以申请特定的存储空间和访问模式。</p>
<p>SVC</p>
<p>pod</p>
<p>node</p>
<h2 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h2><p>引入容器存储接口Container Storage Interface（CSI）机制，用于在Kubernetes和外部存储系统之间建立一套标准的存储管理接口，通过该接口为容器提供存储服务。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>我们通过设置kube-apiserver服务的启动参数–enable-swagger-ui&#x3D;true来启用Swagger UI页面，其访问地址为http:&#x2F;&#x2F;<master-ip>:<master-port>&#x2F;swagger-ui&#x2F;</p>
<h2 id="Master的组件"><a href="#Master的组件" class="headerlink" title="Master的组件"></a>Master的组件</h2><ul>
<li>（1）kube-apiserver</li>
<li>（2）etcd</li>
<li>（3）kube-scheduler</li>
<li>（4）kube-controller-manager</li>
<li>（5）cloud-controller-manager</li>
</ul>
<p>Pod有两种类型：普通的Pod和静态Pod（Static Pod）</p>
<p>Service在Kubernetes中是一个抽象的概念，定义了一组逻辑上的Pod和一个访问它们的策略（通常称为微服务）。</p>
<p>，在Kubernetes中，Volume是Pod中能够被多个容器访问的共享目录。</p>
<h4 id="3．卷（Volume）"><a href="#3．卷（Volume）" class="headerlink" title="3．卷（Volume）"></a>3．卷（Volume）</h4><ul>
<li>local 本地存储 ，使用Local Storage可以由Kubernetes自动对Pod进行调度，而使用HostPath只能人工手动调度Pod，因为Kubernetes已经知道了每个节点上kube-reserved和system-reserved设置的本地存储限制。</li>
<li>NFS（Network File System，网络文件系统） 使用NFS数据卷适用于多读多写的持久化存储，适用于大数据分析、媒体处理、内容管理等场景。</li>
<li>projected Volume projected Volume将多个Volume源映射到同一个目录，可以支持以下类型的卷源：secret、downwardAPI、configMap、serviceAccounttoken。 所有源都需要与Pod在同一名称空间中。</li>
<li>secret volume用于将敏感信息（如密码）传递给Pod。 ，因此它们永远不会写入非易失性存储。</li>
</ul>
<h4 id="复制控制器（Replication-Controller-RC）"><a href="#复制控制器（Replication-Controller-RC）" class="headerlink" title="复制控制器（Replication Controller, RC）"></a>复制控制器（Replication Controller, RC）</h4><p>● 重新规划，比如重新设置Pod数量。</p>
<p>● 缩放。</p>
<p>● 滚动更新。</p>
<p>● RC支持滚动更新，允许我们在更新服务时逐个替换Pod。</p>
<ul>
<li>除了在程序更新过程中同时可以运行多个版本的程序外，也可以在更新完成之后的一段时间内或者持续的同时运行多个版本（新旧），需要通过标签选择器来完成。</li>
</ul>
<h4 id="Replica-Set"><a href="#Replica-Set" class="headerlink" title="Replica Set"></a>Replica Set</h4><p>Replica Set 是下一代复制控制器。Replica Set和Replication Controller之间的&#x3D;&#x3D;唯一区别&#x3D;&#x3D;是选择器的支持——Replica Set支持基于集合的Label selector（Set-based selector），而RC只支持基于等式的Label selector（equality-basedselector），所以Replica Set的功能更强大。</p>
<h4 id="7．部署控制器（Deployment）"><a href="#7．部署控制器（Deployment）" class="headerlink" title="7．部署控制器（Deployment）"></a>7．部署控制器（Deployment）</h4><h4 id="8．StatefulSet"><a href="#8．StatefulSet" class="headerlink" title="8．StatefulSet"></a>8．StatefulSet</h4><p>StatefulSet用于管理有状态应用程序，比如MySQL集群、MongoDB集群、ZooKeeper集群等。</p>
<h4 id="9．后台支撑服务集（DaemonSet）"><a href="#9．后台支撑服务集（DaemonSet）" class="headerlink" title="9．后台支撑服务集（DaemonSet）"></a>9．后台支撑服务集（DaemonSet）</h4><p>DaemonSet保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：</p>
<p>● 日志收集守护程序，比如fluentd、logstash等。</p>
<p>● 系统监控，比如Prometheus Node Exporter、collectd、New Relicagent、Ganglia gmond等。</p>
<p>● 集群存储后台进程，比如glusterd、ceph等。</p>
<p>● 系统程序，比如kube-proxy、kube-dns、glusterd、ceph等。</p>
<h4 id="10-JOB"><a href="#10-JOB" class="headerlink" title="10. JOB"></a>10. JOB</h4><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p> journalctl -u docker</p>
<p>journalctl -u kuberlet -f</p>
<p>&#x2F;&#x2F;查看指定文件描述的所有资源</p>
<p>kuberctl describe -f **.yaml</p>
<p>kubectl-debug是一个简单的开源kubectl插件，可以帮助我们便捷地进行Kubernetes上的Pod排障诊断，背后做的事情很简单：在运行中的Pod上额外起一个新容器，并将新容器加入目标容器的pid、network、user以及ipc namespace中。这时我们就可以在新容器中直接用netstat、tcpdump这些熟悉的工具来诊断和解决问题了，而旧容器可以保持最小化，不需要预装任何额外的排障工具。</p>
<p>（1）Pod一直处于Pending状态Pending一般情况下表示这个Pod没有被调度到一个节点上，通常使用“kubectldescribe”命令来查看Pod事件以得到具体原因。通常情况下，这是因为资源不足引起的。如果是资源不足，那么解决方案有：● 添加工作节点。● 移除部分Pod以释放资源。● 降低当前Pod的资源限制。</p>
<p>（2）如果一个Pod卡在Waiting状态，</p>
<p>就表示这个Pod已经调试到节点上，但是没有运行起来。解决方案有：</p>
<p>● 检查网络问题。若是网络问题，则保障网络通畅，可以考虑使用代理或国际网络（部分域名在国内网络无法访问，比如“k8s.gcr.io”）。</p>
<p>● 如果是拉取超时，可以考虑使用镜像加速器（比如使用阿里云或腾讯云提供的镜像加速地址），也可以考虑适当调整超时时间。</p>
<p>● 尝试使用docker pull <image>来验证镜像是否可以正常拉取。（</p>
<p>（3）Pod一直处于CrashLoopBackOff状态，经检查判为健康检查启动超时而退出CrashLoopBackOff状态说明容器曾经启动但又异常退出了，通常此Pod的重启次数是大于0的。解决方案有：● 重新设置合适的健康检查阈值。● 优化容器性能，提高启动速度。● 关闭健康检查。</p>
<p>（4）出现大量状态为“Evicted”的PodEvicted即驱赶的意思，当节点NotReady（节点宕机或失联）或资源不足时就会将Pod驱逐到其他节点。解决方案有：● 排查节点异常。● 排查资源问题，扩充资源或释放其他资源。● 可使用以下命令批量删除已有的“Evicted”状态的Pod：</p>
<p>Azure中国镜像源地址：<a target="_blank" rel="noopener" href="http://mirror.azure.cn/%E3%80%82">http://mirror.azure.cn/。</a></p>
<p>中科大镜像源地址：<a target="_blank" rel="noopener" href="http://mirrors.ustc.edu.cn/%E3%80%82">http://mirrors.ustc.edu.cn/。</a></p>
<p>网络组件flannel安装完成后，通过命令查看时一直在初始化状态，并且通过日志输出的内容如下所示：</p>
<p><img src="/../../ImgSource/image-20211112162530870.png" alt="image-20211112162530870"></p>
<p><img src="/../../ImgSource/image-20211112162721959.png" alt="image-20211112162721959"></p>
<p>通常推荐使用“kubectl apply”命令替代“kubectl create”，因为“kubectl apply”既能创建Kubernetes资源，也能对资源进行更新，属于声明式对象配置管理，比命令式对象配置管理更易于理解和使用。</p>
<h3 id="使用“kubectl-scale”命令来伸缩应用"><a href="#使用“kubectl-scale”命令来伸缩应用" class="headerlink" title="使用“kubectl scale”命令来伸缩应用"></a>使用“kubectl scale”命令来伸缩应用</h3><h4 id="9-2-2-使用“kubectl-autoscale”命令来自动伸缩应用"><a href="#9-2-2-使用“kubectl-autoscale”命令来自动伸缩应用" class="headerlink" title="9.2.2 使用“kubectl autoscale”命令来自动伸缩应用"></a>9.2.2 使用“kubectl autoscale”命令来自动伸缩应用</h4><h4 id="9-2-4-使用“kubectl-set”命令更新应用"><a href="#9-2-4-使用“kubectl-set”命令更新应用" class="headerlink" title="9.2.4 使用“kubectl set”命令更新应用"></a>9.2.4 使用“kubectl set”命令更新应用</h4><h4 id="9-2-5-使用“kubectl-rollout”命令回滚应用"><a href="#9-2-5-使用“kubectl-rollout”命令回滚应用" class="headerlink" title="9.2.5 使用“kubectl rollout”命令回滚应用"></a>9.2.5 使用“kubectl rollout”命令回滚应用</h4><p><img src="/../../ImgSource/image-20211112163203163.png" alt="image-20211112163203163"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yan234280533/article/details/72567261?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">Kubernetes中pod创建流程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(k8s)/" data-id="cld1buvso000sbjopfsz328t8" data-title="每日一问0925(k8s)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0925(maven)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(maven)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(maven)/">每日一问0925(maven)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0925(maven)/" data-id="cld1buvsp000tbjopas9p5k6u" data-title="每日一问0925(maven)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1009(mongodb)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1009(mongodb)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1009(mongodb)/">每日一问1009(mongodb)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>show collections 查看集合</li>
<li>db.dbName.find({“a”:”b”}) 查找</li>
<li>创建&#x2F;切换仓库: use DATABASE_NAME</li>
<li>查看当前仓库: db</li>
<li>查看所有仓库: show dbs</li>
<li>普通库增加用户: (1)use  dbName (2) db.createUser({“user”:”ctfo”,”pwd”:”pipelineCTFO!2020”,roles:[“dbOwner”]})</li>
<li>查看用户: show users   ;     db.dbName.users.find().pretty()</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1009(mongodb)/" data-id="cld1buvsp000ubjopfmmsda42" data-title="每日一问1009(mongodb)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1015(docker)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1015(docker)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1015(docker)/">每日一问1015(docker)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，既增加了构建部署的时间，也很容易出错。因此，在很多情况下，可以合并指令并运行</p>
<h2 id="镜像存储方式"><a href="#镜像存储方式" class="headerlink" title="镜像存储方式"></a>镜像存储方式</h2><p><img src="https://pic2.zhimg.com/80/v2-f3109ae2689c869b28f5033e2dff9669_720w.jpg" alt="avator"></p>
<ol>
<li>镜像中心域名 </li>
<li>命名空间</li>
<li>仓库名称</li>
<li>标签</li>
</ol>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><h3 id="docker-compose-yml-属性"><a href="#docker-compose-yml-属性" class="headerlink" title="docker-compose.yml 属性"></a>docker-compose.yml 属性</h3><ul>
<li><strong>version</strong>：指定 docker-compose.yml 文件的写法格式</li>
<li><strong>services</strong>：多个容器集合</li>
<li><strong>build</strong>：配置构建时，Compose 会利用它自动构建镜像，该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>command</strong>：覆盖容器启动后默认执行的命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>dns</strong>：配置 dns 服务器，可以是一个值或列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>dns_search</strong>：配置 DNS 搜索域，可以是一个值或列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>environment</strong>：环境变量配置，可以用数组或字典两种方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &#x27;ture&#x27;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV=development</span><br><span class="line">    - SHOW=ture</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>env_file</strong>：从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - ./common.env</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>expose</strong>：暴露端口，只将端口暴露给连接的服务，而不暴露给主机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>image</strong>：指定服务所使用的镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: java</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>network_mode</strong>：设置网络模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ports</strong>：对外暴露的端口定义，和 expose 对应</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>links</strong>：将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:    # 指定服务名称:别名 </span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>volumes</strong>：卷挂载路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /lib</span><br><span class="line">  - /var</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>logs</strong>：日志输出信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail=200</span><br></pre></td></tr></table></figure>

<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul>
<li><strong>ps</strong>：列出所有运行容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>logs</strong>：查看服务日志输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>port</strong>：打印绑定的公共端口，下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>kill</strong>：通过发送 SIGKILL 信号来停止指定服务的容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>pull</strong>：下载服务镜像</li>
<li><strong>scale</strong>：设置指定服务运气容器的个数，以 service&#x3D;num 形式指定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale user=3 movie=3</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>run</strong>：在一个服务上执行一个命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure>

<h2 id="dockerFile"><a href="#dockerFile" class="headerlink" title="dockerFile"></a>dockerFile</h2><ul>
<li>ENTRYPOINT是配置容器启动后执行的指令，并且不可被docker run提供的参数覆盖。每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</li>
<li>ADD指令与COPY指令非常类似，但它包含了更多的功能。除了将文件从主机复制到容器镜像外，ADD指令还可以使用URL规范从远程位置复制文件。</li>
<li>如果Dockerfile中指定了多个CMD指令，就只会执行最后一个指令。</li>
<li>转义字符, Dockerfile指令需要跨多行进行编写，以提高脚本命令的可读性。这可以通过转义字符完成，默认Dockerfile转义字符是反斜杠“\”</li>
</ul>
<h3 id="dockerfile-优化"><a href="#dockerfile-优化" class="headerlink" title="dockerfile 优化"></a>dockerfile 优化</h3><p>（1）尽量选择官方镜像。</p>
<p>（2）选择合适的基础镜像。<br>需要特别说明的是，标签中包含“alpine”的镜像是基于体积更小的Alpine Linux发行版制作的，一般情况下可以优先考虑。标签中包含“sdk”的镜像是包含完整的框架SDK的，往往体积比较大，如果仅用于运行托管，尽量选择带“runtime”的镜像<br>（3）优化指令顺序。Docker会缓存Dockerfile中尚未更改的所有步骤，但是不管更改什么指令，都将重做其后的所有步骤。也就是说，如果指令3有变动，那么4、5、6就会重做。因此，需要将最不可能产生更改的指令放在前面，按照这个顺序来编写Dockerfile指令。这样，在构建过程中就可以节省很多时间。比如，可以把WORKDIR、ENV等放在前面，把COPY、ADD放在后面。总的来说，就是把不需要经常更改的指令放到前面，将最频繁更改的指令放到最后面。</p>
<p>（4）只复制需要的文件，切忌复制所有内容。</p>
<p>（5）最小化可缓存的执行层。	<br>每一个RUN指令都会被看作是可缓存的执行单元。太多的RUN指令会增加镜像的层数，增大镜像体积，而将所有的命令都放到同一个RUN指令中又会破坏缓存，从而延缓构建周期。当使用包管理器安装软件时，一般都会先更新软件索引信息再安装软件。推荐将更新索引和安装软件放在同一个RUN指令中，这样可以形成一个可缓存的执行单元，否则可能会安装旧的软件包。</p>
<p>（6）使用多阶段构建。</p>
<p>多阶段构建可以由多个FROM指令组成，每一个FROM语句表示一个新的构建阶段，阶段名称可以用AS参数指定。例如，在下面的示例中，指定第一阶段的名称为builder，可以被第二阶段直接引用。两个阶段环境一致，并且第一阶段包含所有构建依赖项。第二阶段是构建最终镜像的最后阶段，包括应用运行时的所有必要条件。</p>
<p><img src="/../../ImgSource/image-20211112111906126.png" alt="image-20211112111906126"></p>
<p>（7）根据情况合并指令。</p>
<p>（8）删除多余文件和清理没用的中间结果。	</p>
<p>（9）使用.dockerignore。</p>
<h2 id="快捷键方式"><a href="#快捷键方式" class="headerlink" title="快捷键方式"></a>快捷键方式</h2><ul>
<li>拉取镜像: docker pull {imageName}</li>
<li>查看镜像: docker images 查看镜像</li>
<li>在容器中执行命令: docker exec -it {containerName} &#x2F;bin&#x2F;bash   ? &#x2F;bin&#x2F;sh</li>
<li>查看基本信息: docker inspect {containerName}</li>
<li>查看内存: docker stats </li>
<li>查看日志： docker logs</li>
<li>查看镜像的历史版本可以执行以下命令：docker history &lt;image_name&gt; </li>
<li>将容器的状态保存为镜像： docker commit $sample_job job1 </li>
<li>在registry中的镜像可以使用以下命令查找到： docker search &lt;image-name&gt; </li>
<li>docker 查看挂载目录 docker inspect container_name | grep Mounts -A 20</li>
<li>查看docker 镜像仓库地址:   cat &#x2F;etc&#x2F;docker&#x2F;daemon.json</li>
<li>docker run 长久运行: docker run centos ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> &#x2F; sleep 50s 就是运行结束后重新运行</li>
<li>修改镜像名称 docker tag source target</li>
</ul>
<p><img src="/../../ImgSource/image-20211111144335309.png" alt="image-20211111144335309"></p>
<p><img src="/../../ImgSource/image-20211111144405420.png" alt="image-20211111144405420"></p>
<p><img src="/../../ImgSource/image-20211111144434027.png" alt="image-20211111144434027"></p>
<p><img src="/../../ImgSource/image-20211111144524928.png" alt="image-20211111144524928"></p>
<p><img src="/../../ImgSource/image-20211111144553999.png" alt="image-20211111144553999"></p>
<p><img src="/../../ImgSource/image-20211111144720541.png" alt="image-20211111144720541"></p>
<p>定时清理不用镜像脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_42_centos opt]# cat clean.sh </span><br><span class="line">sh /opt/docker/lock.sh -t clean -a lock</span><br><span class="line">docker image prune -a -f</span><br><span class="line">docker container prune -f</span><br><span class="line">sh /opt/docker/lock.sh -t clean -a unlock </span><br><span class="line">dt=$(date)</span><br><span class="line">echo time is $dt</span><br></pre></td></tr></table></figure>

<p><img src="/../../ImgSource/image-20211111150440975.png" alt="image-20211111150440975"></p>
<p><img src="/../../ImgSource/image-20211112105933891.png" alt="image-20211112105933891"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="docker-compose-启动容器"><a href="#docker-compose-启动容器" class="headerlink" title="docker-compose 启动容器"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liaokui/p/11380590.html">docker-compose 启动容器</a></h1><p><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/13b32c4071cc8f0613bd197kc1632f5021fc16a5320f3dc">微信读书-</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1015(docker)/" data-id="cld1buvsq000vbjop07wuftvq" data-title="每日一问1015(docker)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1024(docsify)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1024(docsify)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1024(docsify)/">每日一问1024(docsify)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h1><p>一个神奇的文档网站生成工具</p>
<p>docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会将 .md 转成 .html 文件，所有转换工作都是在运行时进行。这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在GitHub Pages。</p>
<p>参考地址：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4883e95aa903">有了docsify神器，从此爱上看文档</a></p>
<p><a target="_blank" rel="noopener" href="https://docsify.js.org/#/zh-cn/">快速开始</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1024(docsify)/" data-id="cld1buvsr000wbjopcte6h4cv" data-title="每日一问1024(docsify)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1027(正则表达式)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1027(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1027(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)/">每日一问1027(正则表达式)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p> 正则表达式是一串字符，它描述了一个文本模式，利用它可以方便地处理文本，包括文本的查找、替换、验证、切分等</p>
<p> 正则表达式中的字符有两类：一类是普通字符，就是匹配字符本身；另一类是元字符，这些字符有特殊含义，这些元字符及其特殊含义构成了正则表达式的语法。</p>
<p> 最后针对转义、匹配模式和各种语法进行总结。<br> 1．单个字符大部分的单个字符就是用字符本身表示的，比如字符’0’、’3’、’a’、’马’等，但有一些单个字符使用多个字符表示，这些字符都以斜杠’&#39;开头，比如：</p>
<p> 1）特殊字符，比如tab字符’\t’、换行符’\n’、回车符’\r’等。</p>
<p> 2）八进制表示的字符，以\0开头，后跟1～3位数字，比如\0141，对应的是ASCII编码为97的字符，即字符’a’。</p>
<p> 3）十六进制表示的字符，以\x开头，后跟两位字符，比如\x6A，对应的是ASCII编码为106的字符，即字符’j’。</p>
<p> 4）Unicode编号表示的字符，以\u开头，后跟4位字符，比如\u9A6C，表示的是中文字符’马’，这只能表示编号在0xFFFF以下的字符，如果超出0ⅩFFFF，使用\x{…}形式，比如\x{1f48e}。</p>
<p> 5）斜杠\本身，斜杠\是一个元字符，如果要匹配它自身，使用两个斜杠表示，即’\‘。</p>
<p> 6）元字符本身，除了’&#39;，正则表达式中还有很多元字符，比如．、*、? 、+等，要匹配这些元字符自身，需要在前面加转义字符’&#39;，比如’.‘。</p>
<p> 2．字符组字符组有多种，包括任意字符、多个指定字符之一、字符区间、排除型字符组、预定义的字符组等，下面具体介绍。点号字符’.’是一个元字符，默认模式下，它匹配除了换行符以外的任意字符，</p>
<p> 比如正则表达式：a.f ,既匹配字符串”abf”，也匹配”acf” 一般称为单行匹配模式或者点号匹配模式  一种是在正则表达式中，以(? s)开头，s表示single line，即单行匹配模式。比如：(? s)a.f</p>
<p>在单个字符和任意字符之间，有一个字符组的概念，匹配组中的任意一个字符，用中括号[]表示，比如： [abcd] 匹配 a,b,c,d 中的任意一个字符</p>
<p>为方便表示连续的多个字符，字符组中可以使用连字符’-‘ 比如 [0-9a-zA-Z]</p>
<p>在字符组中，’-‘是一个元字符，如果要匹配它自身，可以使用转义，即’-‘，或者把它放在字符组的最前面 [-0-9]</p>
<p>字符组支持排除的概念，在[后紧跟一个字符^[^abcd] 表示匹配除了a, b, c, d以外的任意一个字符</p>
<p>^只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身<br>[a^b] 匹配 a,^ 或b</p>
<h3 id="有一些特殊的以-开头的字符，表示一些预定义的字符组，比如："><a href="#有一些特殊的以-开头的字符，表示一些预定义的字符组，比如：" class="headerlink" title="有一些特殊的以\开头的字符，表示一些预定义的字符组，比如："></a>有一些特殊的以\开头的字符，表示一些预定义的字符组，比如：</h3><p>❑ \d:d表示digit，匹配一个数字字符，等同于[0-9]。</p>
<p>❑ \w:w表示word，匹配一个单词字符，等同于[a-zA-Z_0-9]。</p>
<p>❑ \s:s表示space，匹配一个空白字符，等同于[ \t\n\x0B\f\r]。</p>
<p>它们都有对应的排除型字符组，用大写表示，即：</p>
<p>❑ \D：匹配一个非数字字符，即[^\d]。</p>
<p>❑ \W：匹配一个非单词字符，即[^\w]。</p>
<p>❑ \S：匹配一个非空白字符，即[^\s]。</p>
<p>还有一类字符组，称为POSIⅩ字符组，它们是POSIⅩ标准定义的一些字符组</p>
<h2 id="3。-量词"><a href="#3。-量词" class="headerlink" title="3。 量词"></a>3。 量词</h2><p>量词指的是指定出现次数的元字符，有三个常见的元字符：+、*、? ：</p>
<p>1）+：表示前面字符的一次或多次出现，比如正则表达式ab+c，既能匹配abc，也能匹配abbc，或abbbc。</p>
<p>2）<em>：表示前面字符的零次或多次出现，比如正则表达式ab</em>c，既能匹配abc，也能匹配ac，或abbbc。</p>
<p>3）? ：表示前面字符可能出现，也可能不出现，比如正则表达式ab? c，既能匹配abc，也能匹配ac，但不能匹配abbc。</p>
<p>更为通用的表示出现次数的语法是{m, n}，出现次数从m到n，包括m和n，如果n没有限制，可以省略，如果m和n一样，可以写为{m}，比如：</p>
<p>❑ ab{1,10}c:b可以出现1次到10次。</p>
<p>❑ ab{3}c:b必须出现三次，即只能匹配abbbc。</p>
<p>❑ ab{1, }c：与ab+c一样。</p>
<p>❑ ab{0, }c：与ab*c一样。</p>
<p>❑ ab{0,1}c：与ab? c一样。</p>
<p>?、*、+、{是元字符，如果要匹配这些字符本身，需要使用’&#39;转义，比如：a*b</p>
<p>关于量词，它们的默认匹配是贪婪的，什么意思呢？看个例子，正则表达式是：</p>
<p><a>.*</a><br>处理<br><a>first</a><a>second</a><br>得到 <a>first</a><a>second</a> </p>
<p>目的是得到   <a>first</a> 和 <a>second</a></p>
<p>这是因为．*可以匹配第一个<a>和最后一个</a>之间的所有字符，只要能匹配，.<em>就尽量往后匹配，它是贪婪的。如果希望在碰到第一个匹配时就停止呢？应该使用懒惰量词，在量词的后面加一个符号’? ‘<br>针对上例，将表达式改为：<a>.</em>?</a></p>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4. 分组"></a>4. 分组</h2><p>表达式可以用括号()括起来，表示一个分组，比如a(bc)d, bc就是一个分组。分组可以嵌套，比如a(de(fg))。分组默认都有一个编号，按照括号的出现顺序，从1开始，从左到右依次递增，比如表达式：</p>
<p>a(bc)((de)(fg))</p>
<p>字符串abcdefg匹配这个表达式，第1个分组为bc，第2个为defg，第3个为de，第4个为fg。分组0是一个特殊分组，内容是整个匹配的字符串，这里是abcdefg。分组匹配的子字符串可以在后续访问，好像被捕获了一样，所以默认分组称为捕获分组。关于如何在Java中访问和使用捕获分组，</p>
<p>可以对分组使用量词，表示分组的出现次数，比如a(bc)+d，表示bc出现一次或多次。</p>
<p>括号()和元字符’|’一起，可以表示匹配其中的一个子表达式 (http|ftp|file)</p>
<p>| 用于[] 中不再有特殊含义 如[a|b] 匹配 a或|或b</p>
<p>在正则表达式中，可以使用斜杠\加分组编号引用之前匹配的分组，这称为回溯引用，比如：&lt;(\w+)&gt;(.*)&lt;&#x2F;\1&gt;  \1匹配之前的第一个分组(\w+)，这个表达式可以匹配类似如下字符串：</p>
<title>bc</title>

<h2 id="5-特殊边界匹配"><a href="#5-特殊边界匹配" class="headerlink" title="5. 特殊边界匹配"></a>5. 特殊边界匹配</h2><p>在正则表达式中，除了可以指定字符需满足什么条件，还可以指定字符的边界需满足什么条件，或者说匹配特定的边界，常用的表示特殊边界的元字符有^、$、\A、\Z、\z和\b。</p>
<p>默认情况下，^匹配整个字符串的开始，^abc表示整个字符串必须以abc开始。</p>
<p>需要注意的是^的含义，在字符组中它表示排除，但在字符组外，它匹配开始，比如表达式^[^abc]，表示以一个不是a、b、c的字符开始。</p>
<p>默认情况下，$匹配整个字符串的结束，不过，如果整个字符串以换行符结束，$匹配的是换行符之前的边界，比如表达式abc$，表示整个表达式以abc结束，或者以abc\r\n或abc\n结束。</p>
<p>以上^和$的含义是默认模式下的，可以指定另外一种匹配模式：多行匹配模式，在此模式下，会以行为单位进行匹配，^匹配的是行开始，$匹配的是行结束，比如表达式是^abc$，字符串是”abc\nabc\r\n”，就会有两个匹配。</p>
<p>可以有两种方式指定匹配模式。一种是在正则表达式中，以(? m)开头，m表示multi-line，即多行匹配模式，上面的正则表达式可以写为：(? m)^abc$</p>
<p>需要说明的是，多行模式和之前介绍的单行模式容易混淆，其实，它们之间没有关系。单行模式影响的是字符’.’的匹配规则，使得’.’可以匹配换行符；多行模式影响的是^和$的匹配规则，使得它们可以匹配行的开始和结束，两个模式可以一起使用。 </p>
<p>\A与^类似，但不管什么模式，它匹配的总是整个字符串的开始边界。</p>
<p>\Z和\z与$类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。\Z与\z的区别是：如果字符串以换行符结束，\Z与$一样，匹配的是换行符之前的边界，而\z匹配的总是结束边界。在进行输入验证的时候，为了确保输入最后没有多余的换行符，可以使用\z进行匹配。</p>
<p>\b匹配的是单词边界，比如\bcat\b，匹配的是完整的单词cat，它不能匹配category。\b匹配的不是一个具体的字符，而是一种边界，这种边界满足一个要求，即一边是单词字符，另一边不是单词字符。在Java中，\b识别的单词字符除了\w，还包括中文字符。</p>
<h2 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h2><ul>
<li><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/b51320f05e159eb51b29226ka8b3222028ea8baa56554b9">java的编程逻辑</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1027(%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)/" data-id="cld1buvsr000xbjop8y9rdipm" data-title="每日一问1027(正则表达式)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1029(logstash)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1029(logstash)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1029(logstash)/">每日一问1029(logstash)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1029(logstash)/" data-id="cld1buvss000ybjope4368oti" data-title="每日一问1029(logstash)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1102(kubernetes)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(kubernetes)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(kubernetes)/">每日一问1102(kubernetes)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="kubernetes-基本概念和术语"><a href="#kubernetes-基本概念和术语" class="headerlink" title="kubernetes 基本概念和术语"></a>kubernetes 基本概念和术语</h1><h2 id="kubernates-架构"><a href="#kubernates-架构" class="headerlink" title="kubernates 架构"></a>kubernates 架构</h2><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><ul>
<li>API服务器</li>
<li>etcd 元数据存储 ： 为了保证冗余性，通常由三个或五个etcd实例组成一个集群。如果你丢失了etcd存储中的数据，那么你会丢掉整个集群。</li>
<li>调度器  它实现了一种复杂的调度算法，该算法考虑到多个维度的信息，例如每个节点上的资源可用性、用户指定的各种约束、可用节点的类型、资源限制和配额以及其他因素，例如亲和性、反亲和性、容忍和污点等。</li>
<li>控制器管理器 ： 这些控制器监控着集群事件和对集群的更改并做出响应。</li>
<li>云控制器管理器</li>
</ul>
<h2 id="kubernetes-基本概念和术语-1"><a href="#kubernetes-基本概念和术语-1" class="headerlink" title="kubernetes 基本概念和术语"></a>kubernetes 基本概念和术语</h2><p>Kubernetes中的大部分概念如Node、Pod、ReplicationController、Service等都可以被看作一种资源对象<br>几乎所有资源对象都可以通过Kubernetes提供的kubectl工具（或者API编程调用）执行增、删、改、查等操作并将其保存在etcd中持久化存储。</p>
<p>Kubernetes其实是一个高度自动化的资源控制系统，它通过跟踪对比etcd库里保存的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错的高级功能。</p>
<h2 id="Kubernetes-资源对象"><a href="#Kubernetes-资源对象" class="headerlink" title="Kubernetes 资源对象"></a>Kubernetes 资源对象</h2><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>在每个Kubernetes集群里都需要有一个Master来负责整个集群的管理和控制，基本上Kubernetes的所有控制命令都发给它，它负责具体的执行过程</p>
<p>在Master上运行着以下关键进程。</p>
<ul>
<li>Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程。</li>
<li>Kubernetes Controller Manager（kube-controller-manager）：Kubernetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的“大总管”。（控制啥）</li>
<li>Kubernetes Scheduler（kube-scheduler）：负责资源调度（Pod调度）的进程，相当于公交公司的“调度室”。（调度啥）</li>
</ul>
<p>另外，在Master上通常还需要部署etcd服务，因为Kubernetes里的所有资源对象的数据都被保存在etcd中。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node可以是一台物理主机，也可以是一台虚拟机<br>Node是Kubernetes集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器）<br>当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。<br>在每个Node上都运行着以下关键进程。</p>
<ul>
<li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能。</li>
<li>kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。</li>
<li>Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作。</li>
</ul>
<p>在默认情况下kubelet会向<code>Master</code>注册自己，这也是Kubernetes推荐的Node管理方式。一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身的情报，例如操作系统、Docker版本、机器的CPU和内存情况，以及当前有哪些Pod在运行等，这样Master就可以获知每个Node的资源使用情况，并实现<code>高效均衡的资源调度策略</code>。而某个Node在超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用（Not Ready），随后Master会触发“工作负载大转移”的自动流程。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>我们看到每个Pod都有一个特殊的被称为“根容器”的<code>Pause容器</code></p>
<p><img src="/../../ImgSource/pod_img.png" alt="avator"><br>为什么Kubernetes会设计出一个全新的Pod的概念并且Pod有这样特殊的组成结构？</p>
<ol>
<li>判断死亡率 一杀多</li>
<li>共享 IP ，Volume 解决通讯问题<br>每个Pod都分配了唯一的IP地址<br>Kubernetes要求底层网络支持集群内任意两个Pod之间的TCP&#x2F;IP直接通信，这通常采用虚拟二层网络技术来实现，例如<code>Flannel、OpenvSwitch</code>等<br>在Kubernetes里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。</li>
</ol>
<p>Pod其实有两种类型：<code>普通的Pod</code>及<code>静态Pod（Static Pod）</code>。后者比较特殊，它并没被存放在Kubernetes的etcd存储里，而是被存放在某个具体的<code>Node上的一个具体文件中</code>，并且只在此Node上启动、运行</p>
<p>在默认情况下，当Pod里的某个容器停止时，Kubernetes会自动检测到这个问题并且重新启动这个Pod（重启Pod里的所有容器），如果Pod所在的Node宕机，就会将这个Node上的所有Pod重新调度到其他节点</p>
<p>可以用kubectl describe pod xxxx来查看它的描述信息，以定位问题的成因</p>
<p>可以对服务器资源设置限额<br>CPU（Core）设置数量 100~300m 即占用0.1-0.3个CPU<br>在Kubernetes里，一个计算资源进行配额限定时需要设定以下两个参数。</p>
<ul>
<li>Requests：该资源的最小申请量，系统必须满足要求</li>
<li>Limits：该资源最大允许使用的量，不能被突破，当容器试图使用超过这个量的资源时，可能会被Kubernetes“杀掉”并重启。</li>
</ul>
<p><img src="/../../ImgSource/pod_request_limit.png" alt="avator"></p>
<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>一个Label是一个key&#x3D;value的键值对，其中key与value由用户自己指定</p>
<p>Label可以被附加到各种资源对象上，例如Node、Pod、Service、RC等，一个资源对象可以定义任意数量的Label</p>
<p>我们可以通过给指定的资源对象捆绑一个或多个不同的Label来实现多维度的资源分组管理功能</p>
<p>以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。例如，部署不同版本的应用到不同的环境中；监控和分析应用（日志记录、监控、告警）</p>
<p>例如：</p>
<ul>
<li>版本标签：”release” : “stable”、”release” : “canary”。</li>
<li>环境标签：”environment”:”dev”、”environment”:”qa”、”environment”:”production”。</li>
<li>分区标签：”partition” : “customerA”、”partition” :”customerB”。</li>
<li>质量管控标签：”track” : “daily”、”track” : “weekly”。</li>
</ul>
<p>随后可以通过LabelSelector（标签选择器）查询和筛选拥有某些Label的资源对象，Kubernetes通过这种方式实现了类似SQL的简单又通用的对象查询机制。</p>
<p><code>当前有两种Label Selector表达式</code>：基于等式的（Equality-based）和基于集合的（Set-based）</p>
<p>多个表达式之间用“，”进行分隔即可，几个条件之间是“AND”的关系<br>例如： name&#x3D;redis-slave,env!&#x3D;production</p>
<h3 id="Replication-Controller-RC"><a href="#Replication-Controller-RC" class="headerlink" title="Replication Controller (RC)"></a>Replication Controller (RC)</h3><p>简单来说，它其实定义了一个期望的场景，即声明某种Pod的副本数量在任意时刻都符合某个预期值</p>
<p>所以 RC的定义包括如下：</p>
<ul>
<li>Pod期待的副本数量。</li>
<li>用于筛选目标Pod的Label Selector。</li>
<li>当Pod的副本数量小于预期数量时，用于创建新Pod的Pod模板（template）。</li>
</ul>
<p>在我们定义了一个RC并将其提交到Kubernetes集群中后，Master上的Controller Manager组件就得到通知，定期巡检系统中当前存活的目标Pod，并确保目标Pod实例的数量刚好等于此RC的期望值，如果有过多的Pod副本在运行，系统就会停掉一些Pod，否则系统会再自动创建一些Pod。</p>
<p>删除RC并不会影响通过该RC已创建好的Pod。为了删除所有Pod，可以设置replicas的值为0，然后更新该RC。另外，kubectl提供了stop和delete命令来一次性删除RC和RC控制的全部Pod。</p>
<p>通过RC机制，Kubernetes很容易就实现了这种高级实用的特性，被称为“滚动升级”</p>
<p>同名冲突 所以 所以在Kubernetes 1.2中，升级为另外一个新概念——Replica Set</p>
<p>特性与作用：<br>在大多数情况下，我们通过定义一个RC实现Pod的创建及副本数量的自动控制。</p>
<ul>
<li>在RC里包括完整的Pod定义模板。</li>
<li>RC通过Label Selector机制实现对Pod副本的自动控制。</li>
<li>通过改变RC里的Pod副本数量，可以实现Pod的扩容或缩容。</li>
<li>通过改变RC里Pod模板中的镜像版本，可以实现Pod的滚动升级。</li>
</ul>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment是Kubernetes在1.2版本中引入的新概念，用于更好地解决Pod的编排问题<br>Deployment在内部使用了Replica Set来实现目的  与 RC相似度90%</p>
<p>Deployment相对于RC的一个最大升级是我们可以随时知道当前Pod“部署”的进度。实际上由于一个Pod的创建、调度、绑定节点及在目标Node上启动对应的容器这一完整过程需要一定的时间，所以我们期待系统启动N个Pod副本的目标状态，实际上是一个连续变化的“部署过程”导致的最终状态。</p>
<h3 id="Horizontal-Pod-Autoscaler-HPA"><a href="#Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="Horizontal Pod Autoscaler (HPA)"></a>Horizontal Pod Autoscaler (HPA)</h3><p>通过手工执行kubectl scale命令，我们可以实现Pod扩容或缩容。HPA 可以实现自动扩容<br><img src="/../../ImgSource/pod_hpa.png" alt="avator"><br>当这些Pod副本的CPUUtilizationPercentage的值超过90%时会触发自动动态扩容行为，在扩容或缩容时必须满足的一个约束条件是Pod的副本数为1～10。<br>通过度量指标</p>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>Pod的管理对象RC、Deployment、DaemonSet和Job都面向无状态的服务。但现实中有很多服务是有状态的，特别是一些复杂的中间件集群，例如MySQL集群、MongoDB集群、Akka集群、ZooKeeper集群等，这些应用集群有4个共同点。</p>
<p>（1）每个节点都有固定的身份ID，通过这个ID，集群中的成员可以相互发现并通信。<br>（2）集群的规模是比较固定的，集群规模不能随意变动。<br>（3）集群中的每个节点都是有状态的，通常会持久化数据到永久存储中。<br>（4）如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损。</p>
<p>StatefulSet  就是为了解决这个问题，有以下特性</p>
<ul>
<li>StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名称为kafka，那么第1个Pod叫kafka-0，第2个叫kafka-1，以此类推。</li>
<li>StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态。</li>
<li>StatefulSet里的Pod采用稳定的持久化存储卷，通过PV或PVC来实现，删除Pod时默认不会删除与StatefulSet相关的存储卷（为了保证数据的安全）。</li>
</ul>
<p>StatefulSet除了要与PV卷捆绑使用以存储Pod的状态数据，还要与Headless Service配合使用，即在每个StatefulSet定义中都要声明它属于哪个Headless Service。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>每个Service其实就是我们经常提起的微服务架构中的一个微服务。</p>
<p>我们的系统最终由多个提供不同业务能力而又彼此独立的微服务单元组成的，服务之间通过TCP&#x2F;IP进行通信，从而形成了强大而又灵活的弹性网格，拥有强大的分布式能力、弹性扩展能力、容错能力，程序架构也变得简单和直观许多</p>
<p>运行在每个Node上的kube-proxy进程其实就是一个智能的软件负载均衡器，负责把对Service的请求转发到后端的某个Pod实例上，并在内部实现服务的负载均衡与会话保持机制。但Kubernetes发明了一种很巧妙又影响深远的设计：Service没有共用一个负载均衡器的IP地址，每个Service都被分配了一个全局唯一的虚拟IP地址，这个虚拟IP被称为<code>Cluster IP</code>。这样一来，每个服务就变成了具备唯一IP地址的通信节点，服务调用就变成了最基础的TCP网络通信问题。</p>
<p>于是，服务发现这个棘手的问题在Kubernetes的架构里也得以轻松解决：只要用Service的Name与Service的Cluster IP地址做一个DNS域名映射即可完美解决问题 </p>
<p>多端口问题，很多服务都存在多个端口的问题，通常一个端口提供业务服务，另外一个端口提供管理服务，比如Mycat、Codis等常见中间件。 多端口需要给每个端口都命名</p>
<p>待续…</p>
<h3 id="JOB"><a href="#JOB" class="headerlink" title="JOB"></a>JOB</h3><p>与RC、Deployment、ReplicaSet、DaemonSet类似，Job也控制一组Pod容器。从这个角度来看，Job也是一种特殊的Pod副本自动控制器 同时Job控制Pod副本与RC等控制器的工作机制有以下重要差别。</p>
<p>（1）Job所控制的Pod副本是短暂运行的，可以将其视为一组Docker容器，其中的每个Docker容器都仅仅运行一次。 Kubernetes在1.5版本之后又提供了类似crontab的定时任务——<code>CronJob</code></p>
<p>（2）Job所控制的Pod副本的工作模式能够多实例并行计算，以TensorFlow框架为例，可以将一个机器学习的计算任务分布到10台机器上，在每台机器上都运行一个worker执行计算任务，这很适合通过Job生成10个Pod副本同时启动运算。</p>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume（存储卷）是Pod中能够被多个容器访问的<code>共享目录</code>。Kubernetes的Volume概念、用途和目的与Docker的Volume比较类似，但<code>两者不能等价</code>。首先，Kubernetes中的Volume被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下；其次，Kubernetes中的Volume与Pod的生命周期相同，但与容器的生命周期不相关，<code>当容器终止或者重启时，Volume中的数据也不会丢失。</code>最后，Kubernetes支持多种类型的Volume，例如<code>GlusterFS、Ceph</code>等先进的分布式文件系统。</p>
<p>Volume的使用也比较简单，在大多数情况下，我们先在Pod上声明一个Volume，然后在容器里引用该Volume并挂载（Mount）到容器里的某个目录上。</p>
<p>Kubernetes提供了非常丰富的Volume类型</p>
<ol>
<li><p>emptyDir</p>
<p>一个emptyDir Volume是在Pod分配到Node时创建的。从它的名称就可以看出，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为这是Kubernetes自动分配的一个目录，当Pod从Node上移除时，emptyDir中的数据也会被永久删除。</p>
<p>◎ <code>临时空间</code>，例如用于某些应用程序运行时所需的临时目录，且无须永久保留。</p>
<p>◎ 长时间任务的中间过程CheckPoint的临时保存目录。</p>
<p>◎ 一个容器需要从另一个容器中获取数据的目录（多容器共享目录）。</p>
<p>目前，用户无法控制emptyDir使用的介质种类。如果kubelet的配置是使用硬盘，那么所有emptyDir都将被创建在该硬盘上。Pod在将来可以设置emptyDir是位于硬盘、固态硬盘上还是基于内存的tmpfs上，上面的例子便采用了emptyDir类的Volume。</p>
</li>
<li><p>hostPath<br> hostPath为在Pod上挂载宿主机上的文件或目录，它通常可以用于以下几方面</p>
<ul>
<li><p>容器应用程序生成的日志文件需要永久保存时，可以使用宿主机的高速文件系统进行存储。</p>
</li>
<li><p>需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机&#x2F;var&#x2F;lib&#x2F;docker目录，使容器内部应用可以直接访问Docker的文件系统。</p>
</li>
</ul>
</li>
</ol>
<p>在使用这种类型的Volume时，需要注意以下几点。</p>
<ul>
<li><p>在不同的Node上具有相同配置的Pod，可能会因为宿主机上的目录和文件不同而导致对Volume上目录和文件的访问结果不一致。</p>
</li>
<li><p>如果使用了资源配额管理，则Kubernetes无法将hostPath在宿主机上使用的资源纳入管理。</p>
</li>
</ul>
<ol start="3">
<li><p>gcePersistentDisk<br> 使用这种类型的Volume表示使用谷歌公有云提供的永久磁盘（Persistent Disk，PD）存放Volume的数据，它与emptyDir不同，PD上的内容会被永久保存，当Pod被删除时，PD只是被卸载（Unmount），但不会被删除。需要注意的是，你需要先创建一个PD，才能使用<br> 使用gcePersistentDisk时有以下一些限制条件。<br> ◎ Node（运行kubelet的节点）需要是GCE虚拟机。<br> ◎ 这些虚拟机需要与PD存在于相同的GCE项目和Zone中。</p>
</li>
<li><p>awsElasticBlockStore</p>
</li>
</ol>
<p>  该类型的Volume使用亚马逊公有云提供的EBS Volume存储数据</p>
<ol start="5">
<li>NFS<br>使用NFS网络文件系统提供的共享目录存储数据时，我们需要在系统中部署一个NFS Server</li>
</ol>
<p><img src="/../../ImgSources/volumn_nfs.png" alt="avator"></p>
<p>6．其他类型的Volume◎ iscsi：使用iSCSI存储设备上的目录挂载到Pod中。<br>◎ flocker：使用Flocker管理存储卷。<br>◎ glusterfs：使用开源GlusterFS网络文件系统的目录挂载到Pod中。<br>◎ rbd：使用Ceph块设备共享存储（Rados Block Device）挂载到Pod中。<br>◎ gitRepo：通过挂载一个空目录，并从Git库clone一个git repository以供Pod使用。<br>◎ secret：一个Secret Volume用于为Pod提供加密的信息，你可以将定义在Kubernetes中的Secret直接挂载为文件让Pod访问。Secret Volume是通过TMFS（内存文件系统）实现的，这种类型的Volume总是不会被持久化的。</p>
<h3 id="Persistent-Volume-PV"><a href="#Persistent-Volume-PV" class="headerlink" title="Persistent Volume (PV)"></a>Persistent Volume (PV)</h3><p>我们通常会先定义一个网络存储，然后从中划出一个“网盘”并挂接到虚拟机上。Persistent Volume（PV）和与之相关联的Persistent Volume Claim（PVC）也起到了类似的作用。</p>
<p>PV可以被理解成Kubernetes集群中的某个网络存储对应的一块存储，它与Volume类似，但有以下区别。<br>◎ PV只能是网络存储，不属于任何Node，但可以在每个Node上访问。<br>◎ PV并不是被定义在Pod上的，而是独立于Pod之外定义的。<br>◎ PV目前支持的类型包括：gcePersistentDisk、AWSElasticBlockStore、AzureFile、AzureDisk、FC（Fibre Channel）、Flocker、NFS、iSCSI、RBD（Rados Block Device）、CephFS、Cinder、GlusterFS、VsphereVolume、Quobyte Volumes、VMware Photon、PortworxVolumes、ScaleIO Volumes和HostPath（仅供单机测试）。</p>
<p>如果某个Pod想申请某种类型的PV，则首先需要定义一个PersistentVolumeClaim对象：</p>
<p>最后说说PV的状态。PV是有状态的对象，它的状态有以下几种。<br>◎ Available：空闲状态。<br>◎ Bound：已经绑定到某个PVC上。<br>◎ Released：对应的PVC已经被删除，但资源还没有被集群收回。<br>◎ Failed：PV自动回收失败。</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace在很多情况下用于实现多租户的资源隔离。Namespace通过将集群内部的资源对象“分配”到不同的Namespace中，形成<code>逻辑上</code>分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。</p>
<p>接下来，如果不特别指明Namespace，则用户创建的Pod、RC、Service都将被系统创建到这个默认的名为<code>default</code>的Namespace中。</p>
<h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><p>Annotation（注解）与Label类似，也使用key&#x2F;value键值对的形式进行定义。不同的是Label具有严格的命名规则，它定义的是Kubernetes对象的元数据（Metadata），并且用于Label Selector。Annotation则是用户任意定义的附加信息，以便于外部工具查找。在很多时候，Kubernetes的模块自身会通过Annotation标记资源对象的一些特殊信息。</p>
<p>通常来说，用Annotation来记录的信息如下。<br>◎ build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像Hash值、Docker Registry地址等。<br>◎ 日志库、监控库、分析库等资源库的地址信息。<br>◎ 程序调试工具信息，例如工具名称、版本号等。<br>◎ 团队的联系信息，例如电话号码、负责人名称、网址等。</p>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>，Docker通过将程序、依赖库、数据及配置文件“打包固化”到一个不变的镜像文件中的做法，解决了应用的部署的难题，但这同时带来了棘手的问题，<code>即配置文件中的参数在运行期如何修改的问题</code>我们不可能在启动Docker容器后再修改容器里的配置文件，然后用新的配置文件重启容器里的用户主进程。为了解决这个问题，Docker提供了两种方式：</p>
<ul>
<li>行时通过容器的环境变量来传递参数；</li>
<li>Docker Volume将容器外的配置文件映射到容器内。</li>
</ul>
<p>这些配置项可以作为Map表中的一个项，整个Map的数据可以被持久化存储在Kubernetes的Etcd数据库中，然后提供API以方便Kubernetes相关组件或客户应用CRUD操作这些数据，上述专门用来保存配置参数的Map<code>就是Kubernetes ConfigMap资源对象</code></p>
<p>接下来，Kubernetes提供了一种内建机制，将存储在etcd中的ConfigMap通过<code>Volume映射</code>的方式变成目标Pod内的配置文件，不管目标Pod被调度到哪台服务器上，都会完成自动映射。进一步地，如果ConfigMap中的key-value数据被修改，则映射到Pod中的“配置文件”也会<code>随之自动更新</code>。于是，KubernetesConfigMap就成了分布式系统中最为简单（使用方法简单，但背后实现比较复杂）且对应用<code>无侵入的配置中心</code>。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>apiVersion</p>
<p>Kubernetes平台采用了“<code>核心+外围扩展</code>”的设计思路</p>
<ol>
<li>v1 核心API<br>大部分常见的核心资源对象都归属于v1这个核心API:</li>
</ol>
<ul>
<li>Node、</li>
<li>Pod、</li>
<li>Service、</li>
<li>Endpoints、</li>
<li>Namespace、</li>
<li>RC、</li>
<li>PersistentVolume等</li>
</ul>
<ol start="2">
<li>而在1.9版本之后引入了apps&#x2F;v1这个正式的扩展API</li>
</ol>
<h3 id="spec"><a href="#spec" class="headerlink" title="spec"></a>spec</h3><p>Kubernetes 1.8版本以后，Init container特性完全成熟，其定义被放入Pod的spec.initContainers一节</p>
<p>在Kubernetes 1.8中，资源对象中的很多Alpha、Beta版本的Annotations被取消，升级成了常规定义方式，在学习Kubernetes的过程中需要特别注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(kubernetes)/" data-id="cld1buvss000zbjopakdcfjha" data-title="每日一问1102(kubernetes)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1103(netstat命令用法)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(netstat%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(netstat%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95)/">每日一问1103(netstat命令用法)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="netstat-命令用法"><a href="#netstat-命令用法" class="headerlink" title="netstat 命令用法"></a>netstat 命令用法</h1><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><hr>
<ul>
<li>*** [Linux下netstat命令详解] (<a target="_blank" rel="noopener" href="https://blog.csdn.net/dongl890426/article/details/86981901">https://blog.csdn.net/dongl890426/article/details/86981901</a>)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(netstat%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95)/" data-id="cld1buvst0010bjop8vmfb3yq" data-title="每日一问1103(netstat命令用法)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1103(systemctl 命令)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(systemctl%20%E5%91%BD%E4%BB%A4)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(systemctl%20%E5%91%BD%E4%BB%A4)/">每日一问1103(systemctl 命令)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl  命令"></a>systemctl  命令</h1><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul>
<li><a href=""></a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1103(systemctl%20%E5%91%BD%E4%BB%A4)/" data-id="cld1buvst0011bjopap44ez9r" data-title="每日一问1103(systemctl 命令)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>