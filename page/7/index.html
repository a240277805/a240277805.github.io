<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020/每日一问1217(java集成es)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1217(java%E9%9B%86%E6%88%90es)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1217(java%E9%9B%86%E6%88%90es)/">每日一问1217(java集成es)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="java-集成es"><a href="#java-集成es" class="headerlink" title="java 集成es"></a>java 集成es</h1><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><ol>
<li>pom.xml中加入maven依赖</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;version&gt;7.7.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xu990128638/article/details/106177934">Java 项目集成 es</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html">es high-level 官网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1217(java%E9%9B%86%E6%88%90es)/" data-id="cld1bs9tr002gfynh173r0sl9" data-title="每日一问1217(java集成es)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1222(nacos)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1222(nacos)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1222(nacos)/">每日一问1222(nacos)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1222(nacos)/" data-id="cld1bs9ts002hfynh8gs752yj" data-title="每日一问1222(nacos)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1223(js相关)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1223(js%E7%9B%B8%E5%85%B3)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1223(js%E7%9B%B8%E5%85%B3)/">每日一问1223(js相关)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><p>##语法</p>
<h4 id="数组追加数组"><a href="#数组追加数组" class="headerlink" title="数组追加数组"></a>数组追加数组</h4><blockquote>
<p>数组.concat(追加的数组);</p>
</blockquote>
<h2 id="reduce-用法"><a href="#reduce-用法" class="headerlink" title="reduce 用法"></a>reduce 用法</h2><h4 id="reduce-方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。"><a href="#reduce-方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。" class="headerlink" title="reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。"></a><strong>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</strong></h4><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>
<p><strong>语法:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure>

<ul>
<li>callback （执行数组中每个值的函数，包含四个参数）<ul>
<li>previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</li>
<li>currentValue （数组中当前被处理的元素）</li>
<li>index （当前元素在数组中的索引）</li>
<li>array （调用 reduce 的数组）</li>
</ul>
</li>
<li>initialValue （作为第一次调用 callback 的第一个参数。）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="JS数组reduce-方法详解及高级技巧"><a href="#JS数组reduce-方法详解及高级技巧" class="headerlink" title="JS数组reduce()方法详解及高级技巧"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moqiutao/p/7389837.html">JS数组reduce()方法详解及高级技巧</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1223(js%E7%9B%B8%E5%85%B3)/" data-id="cld1bs9ts002ifynh4glgbvix" data-title="每日一问1223(js相关)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1224(es概念篇)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(es%E6%A6%82%E5%BF%B5%E7%AF%87)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(es%E6%A6%82%E5%BF%B5%E7%AF%87)/">每日一问1224(es概念篇)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="elastic-search-概念篇"><a href="#elastic-search-概念篇" class="headerlink" title="elastic search 概念篇"></a>elastic search 概念篇</h1><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>在存储结构上，由_index、_type和_id唯一标识一个文档。</p>
<p>_index指向一个或多个物理分片的逻辑命名空间，_type类型用于区分同一个集合中的不同细分，在不同的细分中，数据的整体模式是相同或相似的，不适合完全不同类型的数据。多个_type可以在相同的索引中存在，只要它们的字段不冲突即可（对于整个索引，映射在本质上被“扁平化”成一个单一的、全局的模式）。_id文档标记符由系统自动生成或使用者提供。</p>
<p><strong>理解type</strong></p>
<p>很多初学者喜欢套用RDBMS中的概念，将_index理解为数据库，将_type理解为表，这是很牵强的理解，实际上这是完全不同的概念，没什么相似性，不同_type下的字段不能冲突，删除整个_type也不会释放空间。在实际应用中，数据模型不同，有不同_type需求的时候，我们应该建立单独的索引，而不是在一个索引下使用不同的_type。删除过期老化的数据时，最好以索引为单位，而不是_type和_id。正由于_type在实际应用中容易引起概念混淆，以及允许索引存在多_type并没有什么实际意义，在ES 6.x版本中，一个索引只允许存在一个_type，未来的7.x版本将完全删除_type的概念。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片（shard）是底层的基本读写单元，分片的目的是分割巨大索引，让读写可以并行操作，由多台机器共同完成。读写请求最终落到某个分片上，分片可以独立执行读写工作。ES利用分片将数据分发到集群内各处。分片是数据的容器，文档保存在分片内，不会跨分片存储。分片又被分配到集群内的各个节点里。当集群规模扩大或缩小时，ES 会自动在各节点中迁移分片，使数据仍然均匀分布在集群里。</p>
<p>索引与分片的关系如下图所示:</p>
<p><img src="D:\workspace\0zmkWorkSpace\javaWorkspace\myGitWorkspace\java-learn-dictionary\markdown\ImgSource\es_shard1.png" alt="avator"></p>
<pre><code> 一个ES索引包含很多分片，一个分片是一个Lucene的索引，它本身就是一个完整的搜索引擎，可以独立执行建立索引和搜索任务。Lucene索引又由很多分段组成，每个分段都是一个倒排索引。ES每次“refresh”都会生成一个新的分段，其中包含若干文档的数据。在每个分段内部，文档的不同字段被单独建立索引。每个字段的值由若干词（Term）组成，Term是原文本内容经过分词器处理和语言处理后的最终结果（例如，去除标点符号和转换为词根）。
</code></pre>
<p>如果想了解Lucene分段由哪些文件组成，每个文件都存储了什么内容，则可以参考Apache Lucene 的手册：<a target="_blank" rel="noopener" href="http://lucene.apache.org/core/7_3_0/core/org/apache/lucene/codecs/lucene70/package-summary.html#package.description%E3%80%82">http://lucene.apache.org/core/7_3_0/core/org/apache/lucene/codecs/lucene70/package-summary.html#package.description。</a></p>
<p>索引建立的时候就需要确定好主分片数，在较老的版本中（5.x 版本之前），主分片数量不可以修改，副分片数可以随时修改。现在（5.x～6.x 版本之后）,ES 已经支持在一定条件的限制下，对某个索引的主分片进行拆分（Split）或缩小（Shrink）。但是，我们仍然需要在一开始就尽量规划好主分片数量：先依据硬件情况定好单个分片容量，然后<strong>依据业务场景预估数据量和增长量</strong>，再除以单个分片容量。??? 怎么预估数据量和增长量</p>
<p>分片数不够时，可以考虑新建索引，搜索1个有着50个分片的索引与搜索50个每个都有1个分片的索引完全等价，或者使用_split API来拆分索引（6.1版本开始支持）。</p>
<p>在实际应用中，我们不应该向单个索引持续写数据，直到它的分片巨大无比。巨大的索引会在数据老化后难以删除，<strong>以_id 为单位删除文档不会立刻释放空间，删除的 doc 只在 Lucene分段合并时才会真正从磁盘中删除</strong>。即使手工触发分段合并，仍然会引起较高的 I&#x2F;O 压力，并且可能因为分段巨大导致在合并过程中磁盘空间不足（分段大小大于磁盘可用空间的一半）。因此，我们建议周期性地创建新索引。</p>
<p><strong>索引别名</strong>就像一个快捷方式或软链接，不同的是它可以指向一个或多个索引。可以用于实现索引分组，或者索引间的无缝切换。</p>
<p>现在我们已经确定好了主分片数量，并且保证单个索引的数据量不会太大，周期性创建新索引带来的一个新问题是集群整体分片数量较多，集群管理的总分片数越多压力就越大。在每天生成一个新索引的场景中，可能某天产生的数据量很小，实际上不需要这么多分片，甚至一个就够。这时，可以使用_shrink API来缩减主分片数量，降低集群负载。</p>
<h4 id="那么索引如何更新，让新添加的文档可以被搜索到？"><a href="#那么索引如何更新，让新添加的文档可以被搜索到？" class="headerlink" title="那么索引如何更新，让新添加的文档可以被搜索到？"></a>那么索引如何更新，让新添加的文档可以被搜索到？</h4><p>答案是使用更多的索引，新增内容并写到一个新的倒排索引中，查询时，每个倒排索引都被轮流查询，查询完再对结果进行合并。每次内存缓冲的数据被写入文件时，会产生一个新的Lucene段，每个段都是一个倒排索引。在一个记录元信息的文件中描述了当前Lucene索引都含有哪些分段。由于分段的不变性，更新、删除等操作实际上是将数据标记为删除，记录到单独的位置，这种方式称为标记删除。因此删除部分数据不会释放磁盘空间。</p>
<p>在写操作中，一般会先在内存中缓冲一段数据，再将这些数据写入硬盘，每次写入硬盘的这批数据称为一个分段，如同任何写操作一样。一般情况下（direct方式除外），通过操作系统write接口写到磁盘的数据先到达系统缓存（内存）,write函数返回成功时，数据未必被刷到磁盘。通过手工调用flush，或者操作系统通过一定策略将系统缓存刷到磁盘。这种策略大幅提升了写入效率。从write函数返回成功开始，无论数据有没有被刷到磁盘，该数据已经对读取可见。</p>
<p>ES正是利用这种特性实现了近实时搜索。<strong>每秒产生一个新分段</strong>，新段先写入文件系统缓存，但稍后再执行flush刷盘操作，写操作很快会执行完，一旦写成功，就可以像其他文件一样被打开和读取了。由于系统先缓冲一段数据才写，且新段不会立即刷入磁盘，这两个过程中如果出现某些意外情况（如主机断电），则会存在丢失数据的风险。通用的做法是记录事务日志，每次对ES进行操作时均记录事务日志，当ES启动的时候，重放translog中所有在最后一次提交后发生的变更操作。比如HBase等都有自己的事务日志。</p>
<p>  <strong>注1</strong>：避免使用非常大的分片，因为这会对群集从故障中恢复的能力产生负面影响。 对分片的大小没有固定的限制，但是通常情况下很多场景限制在 50GB 的分片大小以内。</p>
<p>  <strong>注2</strong>：当在ElasticSearch集群中配置好你的索引后, 你要明白在集群运行中你无法调整分片设置. 既便以后你发现需要调整分片数量, 你也只能新建创建并对数据进行重新索引(reindex)(虽然reindex会比较耗时, 但至少能保证你不会停机).<br>  主分片的配置与硬盘分区很类似, 在对一块空的硬盘空间进行分区时, 会要求用户先进行数据备份, 然后配置新的分区, 最后把数据写到新的分区上。</p>
<p>  <strong>注3</strong>：尽可能使用基于时间的索引来管理数据保留期。 根据保留期将数据分组到索引中。 基于时间的索引还可以轻松地随时间改变主分片和副本的数量，因为可以更改下一个要生成的索引。</p>
<h2 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h2><p>在ES中，<strong>每秒清空一次写缓冲</strong>，将这些数据写入文件，这个过程称为<strong>refresh</strong>，每次refresh会创建一个新的Lucene 段。但是分段数量太多会带来较大的麻烦，每个段都会<strong>消耗文件句柄、内存</strong>。每个搜索请求都需要轮流检查每个段，查询完再对结果进行合并；所以段越多，搜索也就越慢。因此需要通过一定的策略将这些较小的段合并为大的段，常用的方案是选择大小相似的分段进行合并。在合并过程中，标记为删除的数据不会写入新分段，<strong>当合并过程结束，旧的分段数据被删除，标记删除的数据才从磁盘删除。</strong></p>
<p>HBase、Cassandra等系统都有类似的分段机制 Cassandra <strong>系统在段合并过程中的一个问题就是，当持续地向一个表中写入数据，如果段文件大小没有上限，当巨大的段达到磁盘空间的一半时，剩余空间不足以进行新的段合并过程。如果段文件设置一定上限不再合并，则对表中部分数据无法实现真正的物理删除。ES存在同样的问题。</strong></p>
<h3 id="Elasticsearch写数据的底层原理"><a href="#Elasticsearch写数据的底层原理" class="headerlink" title="Elasticsearch写数据的底层原理"></a><strong>Elasticsearch写数据的底层原理</strong></h3><p>1）先写入buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件。</p>
<p>2）如果buffer快满了，或者到一定时间，就会将buffer数据refresh到一个新的segment file中，但是此时数据不是直接进入segment file的磁盘文件的，而是先进入os cache的。这个过程就是refresh。</p>
<p>每隔1秒钟，es将buffer中的数据写入一个新的segment file，每秒钟会产生一个新的磁盘文件，segment file，这个segment file中就存储最近1秒内buffer中写入的数据。</p>
<p>但是如果buffer里面此时没有数据，那当然不会执行refresh操作咯，每秒创建换一个空的segment file，如果buffer里面有数据，默认1秒钟执行一次refresh操作，刷入一个新的segment file中。</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做os cache，操作系统缓存，就是说数据写入磁盘文件之前，会先进入os cache，先进入操作系统级别的一个内存缓存中去。</p>
<p>只要buffer中的数据被refresh操作，刷入os cache中，就代表这个数据就可以被搜索到了。</p>
<p>为什么叫es是准实时的？NRT，near real-time，准实时。默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。</p>
<p>可以通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。</p>
<p>只要数据被输入os cache中，buffer就会被清空了，因为不需要保留buffer了，数据在translog里面已经持久化到磁盘去一份了。</p>
<p><img src="/..%5CImgSource%5Ces_write1.png" alt="avator"></p>
<h3 id="分片大小如何影响性能"><a href="#分片大小如何影响性能" class="headerlink" title="分片大小如何影响性能"></a>分片大小如何影响性能</h3><p>  在Elasticsearch中，每个查询在每个分片的单个线程中执行。 但是，可以并行处理多个分片，对同一分片也可以进行多个查询和聚合。<br>  这意味着，如果不涉及缓存，则最小查询延迟将取决于数据、查询类型以及分片的大小。 查询大量小的分片将使每个分片的处理速度更快，但是需要按顺序排队和处理更多的任务，它不一定比查询较少数量的较大分片更快。 如果存在多个并发查询，则拥有大量小分片也会降低查询吞吐量。<br>  从查询性能角度确定最大分片大小的最佳方法是使用实际数据和查询进行基准测试。 始终以查询和加载索引的节点在生产中需要处理的内容基准，因为优化单个查询可能会产生误导性结果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="ES之1：基本概念及原理"><a href="#ES之1：基本概念及原理" class="headerlink" title="ES之1：基本概念及原理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/10108296.html">ES之1：基本概念及原理</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1224(es%E6%A6%82%E5%BF%B5%E7%AF%87)/" data-id="cld1bs9tt002jfynhf9cx2vvs" data-title="每日一问1224(es概念篇)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1225(Hystrix)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1225(Hystrix)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1225(Hystrix)/">每日一问1225(Hystrix)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><h2 id="为啥需要隔离"><a href="#为啥需要隔离" class="headerlink" title="为啥需要隔离"></a>为啥需要隔离</h2><p>例如，我们容器(Tomcat)配置的线程个数为1000，从服务A到服务R，其中服务I的并发量非常的大，需要500个线程来执行，此时，服务I又挂了，那么这500个线程很可能就夯死了，那么剩下的服务，总共可用的线程为500个，随着并发量的增大，剩余服务挂掉的风险就会越来越大，最后导致整个系统的所有服务都不可用，直到系统宕机。这就是服务的雪崩效应。Hystrix就是用来做资源隔离的，比如说，当客户端向服务端发送请求时，给服务I分配了10个线程，只要超过了这个并发量就走降级服务，就算服务I挂了，最多也就导致服务I不可用，容器的10个线程不可用了，但是不会影响系统中的其他服务。下面，我们就来具体说下这两种隔离策略：</p>
<h2 id="隔离策略"><a href="#隔离策略" class="headerlink" title="隔离策略"></a>隔离策略</h2><ul>
<li>线程池隔离 （默认）</li>
<li>信号量隔离</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>  Hystrix 是一个帮助解决分布式系统交互时超时处理和容错的类库, 它同样拥有保护系统的能力。Netflix的众多开源项目之一。</p>
<p>   \1. <strong>隔离</strong>：</p>
<p>​      Hystrix隔离方式采用线程&#x2F;信号的方式，通过隔离限制依赖的并发量和阻塞扩散</p>
<p>​      1)线程隔离</p>
<p>​      Hystrix在用户请求和服务之间加入了线程池。</p>
<p>​      Hystrix为每个依赖调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。线程数是可以被设定的。</p>
<p>​      原理：用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，则会进行降级处理，用户的请求不会被阻塞，至少可以看到一个执行结果（例如返回友好的提示信息），而不是无休止的等待或者看到系统崩溃。</p>
<p>   b）信号隔离：</p>
<p>​     信号隔离也可以用于限制并发访问，防止阻塞扩散, 与线程隔离最大不同在于执行依赖代码的线程依然是请求线程（该线程需要通过信号申请, 如果客户端是可信的且可以快速返回，可以使用信号隔离替换线程隔离,降低开销。信号量的大小可以动态调整, 线程池大小不可以。（参考文章2）</p>
<p> \2. <strong>熔断</strong>：</p>
<p>如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p>
<p><strong>熔断器:Circuit Breaker</strong></p>
<p>   熔断器是位于线程池之前的组件。用户请求某一服务之后，Hystrix会先经过熔断器，此时如果熔断器的状态是打开（跳起），则说明已经熔断，这时将直接进行降级处理，不会继续将请求发到线程池<strong>。</strong>&#x3D;&#x3D;熔断器相当于在线程池之前的一层屏障。每个熔断器默认维护10个bucket ，每秒创建一个bucket ，每个blucket记录成功,失败,超时,拒绝的次数。当有新的bucket被创建时，最旧的bucket会被抛弃。&#x3D;&#x3D;</p>
<p>​     熔断器的状态机：</p>
<p>​      <img src="https://images2015.cnblogs.com/blog/978381/201705/978381-20170516093016728-916759277.png" alt="img"></p>
<ul>
<li>Closed：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；</li>
<li>Open：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；</li>
<li>Half-Open：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；</li>
</ul>
<h2 id="、流程"><a href="#、流程" class="headerlink" title="、流程"></a>、流程</h2><p><img src="https://images2015.cnblogs.com/blog/978381/201705/978381-20170516093153119-1533131398.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">流程说明:</span><br><span class="line">1``:每次调用创建一个新的HystrixCommand，把依赖调用封装在run()方法中。</span><br><span class="line">2``:执行execute()/queue做同步或异步调用。</span><br><span class="line">3``:判断熔断器(circuit-breaker)是否打开，如果打开跳到步骤``8，``进行降级策略，如果关闭进入步骤。</span><br><span class="line">4``:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤``8，``否则继续后续步骤。</span><br><span class="line">5``:调用HystrixCommand的run方法。运行依赖逻辑</span><br><span class="line">5a:依赖逻辑调用超时，进入步骤``8。</span><br><span class="line">6``:判断逻辑是否调用成功</span><br><span class="line">6a:返回成功调用结果</span><br><span class="line">6b:调用出错，进入步骤``8。</span><br><span class="line">7``:计算熔断器状态，所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态。</span><br><span class="line">8``:getFallback()降级逻辑。</span><br><span class="line"> ``以下四种情况将触发getFallback调用：</span><br><span class="line"> ``(``1``)：run()方法抛出非HystrixBadRequestException异常</span><br><span class="line"> ``(``2``)：run()方法调用超时</span><br><span class="line"> ``(``3``)：熔断器开启拦截调用</span><br><span class="line"> ``(``4``)：线程池/队列/信号量是否跑满</span><br><span class="line">8a:没有实现getFallback的Command将直接抛出异常</span><br><span class="line">8b:fallback降级逻辑调用成功直接返回</span><br><span class="line">8c:降级逻辑调用失败抛出异常</span><br><span class="line">9``:返回执行成功结果</span><br></pre></td></tr></table></figure>

<h2 id="六、代码实现"><a href="#六、代码实现" class="headerlink" title="六、代码实现"></a>六、代码实现</h2><p>jar包：</p>
<p><strong>hystrix包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;`` </span><br><span class="line">``&lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;``  </span><br><span class="line">``&lt;artifactId&gt;hystrix-core&lt;/artifactId&gt;`` </span><br><span class="line">``&lt;version&gt;``1.4``.``21``&lt;/version&gt;``</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>设置参数</strong> 展开原码</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>circuitBreaker.errorThresholdPercentage</td>
<td>失败率达到多少百分比后熔断</td>
<td>默认值：50主要根据依赖重要性进行调整</td>
</tr>
<tr>
<td>circuitBreaker.forceClosed</td>
<td>是否强制关闭熔断</td>
<td>如果是强依赖，应该设置为true</td>
</tr>
<tr>
<td>circuitBreaker.requestVolumeThreshold</td>
<td>熔断触发的最小个数&#x2F;10s</td>
<td>默认值：20</td>
</tr>
<tr>
<td>circuitBreaker.sleepWindowInMilliseconds</td>
<td>熔断多少秒后去尝试请求</td>
<td>默认值：5000</td>
</tr>
<tr>
<td>commandKey</td>
<td></td>
<td>默认值：当前执行方法名</td>
</tr>
<tr>
<td>coreSize</td>
<td>线程池coreSize</td>
<td>默认值：10</td>
</tr>
<tr>
<td>execution.isolation.semaphore.maxConcurrentRequests</td>
<td>信号量最大并发度</td>
<td>SEMAPHORE模式有效，默认值：10</td>
</tr>
<tr>
<td>execution.isolation.strategy</td>
<td>隔离策略，有THREAD和SEMAPHORE</td>
<td>默认使用THREAD模式，以下几种可以使用SEMAPHORE模式：只想控制并发度外部的方法已经做了线程隔离调用的是本地方法或者可靠度非常高、耗时特别小的方法（如medis）</td>
</tr>
<tr>
<td>execution.isolation.thread.interruptOnTimeout</td>
<td>是否打开超时线程中断</td>
<td>THREAD模式有效</td>
</tr>
<tr>
<td>execution.isolation.thread.timeoutInMilliseconds</td>
<td>超时时间</td>
<td>默认值：1000在THREAD模式下，达到超时时间，可以中断在SEMAPHORE模式下，会等待执行完成后，再去判断是否超时</td>
</tr>
<tr>
<td>execution.timeout.enabled</td>
<td>是否打开超时</td>
<td></td>
</tr>
<tr>
<td>fallback.isolation.semaphore.maxConcurrentRequests</td>
<td>fallback最大并发度</td>
<td>默认值：10</td>
</tr>
<tr>
<td>groupKey</td>
<td>表示所属的group，一个group共用线程池</td>
<td>默认值：getClass().getSimpleName();</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>请求等待队列</td>
<td>默认值：-1如果使用正数，队列将从SynchronizeQueue改为LinkedBlockingQueue</td>
</tr>
<tr>
<td>hystrix.command.default.metrics.rollingStats.timeInMilliseconds</td>
<td>设置统计的时间窗口值的，毫秒值</td>
<td>circuit break 的打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</td>
</tr>
<tr>
<td>hystrix.command.default.metrics.rollingStats.numBuckets</td>
<td>设置一个rolling window被划分的数量</td>
<td></td>
</tr>
<tr>
<td>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds</td>
<td>记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1225(Hystrix)/" data-id="cld1bs9tt002kfynh8tyehtag" data-title="每日一问1225(Hystrix)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1226(ribbon)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1226(ribbon)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1226(ribbon)/">每日一问1226(ribbon)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h1><h2 id="ribbon-与-feign-关系"><a href="#ribbon-与-feign-关系" class="headerlink" title="ribbon 与 feign 关系"></a>ribbon 与 feign 关系</h2><p>Feign是一个声明式的web service客户端，它使得编写web service客户端更为容易。</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon是一个客户端负载均衡器。</p>
<p>如果微服务项目加上了spring-cloud-starter-netflix-hystrix依赖，那么，feign会通过代理模式， 自动将所有的方法用 hystrix 进行包装。</p>
<p>在Spring Cloud微服务体系下，微服务之间的互相调用可以通过Feign进行声明式调用，在这个服务调用过程中Feign会通过Ribbon从服务注册中心获取目标微服务的服务器地址列表，之后在网络请求的过程中Ribbon就会将请求以负载均衡的方式打到微服务的不同实例上，从而实现Spring Cloud微服务架构中最为关键的功能即服务发现及客户端负载均衡调用。</p>
<h3 id="RestTemplate-为啥-加上-LoadBalanced-就负载均衡了"><a href="#RestTemplate-为啥-加上-LoadBalanced-就负载均衡了" class="headerlink" title="RestTemplate 为啥 加上 @LoadBalanced 就负载均衡了"></a>RestTemplate 为啥 加上 @LoadBalanced 就负载均衡了</h3><h3 id="ribbon-源码解析"><a href="#ribbon-源码解析" class="headerlink" title="ribbon 源码解析"></a>ribbon 源码解析</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1bd66db5dc46">Ribbon详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1226(ribbon)/" data-id="cld1bs9tu002lfynh30pnd89u" data-title="每日一问1226(ribbon)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1227(threadlocal)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1227(threadlocal)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1227(threadlocal)/">每日一问1227(threadlocal)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="threadlocal"><a href="#threadlocal" class="headerlink" title="threadlocal"></a>threadlocal</h1><ol>
<li>lock 的资源是多个线程共享的，所以访问的时候需要加锁。</li>
<li>ThreadLocal 是每个线程都有一个副本，是不需要加锁的。</li>
<li>lock 是通过时间换空间的做法。</li>
<li>ThreadLocal 是典型的通过空间换时间的做法。</li>
</ol>
<p>值真正是放在ThreadLocalMap 中存取的，ThreadLocalMap 内部类有一个Entry 类，key是ThreadLocal 对象，value 就是你要存放的值，上面的代码value 存放的就是hello word。ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同：</p>
<ol>
<li>HashMap 的数据结构是数组+链表</li>
<li>ThreadLocalMap的数据结构仅仅是数组</li>
<li>HashMap 是通过链地址法解决hash 冲突的问题</li>
<li>ThreadLocalMap 是通过开放地址法来解决hash 冲突的问题</li>
<li>HashMap 里面的Entry 内部类的引用都是强引用</li>
<li>ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用</li>
</ol>
<p>看源码,</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20191026/7ed07e788f7048949cbea7c5842d7209.png" alt="img"></p>
<p><strong>链地址法和开放地址法的优缺点</strong></p>
<p>开放地址法：</p>
<ol>
<li>容易产生堆积问题，不适于大规模的数据存储。</li>
<li>散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</li>
<li>删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</li>
</ol>
<p>链地址法：</p>
<ol>
<li>处理冲突简单，且无堆积现象，平均查找长度短。</li>
<li>链表中的结点是动态申请的，适合构造表不能确定长度的情况。</li>
<li>删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</li>
<li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。</li>
</ol>
<p><strong>ThreadLocalMap 采用开放地址法原因</strong>ThreadLocal 中看到一个属性 HASH_INCREMENT &#x3D; 0x61c88647 ，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table，关于这个神奇的数字google 有很多解析，这里就不重复说了ThreadLocal 往往存放的数据量不会特别大（而且key 是弱引用又会被垃圾回收，及时让数据量更小），这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低</p>
<p><strong>为什么要交换</strong></p>
<p>这里解释下为什么交换，我们先来看看如果不交换的话，经过设置值和清理过期对象，会是以下这张图</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20191026/bb4730acefe44b0d99452953ab9ce4b3.png" alt="img"></p>
<p>这个时候如果我们再一次设置一个key&#x3D;15,value&#x3D;new2 的值，通过f(15)&#x3D;5,这个时候由于上次index&#x3D;5是过期对象，被清空了，所以可以存在数据，那么就直接存放在这里了</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20191026/d5451e3cf21a4610bb42a243a34fa6cb.png" alt="img"></p>
<p>你看，这样整个数组就存在两个key&#x3D;15 的数据了，这样是不允许的，所以一定要交换数据</p>
<hr>
<p>get 和 set 方法都有进行帮助 GC ，所以正常情况下是不会有内存溢出的，<em>但是如果创建了之后一直没有调用 get 或者 set 方法，还是有可能会内存溢出</em></p>
<p>所以最保险的方法就是，使用完之后就及时 remove 一下，加快垃圾回收，就完美的避免了垃圾回收</p>
<h2 id="个人记录"><a href="#个人记录" class="headerlink" title="个人记录"></a>个人记录</h2><p>threadlocal 里有个 threadlocalMap, 它的存储是  key是本线程实例化的引用(this),value是要存储的值；它的结构只有一个数组；key存储使用的开放地址法，（当出现hash冲突，则取下一个不冲突的位置，有个值8864 保证hash均匀分布在2的N次方上，初始长度是16），当 有个值被释放了，之前冲突的值要替换位置，（替换发生在 get,set方法内部），当没有调用get&#x2F;set方法 还是有可能造成内存泄漏；</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="Java弱引用-WeakReference-的理解与使用"><a href="#Java弱引用-WeakReference-的理解与使用" class="headerlink" title="Java弱引用(WeakReference)的理解与使用"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zjj1996/p/9140385.html">Java弱引用(WeakReference)的理解与使用</a></h1><p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/349724415_99908665">吃透ThreadLocal 源码的每一个细节和设计原理 </a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javageektech/article/details/108543987">阿粉昨天说我动不动就内存泄漏，我好委屈…</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1227(threadlocal)/" data-id="cld1bs9tu002mfynh9m708ffv" data-title="每日一问1227(threadlocal)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1228(sentinel)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1228(sentinel)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1228(sentinel)/">每日一问1228(sentinel)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h1><h2 id="Hystrix-和-sentinel-区别"><a href="#Hystrix-和-sentinel-区别" class="headerlink" title="Hystrix 和 sentinel 区别"></a>Hystrix 和 sentinel 区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.</span><br></pre></td></tr></table></figure>

<p>Hystrix 的关注点在于<strong>以隔离和熔断为主的容错机制</strong>，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。 </p>
<p> Sentinel 的侧重点在于：</p>
<ul>
<li>多样化的流量控制</li>
<li>熔断降级</li>
<li>系统负载保护</li>
<li>实时监控和控制台</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="Sentinel源码解析一（流程总览）"><a href="#Sentinel源码解析一（流程总览）" class="headerlink" title="Sentinel源码解析一（流程总览）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taromilk/p/11750962.html">Sentinel源码解析一（流程总览）</a></h1><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">熔断降级</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1228(sentinel)/" data-id="cld1bs9tv002nfynhd60r4f9p" data-title="每日一问1228(sentinel)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1229(序列化)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1229(%E5%BA%8F%E5%88%97%E5%8C%96)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1229(%E5%BA%8F%E5%88%97%E5%8C%96)/">每日一问1229(序列化)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h3 id="fastjson-Gson-jackson-区别"><a href="#fastjson-Gson-jackson-区别" class="headerlink" title="fastjson ,Gson,jackson 区别"></a>fastjson ,Gson,jackson 区别</h3><p>Jackson 在运行时占用的内存较少，Fastjson 的速度更快，而我，可以处理任意的 Java 对象，甚至在没有源代码的情况下。另外，我对泛型的支持也更加的友好。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6911102004958134285">Gson：我爸是 Google</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1229(%E5%BA%8F%E5%88%97%E5%8C%96)/" data-id="cld1bs9tv002ofynhey1ih0da" data-title="每日一问1229(序列化)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问1230(netty)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1230(netty)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1230(netty)/">每日一问1230(netty)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1230(netty)/" data-id="cld1bs9tw002pfynh9u0y8y83" data-title="每日一问1230(netty)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2022/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0922(%E6%9E%B6%E6%9E%84)/">每日一问0922(架构)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2022/%E8%BF%B0%E8%81%8C%E6%A8%A1%E6%9D%BF/">述职模板</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E7%A7%AF%E7%B4%AF/">英文单词积累</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%9C%B0%E5%9D%80/">好玩的地址</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/">摄影后期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>