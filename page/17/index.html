<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/17/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2020/每日一问1231(eventbus)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1231(eventbus)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1231(eventbus)/">每日一问1231(eventbus)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="eventbus"><a href="#eventbus" class="headerlink" title="eventbus"></a>eventbus</h1><p>消息总线</p>
<h1 id="什么时候用cloud-bus"><a href="#什么时候用cloud-bus" class="headerlink" title="什么时候用cloud bus"></a>什么时候用cloud bus</h1><p>spring cloud bus在整个后端服务中起到联通的作用，联通后端的多台服务器。我们为什么需要他做联通呢？</p>
<p>后端服务器一般都做了集群化，很多台服务器，而且在大促活动期经常发生服务的扩容、缩容、上线、下线。这样，后端服务器的数量、IP就会变来变去，如果我们想进行一些线上的管理和维护工作，就需要维护服务器的IP。</p>
<p>比如我们需要更新配置、比如我们需要同时失效所有服务器上的某个缓存，都需要向所有的相关服务器发送命令，也就是调用一个接口。</p>
<p>你可能会说，我们一般会采用zookeeper的方式，统一存储服务器的ip地址，需要的时候，向对应服务器发送命令。这是一个方案，但是他的解耦性、灵活性、实时性相比消息总线都差那么一点。</p>
<p>总的来说，就是在我们需要把一个操作散发到所有后端相关服务器的时候，就可以选择使用cloud bus了。</p>
<h1 id="cloud-bus能做什么"><a href="#cloud-bus能做什么" class="headerlink" title="cloud bus能做什么"></a>cloud bus能做什么</h1><p>当前spring cloud bus提供了两个可用的接口:1.&#x2F;bus&#x2F;env用于设置某一个配置项2.&#x2F;bus&#x2F;refresh用于刷新所有绑定到刷新点的配置项。</p>
<p>这两个接口是使用spring boot actuator方式发布出来的（可以参见：深入<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/9fab4e81d7bb">SpringBoot:自定义Endpoint</a>一文），接收到消息后会使用spring的stream框架（可以参考：张开涛的<a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/blog/1902886">解Spring事件驱动模型</a>一文）把消息传播到所有注册的相关服务器。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/babycomeon/p/11141160.html">SpringCloud系列教程 | 第八篇：Spring Cloud Bus 消息总线</a></p>
<p><a target="_blank" rel="noopener" href="https://buqutianya.blog.csdn.net/article/details/78698755?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">spring cloud 中消息总线（bus）使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/093ed9816993">spring cloud bus 扩展消息总线方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1231(eventbus)/" data-id="cld1buvtg001wbjop8ztr0ndd" data-title="每日一问1231(eventbus)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/2021上半年度总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">2021上半年度总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code>2021上半年度总结
</code></pre>
<h2 id="研发工作业绩"><a href="#研发工作业绩" class="headerlink" title="研发工作业绩"></a>研发工作业绩</h2><h3 id="1-研发效能平台"><a href="#1-研发效能平台" class="headerlink" title="1. 研发效能平台"></a>1. 研发效能平台</h3><ul>
<li>效能平台代码库统计功能</li>
<li>微服务&#x2F;L3  添加,删除，修改，列表 ，评论&#x2F;回复 添加删除 功能开发</li>
<li>二进制制品仓库，二进制目录树对接minio功能开发</li>
<li>二进制制品仓库 添加&#x2F;修改&#x2F;删除 功能开发</li>
<li>用例库下用例模块分组 数据树形展示功能开发</li>
<li>网关增加透传harbor 基础服务 功能开发</li>
<li>需求研发看板按模块分组，数据树形展示</li>
<li>工时功能开发</li>
</ul>
<h3 id="公网制品库"><a href="#公网制品库" class="headerlink" title="公网制品库"></a>公网制品库</h3><ul>
<li>公网制品库微服务 开发</li>
<li>公网制品库下载接口迁移文件服务</li>
</ul>
<h3 id="公网网关"><a href="#公网网关" class="headerlink" title="公网网关"></a>公网网关</h3><ul>
<li>网关合并方案设计</li>
<li>tomcat 上传文件连接超时问题</li>
</ul>
<h3 id="内外网文件服务"><a href="#内外网文件服务" class="headerlink" title="内外网文件服务"></a>内外网文件服务</h3><ul>
<li>解决大文件上传</li>
<li>流水线制品库改造，数据清洗脚本</li>
<li>文件服务上传时间长 连接中断问题修复</li>
</ul>
<h3 id="EDAS-调研-详情如下"><a href="#EDAS-调研-详情如下" class="headerlink" title="EDAS 调研 详情如下"></a>EDAS 调研 详情如下</h3><ul>
<li>EDAS nacos 自带 nacos 接入 </li>
<li>EDAS springcloud 功能准备 demo 搭建</li>
<li>EDAS RDS 数据库创建 以及问题跟进</li>
<li>EDAS 公有云子账号权限分批，功能预览</li>
<li>EDAS 监控 发布 链路追踪 限流 日志收集等功能测试</li>
</ul>
<h2 id="项目支撑情况"><a href="#项目支撑情况" class="headerlink" title="项目支撑情况"></a>项目支撑情况</h2><h3 id="千方科技官网"><a href="#千方科技官网" class="headerlink" title="千方科技官网"></a>千方科技官网</h3><ul>
<li>官网首页 banner 改版</li>
<li>官网首页 样板案例 改版 </li>
<li>官网招聘信息，新闻中心增加筛选 增加排序</li>
<li>官网 投资者关系 财务报告 数据导入  新功能开发完成</li>
</ul>
<h2 id="其他支撑事宜"><a href="#其他支撑事宜" class="headerlink" title="其他支撑事宜"></a>其他支撑事宜</h2><ul>
<li>harbo  镜像 chart 管理接入效能平台</li>
<li>代码生成项目优化</li>
<li>mino 二进制对象文件管理接入效能平台</li>
<li>接入 skywalking skywalking 告警功能开发</li>
<li>Spring boot admin 监控平台搭建 接入</li>
<li>ES 统计数据完善</li>
<li>common项目 通用工具包调整</li>
<li>优化网关 日志打印，token认证，链路追踪</li>
<li>java-tools java 内存调优工具 k8s 安装调研</li>
<li>千方CMS 系统 开发支持</li>
</ul>
<h2 id="个人发展想法"><a href="#个人发展想法" class="headerlink" title="个人发展想法"></a>个人发展想法</h2><p>希望更多的参与到应用架构设计和应用性能调优 相关的工作中，深挖技术瓶颈，解决平时工作中遇到的疑难杂症。</p>
<h2 id="下半年工作计划"><a href="#下半年工作计划" class="headerlink" title="下半年工作计划"></a>下半年工作计划</h2><p>下半年计划花更多的精力在服务治理和服务性能优化，使服务运行中一些常见问题能够有效控制和帮助开发人员快速定位问题定位线上问题，将这些功能迁移到效我们的效能平台中来。再有就是应用 监控管理，报警平台等相关的工作。</p>
<h2 id="工作建议"><a href="#工作建议" class="headerlink" title="工作建议"></a>工作建议</h2><p>建议平时工作中增加技术氛围，提升大家学习进步的积极性，再有提高代码质量，使之能够更好的复用。</p>
<h2 id="需要的支持或帮助"><a href="#需要的支持或帮助" class="headerlink" title="需要的支持或帮助"></a>需要的支持或帮助</h2><p>无</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" data-id="cld1buvth001xbjop3zuqfhvn" data-title="2021上半年度总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/EDAS测试输出文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/EDAS%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/EDAS%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA%E6%96%87%E6%A1%A3/">EDAS测试输出文档</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="EDAS-测试输出文档"><a href="#EDAS-测试输出文档" class="headerlink" title="EDAS 测试输出文档"></a>EDAS 测试输出文档</h1><h2 id="可借鉴功能"><a href="#可借鉴功能" class="headerlink" title="可借鉴功能"></a>可借鉴功能</h2><h3 id="部署-自动挂载Java-agent"><a href="#部署-自动挂载Java-agent" class="headerlink" title="部署 自动挂载Java agent"></a>部署 自动挂载Java agent</h3><p>默认自动挂载 Java Agent 进行精细化监控，并提供完整微服务治理方案（金丝雀发布、服务鉴权、限流&#x2F;降级等）</p>
<p>服务监控</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p>JVM监控，主机监控，调用链路监控， 可以集成skywalking到平台</p>
<p><img src="C:\Users\zmk\AppData\Roaming\Typora\typora-user-images\image-20210712110812197.png" alt="image-20210712110812197"></p>
<h2 id="EDAS-架构设计"><a href="#EDAS-架构设计" class="headerlink" title="EDAS 架构设计"></a>EDAS 架构设计</h2><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p>针对Java 应用单独处理部署，增加了很多java 分布式应用很多特有处理，比如增加agent,Spring cloud 监控等等。</p>
<h3 id="微服务空间设计"><a href="#微服务空间设计" class="headerlink" title="微服务空间设计"></a>微服务空间设计</h3><p>用来隔离各个k8s集群 应用组，适应不同的业务开发线吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/EDAS%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA%E6%96%87%E6%A1%A3/" data-id="cld1buvth001ybjop9uf69ll7" data-title="EDAS测试输出文档" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0104(缓存实施情况)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0104(%E7%BC%93%E5%AD%98%E5%AE%9E%E6%96%BD%E6%83%85%E5%86%B5)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0104(%E7%BC%93%E5%AD%98%E5%AE%9E%E6%96%BD%E6%83%85%E5%86%B5)/">每日一问0104(缓存实施情况)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="缓存实施情况"><a href="#缓存实施情况" class="headerlink" title="缓存实施情况"></a>缓存实施情况</h1><p><strong>redis key 规则定义</strong></p>
<p>定义redis key 规则方便 定位，拆分 或 附加的业务逻辑处理 。</p>
<p>比如： mq 聚合 缓存操作时统一处理</p>
<p>规则:<strong>{项目}:{服务名}:{业务模块}:{type}:{缓存接口}</strong></p>
<p> **type: **</p>
<ul>
<li>method-服务方法</li>
<li>dictionary-字典**</li>
</ul>
<h2 id="项目统一前缀"><a href="#项目统一前缀" class="headerlink" title="项目统一前缀"></a>项目统一前缀</h2><p><strong>devops:platform</strong></p>
<h3 id="效能平台缓存应用位置"><a href="#效能平台缓存应用位置" class="headerlink" title="效能平台缓存应用位置"></a><strong>效能平台缓存应用位置</strong></h3><table>
<thead>
<tr>
<th>添加缓存位置</th>
<th>实施情况</th>
<th>实施类型</th>
<th>失效策略</th>
</tr>
</thead>
<tbody><tr>
<td>表 全部项目&#x2F;我参与的&#x2F;企业公开的&#x2F;已归档项目&#x2F;回收站</td>
<td>进行中</td>
<td></td>
<td>事件+消费者规则匹配+超时</td>
</tr>
<tr>
<td>我的(需求，缺陷，任务，测试用例) 列表视图&#x2F;卡片视图 我执行的&#x2F;创建的&#x2F;删除的</td>
<td>已添加</td>
<td>接口缓存</td>
<td>事件+消费者规则匹配</td>
</tr>
<tr>
<td>项目内(需求，缺陷，任务，测试用例) 列表视图&#x2F;卡片视图</td>
<td>已添加</td>
<td>接口缓存</td>
<td>事件+消费者规则匹配</td>
</tr>
<tr>
<td>gitlab 代码库&#x2F;分组，子代码库&#x2F;子代码组</td>
<td>已添加</td>
<td>接口缓存</td>
<td>事件+消费者规则匹配</td>
</tr>
<tr>
<td>gitlab 全局 代码库&#x2F;分组，子代码库&#x2F;子代码组</td>
<td>已添加</td>
<td>接口缓存</td>
<td>事件+消费者规则匹配</td>
</tr>
<tr>
<td>用户信息</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>用户权限角色</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>chart系统鉴权信息缓存</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gitlab token</td>
<td>已添加</td>
<td>内部缓存</td>
<td>超时</td>
</tr>
<tr>
<td>流水线构建历史</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>流水线已运行完构建日志</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>流水线已运行完构建日志</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>状态列表 -&gt;字典缓存</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事务差异化字段-&gt;字典缓存</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>minio 生成的永久下载地址</td>
<td>未添加</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="redis-缓存类型和定义"><a href="#redis-缓存类型和定义" class="headerlink" title="redis 缓存类型和定义"></a>redis 缓存类型和定义</h3><table>
<thead>
<tr>
<th>内容</th>
<th>key</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>事务导入缓存</td>
<td>devops:platform:import:${事务类型}<em>${工号}</em>${毫秒时间戳}</td>
<td>devops:platform:import:defect_10011069_312312432212</td>
</tr>
<tr>
<td>gitlab每个人的Token缓存</td>
<td>devops:platform:gitlabUserToken:{工号}</td>
<td>devops:platform:import:gitlabUserToken:10011069</td>
</tr>
<tr>
<td>Es报警邮件规则引擎缓存</td>
<td>devops:platform:esMailRole:{报警类型:异常报警&#x2F;超时报警}</td>
<td>devops:platform:esMailRole:error</td>
</tr>
<tr>
<td>kafka缓存消费者业务幂等性ID缓存</td>
<td>devops:platform:kafka:cacheTraceId:{幂等ID}</td>
<td>devops:platform:kafka:cacheTraceId:dbadc</td>
</tr>
<tr>
<td>需求列表卡片视图缓存</td>
<td>devops:platform:demand:method:page:{参数}</td>
<td>devops:platform:demand:method:page:{firstPage:true}</td>
</tr>
<tr>
<td>需求列表缓存</td>
<td>devops:platform:demand:method:list:{参数}</td>
<td>devops:platform:demand:method:list:{firstPage:true}</td>
</tr>
<tr>
<td>我的卡片列表  执行的&#x2F;创建得&#x2F;参与的 缓存</td>
<td>devops:platform:demand:method:myCardList:{用户ID}_{参数}</td>
<td>devops:platform:demand:method:myCardList:31203123123_{firstPage:true}</td>
</tr>
<tr>
<td>缺陷列表卡片视图缓存</td>
<td>devops:platform:defect:method:page:{参数}</td>
<td>devops:platform:defect:method:page:{firstPage:true}</td>
</tr>
<tr>
<td>缺陷列表视图缓存</td>
<td>devops:platform:defect:method:list:{参数}</td>
<td>devops:platform:defect:method:list:{firstPage:true}</td>
</tr>
<tr>
<td>我的缺陷列表卡片视图缓存</td>
<td>devops:platform:defect:method:myCardList:{用户ID}_请求体</td>
<td>devops:platform:defect:method:myCardList:132312312321_{firstPage:true}</td>
</tr>
<tr>
<td>代码库分组顶级分组列表缓存</td>
<td>devops:platform:gitlab:group:method:groups:{项目ID}<em>{是否项目内}</em>{用户工号}</td>
<td>devops:platform:gitlab:group:method:groups:12_true_10011069</td>
</tr>
<tr>
<td>代码库列表缓存</td>
<td>devops:platform:gitlab:code:method:getProjets:{项目ID}<em>{是否项目内}</em>{工号}</td>
<td>devops:platform:gitlab:code:method:getProjets:12_true_10011069</td>
</tr>
<tr>
<td>代码库子分组列表缓存</td>
<td>devops:platform:gitlab:group:method:subgroups:{分组ID}<em>{项目ID}</em>{是否项目内}_{是否顶级分组}</td>
<td>devops:platform:gitlab:group:method:subgroups:21_21_true_true</td>
</tr>
<tr>
<td>代码库分组下项目列表缓存</td>
<td>devops:platform:gitlab:code:method:getGroupProjects:{代码库ID}<em>{项目ID}</em>{是否关联项目}_{工号}</td>
<td>devops:platform:gitlab:code:method:getGroupProjects:21_21_true_10011069</td>
</tr>
<tr>
<td>代码库分组详情缓存</td>
<td>devops:platform:gitlab:group_code:method:getGroupDetail:{分组ID}<em>{项目ID}</em>{是否关联项目}_{工号}</td>
<td>devops:platform:gitlab:group_code:method:getGroupDetail:21_21_true_10011069</td>
</tr>
<tr>
<td>任务可关联列表缓存</td>
<td>devops:platform:task:method:connectList:{参数}</td>
<td>devops:platform:task:method:connectList:{firstPage:true}</td>
</tr>
<tr>
<td>任务卡片视图列表缓存</td>
<td>devops:platform:task:method:cardList:{参数}</td>
<td>devops:platform:task:method:cardList:{firstPage:true}</td>
</tr>
<tr>
<td>我的任务卡片列表缓存</td>
<td>devops:platform:task:method:myCardList:{用户ID}_{参数}</td>
<td>devops:platform:task:method:myCardList:12313132_{firstPage:true}</td>
</tr>
<tr>
<td>任务列表缓存</td>
<td>devops:platform:task:method:list:{参数}</td>
<td>devops:platform:task:method:list:{firstPage:true}</td>
</tr>
<tr>
<td>测试用例列表缓存</td>
<td>devops:platform:test_case:method:list:{参数}</td>
<td>devops:platform:test_case:method:list:{firstPage:true}</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0104(%E7%BC%93%E5%AD%98%E5%AE%9E%E6%96%BD%E6%83%85%E5%86%B5)/" data-id="cld1buvti001zbjoph1wr3e6p" data-title="每日一问0104(缓存实施情况)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0114(Spring循环依赖)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0114(Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0114(Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96)/">每日一问0114(Spring循环依赖)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h1><p><strong>【1】 getSingleton(beanName)：源码如下：</strong></p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//查询缓存</span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  //缓存中存在并且args是null</span><br><span class="line">  if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">       //.......省略部分代码     </span><br><span class="line">       //直接获取Bean实例</span><br><span class="line">   bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> //getSingleton源码，DefaultSingletonBeanRegistry#getSingleton</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">     //先从一级缓存中获取已经实例化属性赋值完成的Bean</span><br><span class="line">  Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">     //一级缓存不存在，并且Bean正处于创建的过程中</span><br><span class="line">  if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">   synchronized (this.singletonObjects) &#123;</span><br><span class="line">                //从二级缓存中查询，获取Bean的早期引用，实例化完成但是未赋值完成的Bean</span><br><span class="line">    singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">                //二级缓存中不存在，并且允许创建早期引用（二级缓存中添加）</span><br><span class="line">    if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    //从三级缓存中查询，实例化完成，属性未装配完成</span><br><span class="line">     ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">     if (singletonFactory != null) &#123;</span><br><span class="line">      singletonObject = singletonFactory.getObject();</span><br><span class="line">                         //二级缓存中添加</span><br><span class="line">      this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        //从三级缓存中移除</span><br><span class="line">      this.singletonFactories.remove(beanName);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return singletonObject;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从源码可以得知，doGetBean最初是查询缓存，一二三级缓存全部查询，如果三级缓存存在则将Bean早期引用存放在二级缓存中并移除三级缓存。（升级为二级缓存）</li>
</ul>
<p><strong>【2】addSingletonFactory：源码如下</strong></p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//中间省略部分代码。。。。。</span><br><span class="line">  //创建Bean的源码，在AbstractAutowireCapableBeanFactory#doCreateBean方法中</span><br><span class="line">  if (instanceWrapper == null) &#123;</span><br><span class="line">            //实例化Bean</span><br><span class="line">   instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  //允许提前暴露</span><br><span class="line">  if (earlySingletonExposure) &#123;</span><br><span class="line">            //添加到三级缓存中</span><br><span class="line">   addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">            //属性装配，属性赋值的时候，如果有发现属性引用了另外一个Bean，则调用getBean方法</span><br><span class="line">   populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            //初始化Bean，调用init-method，afterproperties方法等操作</span><br><span class="line">   exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//添加到三级缓存的源码，在DefaultSingletonBeanRegistry#addSingletonFactory</span><br><span class="line">protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">  synchronized (this.singletonObjects) &#123;</span><br><span class="line">            //一级缓存中不存在</span><br><span class="line">   if (!this.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">                //放入三级缓存</span><br><span class="line">    this.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                //从二级缓存中移除，</span><br><span class="line">    this.earlySingletonObjects.remove(beanName);</span><br><span class="line">    this.registeredSingletons.add(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从源码得知，Bean在实例化完成之后会直接将未装配的Bean工厂存放在<strong>「三级缓存」</strong>中，并且<strong>「移除二级缓存」</strong></li>
</ul>
<p><strong>【3】addSingleton：源码如下：</strong></p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获取单例对象的方法，DefaultSingletonBeanRegistry#getSingleton</span><br><span class="line">//调用createBean实例化Bean</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"></span><br><span class="line">//。。。。中间省略部分代码 </span><br><span class="line"></span><br><span class="line">//doCreateBean之后才调用，实例化，属性赋值完成的Bean装入一级缓存，可以直接使用的Bean</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">//addSingleton源码，在DefaultSingletonBeanRegistry#addSingleton方法中</span><br><span class="line">protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">  synchronized (this.singletonObjects) &#123;</span><br><span class="line">            //一级缓存中添加</span><br><span class="line">   this.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            //移除三级缓存</span><br><span class="line">   this.singletonFactories.remove(beanName);</span><br><span class="line">            //移除二级缓存</span><br><span class="line">   this.earlySingletonObjects.remove(beanName);</span><br><span class="line">   this.registeredSingletons.add(beanName);</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="spring-我是如何解决循环依赖的？"><a href="#spring-我是如何解决循环依赖的？" class="headerlink" title="spring: 我是如何解决循环依赖的？"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wjxzs/p/14239052.html">spring: 我是如何解决循环依赖的？</a></h1><p><a target="_blank" rel="noopener" href="https://hellojava.com/a/88587.html">Spring如何解决循环依赖，你真的懂了？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0114(Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96)/" data-id="cld1buvti0020bjop5lm06js4" data-title="每日一问0114(Spring循环依赖)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0901(markdown语法)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0901(markdown%E8%AF%AD%E6%B3%95)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0901(markdown%E8%AF%AD%E6%B3%95)/">每日一问0901(markdown语法)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h1><p>&#x3D;&#x3D;&#x3D;dafs&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;&#x3D;&#x3D;fasdfsd&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;dsf&#x3D;&#x3D;<br>&#x3D;fsdf&#x3D;</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐标题 | 右对齐标题 | 居中对齐标题 |</span><br><span class="line">| :------| ------: | :------: |</span><br><span class="line">| 短文本 | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>左对齐</th>
<th align="center">居中</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td><em>（斜体）文本1</em></td>
<td align="center"><strong>（加粗）文本2</strong></td>
<td align="right"><del>（删除线）文本3</del></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://jianshu.com/">简书</a></td>
<td align="center">$\color{red}{红色字}$</td>
<td align="right"><em><strong>（加粗斜体）文本6</strong></em></td>
</tr>
</tbody></table>
<h3 id="Markdown-实现”多级有序列表"><a href="#Markdown-实现”多级有序列表" class="headerlink" title="Markdown 实现”多级有序列表"></a>Markdown 实现”多级有序列表</h3><p>具体方法是: 写下一级有序列表时, 缩进 4 个空格</p>
<p>A.</p>
<ol>
<li>段落标题<ol>
<li>段落标题<ol>
<li>段落标题</li>
<li>段落标题</li>
</ol>
</li>
<li>段落标题</li>
<li>段落标题</li>
</ol>
</li>
<li>段落标题</li>
</ol>
<p>B.</p>
<ul>
<li>1.段落标题<ul>
<li>1.1段落标题</li>
<li>1.2段落标题<ul>
<li>1.2.1段落标题</li>
<li>1.2.2段落标题</li>
</ul>
</li>
</ul>
</li>
<li>2.段落标题</li>
</ul>
<p>C.</p>
<ul>
<li>段落标题<ul>
<li>段落标题</li>
<li>段落标题<ul>
<li>段落标题</li>
<li>段落标题</li>
</ul>
</li>
</ul>
</li>
<li>2.段落标题</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>区块引用</p>
<blockquote>
<p>嵌套引用</p>
<blockquote>
<p>三嵌套引用</p>
<blockquote>
<p>四嵌套引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>$\underline{幽默小故事，笑死人不偿命}$<br><br>我：“老板，你这清炒油麦菜是荤菜还是素菜？<br>老板：“当然是素菜了”<br><br>我：“那这条虫是怎么回事”<br>老板：“呃……它也是来吃饭的。”<br><br>我：“它吃饭凭什么我付钱？我又不认识它！”<br>老板哭着说：“它为了这顿饭，把命都丢了，你还能要求它AA制吗？”</p>
</blockquote>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: 是否已收到消息？</span><br><span class="line">B--&gt;&gt;A: 已收到消息</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 甘特图</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">section 项目A</span><br><span class="line">任务1           :a1, 2018-06-06, 30d</span><br><span class="line">任务2     :after a1  , 20d</span><br><span class="line">section 项目B</span><br><span class="line">任务3      :2018-06-12  , 12d</span><br><span class="line">任务4      : 24d</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0901(markdown%E8%AF%AD%E6%B3%95)/" data-id="cld1buvum004abjop0bk9283l" data-title="每日一问0901(markdown语法)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0902(NLP自然语言处理)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0902(NLP%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0902(NLP%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86)/">每日一问0902(NLP自然语言处理)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NLP-自然语言处理"><a href="#NLP-自然语言处理" class="headerlink" title="NLP(自然语言处理)"></a>NLP(自然语言处理)</h1><p>NLP 发展处于初级阶段 原因</p>
<p>造成这样的原因其实比较简单，第一、高质量语料的获取成本很高；第二、真正懂 NLP 技术的人还是比较少，门槛比较高。</p>
<p>突破口的话，我觉得仍然是 理解业务场景，和高质量语料的获取 问题。</p>
<p>这里需要学习的有 分词技术、TF-IDF、朴素贝叶斯算法、Word Embedding、LDA、TextCNN 等</p>
<p>从最前沿科技发展的角度来说，应该会有一批人研究 纯粹的无监督学习 的新方法，毕竟这个是非常理想的 NLP 进化方向</p>
<p>(es 推荐用到了)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0902(NLP%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86)/" data-id="cld1buvun004bbjop4nkw2vxr" data-title="每日一问0902(NLP自然语言处理)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0903(Mysql知识点)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0903(Mysql%E7%9F%A5%E8%AF%86%E7%82%B9)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0903(Mysql%E7%9F%A5%E8%AF%86%E7%82%B9)/">每日一问0903(Mysql知识点)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Mysql知识点"><a href="#Mysql知识点" class="headerlink" title="Mysql知识点"></a>Mysql知识点</h1><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567764108237&di=f9e123ee1767a719e0cd665dc397a5b2&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/54444bc7077289d9330b6d63653afba0.jpg?x-oss-process=image/resize,p_100/auto-orient,1/quality,q_90/format,jpg/watermark,image_eXVuY2VzaGk=,t_100" alt="avatar"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/../../ImgSource/image-20210720142315630.png" alt="image-20210720142315630"></p>
<h2 id="InnoDB-存储结构"><a href="#InnoDB-存储结构" class="headerlink" title="InnoDB 存储结构"></a>InnoDB 存储结构</h2><p><a target="_blank" rel="noopener" href="https://nicky-chin.cn/media/mysql-page-detail/innodb-engine-struct.png"><img src="https://nicky-chin.cn/media/mysql-page-detail/innodb-engine-struct.png" alt="img"></a></p>
<p>从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间内，称为表空间(tablespace)，而表空间由段（sengment）、区（extent）、页（page）组成。 在一些文档中extend又称块（block）。</p>
<h3 id="1-1-表空间（table-space）"><a href="#1-1-表空间（table-space）" class="headerlink" title="1.1 表空间（table space）"></a>1.1 表空间（table space）</h3><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
<p>在 InnoDB 中存在两种表空间的类型：共享表空间和独立表空间。如果是共享表空间就意味着多张表共用一个表空间。如果是独立表空间，就意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间可以在不同的数据库之间进行迁移。可通过命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure>

<p>查看当前系统启用的表空间类型。目前最新版本已经默认启用独立表空间。</p>
<p>InnoDB把数据保存在表空间内，表空间可以看作是InnoDB存储引擎逻辑结构的最高层。本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间并不只是存储表和索引，还保存了回滚段、双写缓冲区等。</p>
<h3 id="1-2-段（segment）"><a href="#1-2-段（segment）" class="headerlink" title="1.2 段（segment）"></a>1.2 段（segment）</h3><p>段（Segment）由一个或多个区组成，区在文件系统是一个<strong>连续分配</strong>的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<h3 id="1-3-区块（extent）"><a href="#1-3-区块（extent）" class="headerlink" title="1.3 区块（extent）"></a>1.3 区块（extent）</h3><p>在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。在任何情况下每个区大小都为1MB，为了保证页的连续性，&#x3D;&#x3D;InnoDB存储引擎每次从磁盘一次申请4-5个区&#x3D;&#x3D;。默认情况下，InnoDB存储引擎的页大小为16KB，即一个区中有64个连续的页。</p>
<h3 id="1-4-页（Page）"><a href="#1-4-页（Page）" class="headerlink" title="1.4 页（Page）"></a>1.4 页（Page）</h3><p>页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB；InnoDB存储引擎从1.2.x版本碍事，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p>
<p>innoDB存储引擎中，常见的页类型有：</p>
<blockquote>
<ol>
<li>数据页（B-tree Node)</li>
<li>undo页（undo Log Page）</li>
<li>系统页 （System Page）</li>
<li>事物数据页 （Transaction System Page）</li>
<li>插入缓冲位图页（Insert Buffer Bitmap）</li>
<li>插入缓冲空闲列表页（Insert Buffer Free List）</li>
<li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li>
<li>压缩的二进制大对象页 （compressed BLOB Page）</li>
</ol>
</blockquote>
<h3 id="1-5-行（row）"><a href="#1-5-行（row）" class="headerlink" title="1.5 行（row）"></a>1.5 行（row）</h3><p>InnoDB存储引擎是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放16KB&#x2F;2-200，即7992行记录。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="innerDB"><a href="#innerDB" class="headerlink" title="innerDB"></a>innerDB</h3><h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><ul>
<li>限定数据的范围 （增删改查）</li>
<li>读写分离</li>
<li>垂直分区 优点:减少读取的Block数，减少I&#x2F;O 次数。缺点：主键冗余 </li>
<li>水平分区 表的行数超过200万 就会变慢</li>
</ul>
<h3 id="一条SQL执行很慢-可能原因？"><a href="#一条SQL执行很慢-可能原因？" class="headerlink" title="一条SQL执行很慢 可能原因？"></a>一条SQL执行很慢 可能原因？</h3><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询日志：响应时间超过阈值的语句，默认时间10秒，默认不开，会影响性能，开启参数  slow_query_log&#x3D;1</p>
<p>slow_query_log_file 这个表中记录</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a> </p>
<ol>
<li>刷脏页 (什么时候刷脏页?)</li>
</ol>
<h3 id="explain作用"><a href="#explain作用" class="headerlink" title="explain作用"></a>explain作用</h3><p>查看sql的执行计划，帮助我们分析mysql是如何解析sql语句的。</p>
<ul>
<li>查看表的加载顺序。</li>
<li>查看sql的查询类型。</li>
<li>哪些索引可能被使用，哪些索引又被实际使用了。</li>
<li>表之间的引用关系。</li>
<li>一个表中有多少行被优化器查询。</li>
<li>其他额外的辅助信息。</li>
</ul>
<h4 id="id详解"><a href="#id详解" class="headerlink" title="id详解"></a>id详解</h4><p>含义：select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</p>
<p>id的情况有三种，分别是：</p>
<ul>
<li>id相同表示加载表的顺序是从上到下。</li>
<li>id不同id值越大，优先级越高，越先被执行。</li>
<li>id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li>
</ul>
<h4 id="key-表示实际使用的索引"><a href="#key-表示实际使用的索引" class="headerlink" title="key:表示实际使用的索引"></a>key:表示实际使用的索引</h4><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL </p>
<h3 id="mysql单表数据达到一定上限查询为啥会慢"><a href="#mysql单表数据达到一定上限查询为啥会慢" class="headerlink" title="mysql单表数据达到一定上限查询为啥会慢"></a>mysql单表数据达到一定上限查询为啥会慢</h3><ul>
<li>假如MySQL服务器有足够的内存能将前三层索引缓存在内存中，索引只有三层，那么通过聚簇索引访问数据只需一次磁盘I&#x2F;O。而当我们数据量过大，索引层级达到四层或四层以上时，通过聚簇索引访问就需要两次以上的磁盘I&#x2F;O了。</li>
<li>当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降。当然，这个还有具体的表结构的设计有关，最终导致的问题都是内存限制。这里，增加硬件配置，可能会带来立竿见影的性能提升哈。</li>
</ul>
<h3 id="主备复制-数据迁移"><a href="#主备复制-数据迁移" class="headerlink" title="主备复制,数据迁移"></a>主备复制,数据迁移</h3><p>根据binlog</p>
<p>canal</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d591c0a6fb9a06b1a5688e8?utm_source=gold_browser_extension">详解B+树及其正确打开方式</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247486241&idx=1&sn=b9110c9d5be352f115c0d8cf6a0a520e&chksm=9bd0a6b9aca72faff0fe2f1ea1c3f43d6716f882bde357a999fe0094aa4e1f880f46473d1b98&scene=27#wechat_redirect">MySQL的索引</a><br><a target="_blank" rel="noopener" href="http://www.luyixian.cn/news_show_359744.aspx">分库分表的一些思考</a></p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><a target="_blank" rel="noopener" href="https://nicky-chin.cn/2019/07/11/mysql-page-detail/">MySQL中的page页详解</a> （多看两遍）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0903(Mysql%E7%9F%A5%E8%AF%86%E7%82%B9)/" data-id="cld1buvun004cbjop7eoqdlkm" data-title="每日一问0903(Mysql知识点)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0904(Mysql索引)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0904(Mysql%E7%B4%A2%E5%BC%95)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0904(Mysql%E7%B4%A2%E5%BC%95)/">每日一问0904(Mysql索引)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="索引好处"><a href="#索引好处" class="headerlink" title="索引好处"></a>索引好处</h3><p>关于MySQL索引的好处，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。</p>
<p>数据是存储在磁盘上的，操作系统读取磁盘的最小单位是页，如果没有索引，会加载所有的数据到内存，依次进行检索，加载的总数据会很多，磁盘IO多。</p>
<p>没有索引的情况下，不论是以主键还是其他列作为搜索条件，只能沿着页的双链表从左到右依次遍历各个页。</p>
<h3 id="索引的类别"><a href="#索引的类别" class="headerlink" title="索引的类别"></a>索引的类别</h3><p>聚簇索引与非聚簇索引</p>
<p>主键索引和辅助索引(常规所指的索引，也叫二级索引，又分为唯一索引和非唯一索引。)</p>
<p>InnoDB引擎中，主键索引会被选中作为聚集索引，而唯一索引和普通辅助索引间除了唯一性约束外，在存储上没本质区别。</p>
<h3 id="MySQL索引演化"><a href="#MySQL索引演化" class="headerlink" title="MySQL索引演化"></a>MySQL索引演化</h3><p>1.密集索引（Dense Index ）</p>
<p>根据减少无效数据访问的原则，我们将键的值拿过来存放到独立的块中。并且为每一个键值添加一个指针， 指向原来的数据块。</p>
<p>1.1折半块查找</p>
<p>需要对Dense进行索引，每个索引块内是有序的，另外，需要一个数组按顺序存储索引块地址，这样整体就有序了，数组也要存储到磁盘上，放在<code>单独的块链中</code>。折半查找的时间复杂度是O(log2(N))</p>
<p>2.稀疏索引（Sparse Index）</p>
<p>介绍基于块的折半查找时发现，读出每个块后只需要和第一行的键值匹配，就可以决定下一个块的位置（方向）。 因此有效数据是每个块的第一行数据，将每一个块的第一行的数据单独拿出来，和索引数组的地址放到一起。这样就可以直接在这个数组上进行折半查找了，这个数组就进化成了Sparse Index了。</p>
<p>3.多层稀疏索引</p>
<p>因为Sparse Index本身是有序的，所以可以为Sparse Index再建sparse Index。通过这个方法，一层一层的建立 Sparse Indexes,直到最上层的Sparse Index只占用一个块为止。</p>
<h3 id="索引组成简述"><a href="#索引组成简述" class="headerlink" title="索引组成简述"></a>索引组成简述</h3><p>   InnoDB数据页有7个部分组成，各个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5asGu0xrowZ97BFBFvrXsCs2ZSu49ZvFjk5fWLAflFSD2iadlbJkQicDQ/640" alt="avatar"><br>##索引执行步骤简述</p>
<p>一个页中的查找</p>
<p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件</li>
</ul>
<p>这个查找过程我们已经很熟悉了，可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<ul>
<li>以其他列作为搜索条件</li>
</ul>
<p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的<code>页目录</code>，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历<code>单链表</code>中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
<p>在很多页中查找</p>
<p>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上边已经唠叨过的查找方式去查找指定的记录。</p>
<p>一行的格式示意图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5dMTgZ8zvqoEax8dqq87xj59ywc2szJicaBsZkibTdnRx1icCtEYTDgRRQ/640" alt="avatar"><br>我们只在示意图里展示记录的这几个部分：</p>
<p><strong>record_type</strong>：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1我们还没用过，等会再说～</p>
<p><strong>next_type</strong>：记录头信息的一项属性，表示下一条地址的偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</p>
<p><strong>各个列的值</strong>：就是各个数据列的值，其中我们用橘黄色的格子代表c1列，深蓝色的格子代表c2列，红色格子代表c3列。</p>
<p><em>其他信息</em>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>概念:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt55ga3Fmqa9Hicn9CQ6Lh2ibT7chylHXd6C6RdrbmZdmFzZJiafyoyjyIjQ/640" alt="avatar"></p>
<p>实际用户记录其实都存放在B+树的最底层的节点上</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引(又叫<code>二级索引</code>)：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行</li>
</ul>
<p>我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<p>1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><p>页内的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p>
</li>
<li><p>各个存放用户记录的页也是根据页中记录的主键大小顺序排成一个<code>双向链表</code>。</p>
</li>
<li><p>各个存放目录项的页也是根据页中记录的主键大小顺序排成一个<code>双向链表</code>。</p>
</li>
</ul>
<p>2.B+树的叶子节点存储的是完整的用户记录。</p>
<p>  所谓完整的用户记录，就是指这个记录中存储了所有列的值。</p>
<p>我们把具有这两种特性的B+树称为聚簇索引</p>
<p>聚簇索引优点:</p>
<ul>
<li>聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。</li>
<li>聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的，</li>
</ul>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>除了除了聚簇索引之外的索引</p>
<p>二级索引这个B+树与聚簇索引有几处不同：</p>
<p>使用记录索引列的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><p>页内的记录是按照<code>索引列</code>的大小顺序排成一个单向链表。</p>
<ul>
<li>各个存放用户记录的页也是根据页中记录的<code>索引列</code>大小顺序排成一个双向链表。</li>
<li>各个存放目录项的页也是根据页中记录的<code>索引列</code>大小顺序排成一个双向链表。</li>
<li>B+树的叶子节点存储的并不是完整的<code>一页记录</code>，而只是<code>索引列</code>+<code>主键</code>这两个列的值。</li>
</ul>
</li>
<li><p>目录项记录中不再是主键+页号的搭配，而变成了<code>索引列</code>+<code>页号</code>的搭配。</p>
</li>
</ul>
<h3 id="二级索引查找过程"><a href="#二级索引查找过程" class="headerlink" title="二级索引查找过程"></a>二级索引查找过程</h3><p>查找过程如下：</p>
<ol>
<li>确定目录项记录页</li>
<li>通过目录项记录页确定用户记录真实所在的页。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
<li>但是这个B+树的叶子节点中的记录只存储了c2(索引列)和c1（也就是主键）两个列，所以我们必须再根据主键值<code>去聚簇索引中再查找一遍</code>完整的用户记录。 (<strong>回表</strong>)</li>
</ol>
<h4 id="为啥回表？"><a href="#为啥回表？" class="headerlink" title="为啥回表？"></a>为啥回表？</h4><p>你说的对，如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了呀</p>
<p>最下层是一个个的数据页，每个页上有很多条数据，上边页目录可以进行二分查找，下边有每个记录各个列的全部数据，如果存到非聚簇索引中，则太占空间，数据同步也是个问题。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><code>其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。</code></p>
<ul>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序<br><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5nXZJIREPnjDpcQ73cLseLFZLjF5bWTVHYp7TvME6jWVgI3zmhWoqhQ/640" alt="avatar"></li>
</ul>
<p>与分别为c2和c3列建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立联合索引只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>涉及二级索引，因为索引中有建立索引的值，查询条件正好是这些索引值得时候 就不用回表了，直接从二级索引中把索引值返回就好了，这种 叫做覆盖索引。</p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>MyISAM的索引方案虽然也使用B+树，但是却将索引和数据分开存储：</p>
<ul>
<li><p>将表中的记录按照插入时间顺序的存储在<code>一块存储空间</code>上，我们可以通过行号而快速访问到一条记录（因为index_demo表的记录是<code>定长</code>的，所以可以使用行号来进行快速访问，对于变长的记录MyISAM有不同的处理方案，我们这里就不介绍了），如图所示： (<strong><code>哈希索引？？？</code></strong>)<br><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55F3opxnpoB8oddtgyoia7Yt5L11Q62nngFGjI1ZkhsQWE0f4wMXjnwI9YY480d17lG1wgfZib2gSaaw/640" alt="avatar"></p>
</li>
<li><p>由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并<code>不能</code>在这些数据上使用二分法进行查找。</p>
</li>
<li><p>MyISAM会单独为表的主键创建一个<code>B+树</code>索引，只不过在B+树的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！</p>
</li>
<li><p>这一点和InnoDB是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找能找到对应的记录，而在MyISAM中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引全部都是<code>二级索引</code>！</p>
</li>
<li><p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引是一样的，只不过在叶子节点处存储的是相应的列 + 行号而已。这些索引也全部都是<code>二级索引</code>。</p>
</li>
</ul>
<h3 id="为啥索引建多了不好"><a href="#为啥索引建多了不好" class="headerlink" title="为啥索引建多了不好"></a>为啥索引建多了不好</h3><p>为啥不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会<code>建立一棵B+树</code>，每插入一条记录都要维护各个记录、数据页的排序关系，这是<code>很费性能</code>和<code>存储空间</code>的。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><a href="./%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(%E6%A0%91).md">基础内容链接 多叉平衡树</a></p>
<h4 id="为什么索引采用B-树呢？"><a href="#为什么索引采用B-树呢？" class="headerlink" title="为什么索引采用B+树呢？"></a>为什么索引采用B+树呢？</h4><p>和SQL的需求相关。<br>一个单行查询的SQL，例如passport，确实可以使用哈希索引。<br>但是对于排序查询的SQL需求：</p>
<ol>
<li>分组：group by</li>
<li>排序：order by</li>
<li>比较：&lt;、&gt;</li>
</ol>
<p>哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。</p>
<p>哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？</p>
<h3 id="为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引？"><a href="#为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引？" class="headerlink" title="为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引？"></a>为什么B-Tree适合数据库索引及红黑树的二叉平衡树不适合作为索引？</h3><h3 id="B-Tree比BTree做索引的优势？"><a href="#B-Tree比BTree做索引的优势？" class="headerlink" title="B+Tree比BTree做索引的优势？"></a>B+Tree比BTree做索引的优势？</h3><h3 id="为什么MongoDB采用B-Tree作为索引结构而MySQL采用B-Tree作为索引存储结构？"><a href="#为什么MongoDB采用B-Tree作为索引结构而MySQL采用B-Tree作为索引存储结构？" class="headerlink" title="为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构？"></a>为什么MongoDB采用B-Tree作为索引结构而MySQL采用B+Tree作为索引存储结构？</h3><h2 id="mysql中建立索引的一些原则"><a href="#mysql中建立索引的一些原则" class="headerlink" title="mysql中建立索引的一些原则"></a>mysql中建立索引的一些原则</h2><ul>
<li>先存数据，再建索引</li>
<li>不要对数据量小的数据表建立索引，数据量超过300的表应该有索引</li>
<li>对于规模小的数据表建立索引，不仅不会提高查询效率，相反使用索引查找可能比简单的全表扫描还要慢，而 且建索引还会占用一部分的存储空间</li>
<li>当对表的查询操作比更新操作频率更高时，对该表建立索引</li>
<li>在不同值较少的字段上不必要建立索引，如<code>性别</code>字段， <code>为啥？？？</code></li>
<li>对查询操作中使用频繁的字段建立索引</li>
<li>表的主键、外键必须有索引</li>
<li>经常出现在Where后面的字段，特别是大表的字段，应该建立索引</li>
<li>经常进行GROUP BY、ORDER BY的字段上建立索引</li>
<li>索引应该建在小字段上，对于<code>大的文本字段甚至超长字段，不要建索引</code> <code>坏处？？？</code></li>
</ul>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ul>
<li>多索引查询，区间长的放最左边，因为区间短的可能效率还不如全表扫描</li>
<li>or in ,unin 都能命中索引 建议使用 in </li>
<li>更新频繁的字段不宜使用索引，因为会更新二叉树</li>
<li>具有唯一特性的要建立唯一索引，及时是多个字段组合 并且影响Insert 性能，但索引的提升效率可见，并且增加了业务控制。</li>
<li>查询尽量不要使用*  减少回表。（有的查询可以直接从索引里取）</li>
<li>用explan 分析</li>
<li>内存碎片</li>
<li>调整数据页大小？（数据页默认16k,改8k查询效率好像快一点）</li>
</ul>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><ul>
<li>当like为’%abc’会失效</li>
<li>is null  is not null （索引是不索引空值的）</li>
<li>负向条件不会命中索引  （not，&lt;&gt;，!&#x3D;）</li>
<li>不包含索引的放最前边，会导致后边有索引的也不会命中索引</li>
<li>or 语句前后没有都使用索引</li>
<li>数据类型发生隐式转换 ，如没加单引号，char 转成int 会全表扫描</li>
<li>字段上使用函数，不走索引(emp(name,pp,sal))</li>
<li>当全表扫描比索引速度快时，索引失效</li>
<li>in 中参数条目超过阈值</li>
<li>字符类型索引 两张表 字符集不一致</li>
</ul>
<h2 id="字符集问题导致索引失效问题排查"><a href="#字符集问题导致索引失效问题排查" class="headerlink" title="字符集问题导致索引失效问题排查"></a>字符集问题导致索引失效问题排查</h2><p>问题描述<br>在 业务开发中  用户表的主键ID 为vachar(32), 业务表里都有响应的user_id列 定义为 vachar(32) 来存储用户ID；<br>然后某个需求是查询 某个业务线 操作的所有用户信息。  正常的流程是  select *from 用户表 where id in( select distinct user_id from 业务表 加条件)<br>发现没有走索引；<br>排查思路：</p>
<ol>
<li><p>id 为索引列 是否添加了索引；索引不合理</p>
</li>
<li><p>in 中的子查询是不是数据量过大 导致的 in 中索引失效</p>
</li>
<li><p>id 和 子查询中的字段是否类型不一致。</p>
</li>
<li><p>检查都添加了索引。 再用强制走索引语法验证，发现还是不走</p>
</li>
<li><p>查出来子查询74条，查看一下 阈值  ，阈值是200 超过阈值 会使索引退化</p>
</li>
<li><p>问题基本锁定在了隐式转换首先检查两个表中字段都是vachar(32)；<br>然后模拟两种情况，将子查询结果直接放到父查询in中执行，发现是走索引的<br>所以问题基本锁定在了隐式转换<br>猜测1：子查询中 distinct 是否会把userId 进行类型转换， 做测试 ，很简单测试发现不成立<br>2：由于参数是数字 ，猜测执行优化器在子查询查出结果自动进行了隐式转换； 这个用cast 操作排除</p>
<ol start="3">
<li>由于是vachar类型 ，猜测字符集问题导致， 验证：子查询结果强制转换字符集 ，测试结果走索引；<br>查看两个表中，用户表手动添加了字符集，另一个表用的默认的，这就导致没走索引，在此记录，用字符类型的索引一定要检查字符集，否则导致索引失效。</li>
</ol>
</li>
</ol>
<p>下一步怎么解决：</p>
<ol>
<li>数据备份</li>
<li>修改字符集</li>
<li>数据导入</li>
</ol>
<p>mysql 三层索引大概能存多少数据？？</p>
<p>每页大概 16k,  用bigint存 8k Mysql 是6k ,mysql 一个节点的大小设为一页或者页的倍数最为合适，16*1024&#x2F;14&#x3D; 1170   1170  * 1170  * 16&#x3D;2千万+</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247486241&idx=1&sn=b9110c9d5be352f115c0d8cf6a0a520e&chksm=9bd0a6b9aca72faff0fe2f1ea1c3f43d6716f882bde357a999fe0094aa4e1f880f46473d1b98&scene=27#wechat_redirect">MySQL的索引</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&mid=2247484932&idx=1&sn=6819e1a80541e0e869cf61120aadbef4&chksm=fcaedc18cbd9550e317f1d258e8128a7894bd024c38f9829515cac3424b7d9eceb8ff76b35d9&scene=27#wechat_redirect">理解索引</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/morethink/p/9251530.html">MongoDB 及 Mysql 背后的 B&#x2F;B+树</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0904(Mysql%E7%B4%A2%E5%BC%95)/" data-id="cld1buvun004dbjopeq7qasiu" data-title="每日一问0904(Mysql索引)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/每日一问0905(趣味题)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0905(%E8%B6%A3%E5%91%B3%E9%A2%98)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2019/">2019</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0905(%E8%B6%A3%E5%91%B3%E9%A2%98)/">每日一问0905(趣味题)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="趣味题"><a href="#趣味题" class="headerlink" title="趣味题"></a>趣味题</h1><h3 id="给你一个装满水的-8-升满壶和两个分别是-5-升、3-升的空壶，请想个优雅的办法，使得其中一个水壶恰好装-4-升水，每一步的操作只能是倒空或倒满。"><a href="#给你一个装满水的-8-升满壶和两个分别是-5-升、3-升的空壶，请想个优雅的办法，使得其中一个水壶恰好装-4-升水，每一步的操作只能是倒空或倒满。" class="headerlink" title="给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。"></a>给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2019/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0905(%E8%B6%A3%E5%91%B3%E9%A2%98)/" data-id="cld1buvuo004ebjop95vl8g8s" data-title="每日一问0905(趣味题)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/18/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>