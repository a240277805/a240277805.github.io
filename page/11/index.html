<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/11/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021/每日一问0728(es分页)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0728(es%E5%88%86%E9%A1%B5)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0728(es%E5%88%86%E9%A1%B5)/">每日一问0728(es分页)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="es-分页"><a href="#es-分页" class="headerlink" title="es 分页"></a>es 分页</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h1 id="Elasticsearch-三种分页方式"><a href="#Elasticsearch-三种分页方式" class="headerlink" title="Elasticsearch 三种分页方式"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jpfss/p/10815206.html">Elasticsearch 三种分页方式</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0728(es%E5%88%86%E9%A1%B5)/" data-id="cld1bs9ua003kfynh9gu9cyl1" data-title="每日一问0728(es分页)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0801(awk)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(awk)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(awk)/">每日一问0801(awk)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0801(awk)/" data-id="cld1bs9ub003lfynh4o1qhc0k" data-title="每日一问0801(awk)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0804(MDL锁)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(MDL%E9%94%81)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(MDL%E9%94%81)/">每日一问0804(MDL锁)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MDL-锁"><a href="#MDL-锁" class="headerlink" title="MDL 锁"></a>MDL 锁</h1><p> MYSQL中MDL锁一直是一个比较让人比较头疼的问题，我们谈起锁一般更加倾向于INNODB下层的gap lock、next key lock、row lock等，<br>因为它很好理解，也很好观察，而对于MDL LOCK却了解得很少，因为它实在不好观察，只有出现问题查看 <strong>show processlist</strong> 勉强可以看到<br>简单的所谓的 **Waiting for table metadata lock ** 之类的状态，其实MDL LOCK是MYSQL上层一个非常复杂的子系统，有自己的死锁检测机制<br>(<strong>无向图</strong>?)而大家一般口中的是不是 <strong>锁表了</strong> 其实就是指的它，可见的它的关键性和严重性，笔者也是根据自己的需求学习了一些(冰山一角)，<br>而没有能力阅读全部的代码，但是笔者通过增加一个TICKET的打印函数让语句的MDL LOCK加锁流程全部打印出来方便学习研究，下面从<br>一些基础说起然后告诉大家修改了哪些东西，最后对每种MDL TYPE进行测试和分析,如果大家对基本概念和增加打印函数不感兴趣可<br>直接参考第五部分加锁测试,但是如果不了解基础知识可能看起来有点困难。 </p>
<p>二 分类<br>  1 MDL读锁 MDL读锁是相互兼容的 SHARED_READ<br>  2 MDL 写锁 MDL写锁是互斥的 EXCLUSIVE</p>
<p>三 针对目标<br>  1 目标 MDL锁是针对语句级别的,并非事务本身,是mysql_server层面的锁<br>  2 目的 当事务本身执行的时候理论上是不能容忍表结构在中途发生改变的</p>
<p>五 经典的元数据锁问题<br>  问题 当我们执行DDL或者innobackup备份时,会出现waiting for table meta lock的问题,而且会导致后续session的等待,我们该如何处理呢<br>  分析 执行上述操作需要申请MDL锁,就证明有操作在把持着MDL锁没有释放,大概会有几种<br>  1 针对此表的慢查询操作(select),没有释放MDL锁<br>  2 针对此表的未提交事物,可能是由于程序原因导致的<br>  3 针对此表的 其他DDL操作<br>  4 执行 flush table with read lock,常见innobackup<br>  解决问题<br>  1 通过show processlist 观察是否有 slow query,DDL,FTWRL操作,如果有进行处理<br>  2 通过innodb_trx 观察是否有未提交事物,如果有进行处理<br>  3 对于mysql5.7版本 可以通过 performance_schema.metadata_lock 进行观察,关键字 SHARED_READ；</p>
<p>六 补充<br>  1 MDL锁等待时间也是通过lock_wait_timeout 设置的<br>  2 mysql5.7对MDL锁的相关特性进行了优化<br>  3 读写事物语句,都是先申请 MDL_EXCLUSIVE,再降级成 READ WRITE锁,所以我上面没有标 注<br> 4 由于队列设计,所以一旦出现MDL锁,一定要及时进行处理</p>
<h3 id="MDL锁的性能与并发改进"><a href="#MDL锁的性能与并发改进" class="headerlink" title="MDL锁的性能与并发改进"></a>MDL锁的性能与并发改进</h3><p>讲到这同学们会发现MDL锁的开销并不比InnoDB层的行锁要小，而且这可能是一个更为密集的并发瓶颈。MySQL 5.6和5.5版本通常通过调整如下两个参数来进行并发调优:</p>
<ul>
<li>metadata_locks_cache_size: MDL锁的缓存大小</li>
<li>metadata_locks_hash_instances：通过分片来提高并发度，与InnoDB AHI类似</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.innomysql.com/article/25689.html">MySQL 5.7</a> MDL锁的最大改进之处在于将MDL锁的机制通过lock free算法来实现，从而提高了在多核并发下数据库的整体性能提升。</p>
<h3 id="MDL锁的诊断"><a href="#MDL锁的诊断" class="headerlink" title="MDL锁的诊断"></a>MDL锁的诊断</h3><p>MySQL 5.7版本之前并没有提供一个方便的途径来查看MDL锁，<a target="_blank" rel="noopener" href="https://github.com/">github</a>上有一名为mysql-plugin-mdl-info的项目，通过插件的方式来查看，非常有想法的实现，大赞。好在官方也意识到了这个问题，于是在MySQL 5.7中的performance_schea库下新增了一张表metadata_locks，用其来查看MDL锁那是相当的方便:</p>
<p>不过默认PS并没有打开此功能，需要手工将wait&#x2F;lock&#x2F;metadata&#x2F;sql&#x2F;mdl监控给打开:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM performance_schema.setup_instruments;</span><br><span class="line"></span><br><span class="line">  UPDATE performance_schema.setup_consumers SET ENABLED = &#x27;YES&#x27; WHERE NAME =&#x27;global_instrumentation&#x27;;</span><br><span class="line">  UPDATE performance_schema.setup_instruments SET ENABLED = &#x27;YES&#x27; WHERE NAME =&#x27;wait/lock/metadata/sql/mdl&#x27;;</span><br><span class="line">  select * from performance_schema.metadata_locks\G</span><br></pre></td></tr></table></figure>

<p>##参考</p>
<p><a target="_blank" rel="noopener" href="http://blog.itpub.net/7728585/viewspace-2143093/">MYSQL METADATA LOCK(MDL LOCK)学习(1) 理论知识和加锁类型测试</a></p>
<h1 id="社区投稿-MySQL：FTWRL一个奇怪的堵塞现象和其堵塞总结"><a href="#社区投稿-MySQL：FTWRL一个奇怪的堵塞现象和其堵塞总结" class="headerlink" title="***** 社区投稿 | MySQL：FTWRL一个奇怪的堵塞现象和其堵塞总结"></a>***** <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020468179">社区投稿 | MySQL：FTWRL一个奇怪的堵塞现象和其堵塞总结</a></h1><h1 id="深入理解MYSQL的MDL元数据锁"><a href="#深入理解MYSQL的MDL元数据锁" class="headerlink" title="深入理解MYSQL的MDL元数据锁"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zengkefu/p/5690385.html">深入理解MYSQL的MDL元数据锁</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(MDL%E9%94%81)/" data-id="cld1bs9uc003mfynh6y8od7o7" data-title="每日一问0804(MDL锁)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0804(mysql主从)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(mysql%E4%B8%BB%E4%BB%8E)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(mysql%E4%B8%BB%E4%BB%8E)/">每日一问0804(mysql主从)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mysql-主从"><a href="#mysql-主从" class="headerlink" title="mysql 主从"></a>mysql 主从</h1><h2 id="一个事务日志同步的完整过程"><a href="#一个事务日志同步的完整过程" class="headerlink" title="一个事务日志同步的完整过程"></a>一个事务日志同步的完整过程</h2><p>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</p>
<p>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</p>
<p>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</p>
<p>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</p>
<p>sql_thread读取中转日志，解析出日志里的命令，并执行。</p>
<h3 id="mysql-binlog-三种格式-binlog-format"><a href="#mysql-binlog-三种格式-binlog-format" class="headerlink" title="mysql binlog 三种格式(binlog_format)"></a>mysql binlog 三种格式(binlog_format)</h3><ul>
<li><p>statement(<strong>SBR</strong>) :SQL语句的原文，同步有风险，比如 delete limit ，不一致的情况,或者使用索引不一致</p>
</li>
<li><p>row(<strong>RBR</strong>)：row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。</p>
<p>Table_map event，用于说明接下来要操作的表是test库的表t;</p>
<p>Delete_rows event，用于定义删除的行为。</p>
<p>需要借助<strong>mysqlbinlog</strong>工具，解析和查看binlog中的内容</p>
</li>
<li><p>mixed(<strong>MBR</strong>): MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。<br>MIXED说明:<br> 对于执行的SQL语句中包含now()这样的时间函数，会在日志中产生对应的unix_timestamp()*1000的时间字符串</p>
</li>
</ul>
<p>SBR 的优点：</p>
<p>历史悠久，技术成熟<br>binlog文件较小<br>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况<br>binlog可以用于实时的还原，而不仅仅用于复制<br>主从版本可以不一样，从服务器版本可以比主服务器版本高</p>
<p>SBR 的缺点：</p>
<p>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。<br>调用具有不确定因素的 UDF 时复制也可能出问题<br>使用以下函数的语句也无法被复制：</p>
<ul>
<li>LOAD_FILE()</li>
<li>UUID()</li>
<li>USER()</li>
<li>FOUND_ROWS()</li>
<li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)<br>INSERT … SELECT 会产生比 RBR 更多的行级锁<br>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁<br>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句<br>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响<br>存储函数(不是存储过程)在被调用的同时也会执行一次 NOW() 函数，这个可以说是坏事也可能是好事<br>确定了的 UDF 也需要在从服务器上执行<br>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错<br>执行复杂语句如果出错的话，会消耗更多资源</li>
</ul>
<p>RBR 的优点：</p>
<p>任何情况都可以被复制，这对复制来说是最安全可靠的<br>和其他大多数数据库系统的复制技术一样<br>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多<br>复制以下几种语句时的行锁更少：</p>
<ul>
<li>INSERT … SELECT</li>
<li>包含 AUTO_INCREMENT 字段的 INSERT</li>
<li>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句<br>执行 INSERT，UPDATE，DELETE 语句时锁更少<br>从服务器上采用多线程来执行复制成为可能</li>
</ul>
<p>RBR 的缺点：</p>
<p>binlog 大了很多<br>复杂的回滚时 binlog 中会包含大量的数据<br>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题<br>UDF 产生的大 BLOB 值会导致复制变慢<br>无法从 binlog 中看到都复制了写什么语句<br>当在非事务表上执行一段堆积的SQL语句时，最好采用 SBR 模式，否则很容易导致主从服务器的数据不一致情况发生</p>
<p>另外，针对系统库 mysql 里面的表发生变化时的处理规则如下：<br>如果是采用 INSERT，UPDATE，DELETE 直接操作表的情况，则日志格式根据 binlog_format 的设定而记录<br>如果是采用 GRANT，REVOKE，SET PASSWORD 等管理语句来做的话，那么无论如何都采用 SBR 模式记录<br>注：采用 RBR 模式后，能解决很多原先出现的主键重复问题。</p>
<h2 id="双-M-结构-如果节点-A-同时是节点-B-的备库，相当于又把节点-B-新生成的-binlog-拿过来执行了一次，然后节点-A-和-B-间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？"><a href="#双-M-结构-如果节点-A-同时是节点-B-的备库，相当于又把节点-B-新生成的-binlog-拿过来执行了一次，然后节点-A-和-B-间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？" class="headerlink" title="(双 M 结构)如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？"></a>(双 M 结构)如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</h2><p>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="深入解析Mysql-主从同步延迟原理及解决方案"><a href="#深入解析Mysql-主从同步延迟原理及解决方案" class="headerlink" title="深入解析Mysql 主从同步延迟原理及解决方案"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengff/p/11011702.html">深入解析Mysql 主从同步延迟原理及解决方案</a></h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xyw145195/article/details/109438190">mysql主从复制及binlog格式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/125615.htm">mysql中binlog_format模式与配置详细分析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0804(mysql%E4%B8%BB%E4%BB%8E)/" data-id="cld1bs9uc003nfynhbvyw9ixe" data-title="每日一问0804(mysql主从)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问0827(kafka监控运维)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0827(kafka%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0827(kafka%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4)/">每日一问0827(kafka监控运维)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="kafka-监控运维平台-调研"><a href="#kafka-监控运维平台-调研" class="headerlink" title="kafka 监控运维平台 调研"></a>kafka 监控运维平台 调研</h1><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>kafka-Eagle</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0827(kafka%E7%9B%91%E6%8E%A7%E8%BF%90%E7%BB%B4)/" data-id="cld1bs9uc003ofynhcbsj9asd" data-title="每日一问0827(kafka监控运维)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1101(垃圾回收)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/">每日一问1101(垃圾回收)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="带有垃圾回收的语言"><a href="#带有垃圾回收的语言" class="headerlink" title="带有垃圾回收的语言"></a>带有垃圾回收的语言</h2><ul>
<li><p>Lisp</p>
</li>
<li><p>Java</p>
</li>
<li><p>Ruby</p>
</li>
<li><p>Python</p>
</li>
<li><p>Perl</p>
</li>
<li><p>Haskell</p>
</li>
<li><p>go</p>
</li>
</ul>
<h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>我们将对象中保存对象本身信息的部分称为“头”。</p>
<p>我们把对象使用者在对象中可访问的部分称为“域”。</p>
<p>指针</p>
<p>mutator</p>
<p>分配（allocation）指的是在内存空间中分配对象。</p>
<p>堆指的是用于动态（也就是执行程序时）存放对象的内存空间。</p>
<h2 id="评价GC算法的性能时，我们采用以下4个标准。"><a href="#评价GC算法的性能时，我们采用以下4个标准。" class="headerlink" title="评价GC算法的性能时，我们采用以下4个标准。"></a>评价GC算法的性能时，我们采用以下4个标准。</h2><ul>
<li>吞吐量（在单位时间内的处理能力）</li>
<li>最大暂停时间 （“因执行GC而暂停执行mutator的最长时间）</li>
<li>堆使用效率</li>
<li>访问的局部性</li>
</ul>
<p><img src="/../../ImgSource/image-20211102174303616.png" alt="image-20211102174303616"></p>
<h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>（如何分配内存）第2行的pickup_chunk()函数用于遍历$free_list，寻找大于等于size的分块。它不光会返回和size大小相同的分块，还会返回比size大的分块。如果它找到和size大小相同的分块，则会直接返回该分块；如果它找到比size大的分块，则会将其分割成size大小的分块和去掉size后剩余大小的分块，并把剩余的分块返回&#x3D;&#x3D;空闲链表&#x3D;&#x3D;。如果此函数没有找到合适的分块，则会返回NULL。返回NULL时分配是不会进行的。为了处理这种情况，我们在代码清单2.5中调用了之前在1.6节提到的allocation_fail()函数。</p>
<ul>
<li>first-fit  选择最先</li>
<li>best-fit 选择最佳</li>
<li>Worst-fit 选择最差</li>
</ul>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>碎片化</li>
<li>与标记-压缩，复制算法不兼容</li>
<li>分配速度慢 》由于分块是不连续的，因此每次分配都要遍历整个空闲链表，找到足够大的内存块，最糟的情况就是每次进行分配都得把空闲链表遍历到最后。</li>
<li>与&#x3D;&#x3D;写时复制技术&#x3D;&#x3D;不兼容</li>
</ol>
<h3 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h3><p>查找三个大小的分块只需遍历一次</p>
<p><img src="/../../ImgSource/image-20211115095756139.png" alt="image-20211115095756139"></p>
<p>要多少个空闲链表合适呢？我们通常会给分块大小设定一个上限，分块如果大于等于这个大小，就全部采用一个空闲链表处理。</p>
<h3 id="BI-BOP-法"><a href="#BI-BOP-法" class="headerlink" title="BI-BOP 法"></a>BI-BOP 法</h3><p>把堆分割成固定大小的块，让每个块只能配置同样大小的对象。这就是BiBOP法。</p>
<h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><p>对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。像这样集合了用于标记的位的表格称为“位图表格”（bitmap table），利用这个表格进行标记的行为称为“位图标记”。位图表格的实现方法有多种，例如散列表和树形结构等。</p>
<h2 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h2><p>可以减少暂停时间     </p>
<p>因为延迟清除法不是一下遍历整个堆，它只在分配时执行必要的遍历，所以可以压缩因清除操作而导致的mutator的暂停时间。这就是“延迟”清除操作的意思。         </p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>优点：</p>
<ul>
<li>可即刻回收垃圾</li>
<li>最大暂停时间短</li>
</ul>
<p>缺点：</p>
<ul>
<li>计数器值的增减处理繁重</li>
<li>计数器需要占用很多位</li>
<li>实现烦琐复杂</li>
</ul>
<h2 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h2><p>优点： 在延迟引用计数法中，程序延迟了根引用的计数，将垃圾一并回收。通过延迟，减轻了因根引用频繁发生变化而导致的计数器增减所带来的额外负担。</p>
<p> 缺点： 为了延迟计数器值的增减，垃圾不能马上得到回收，这样一来垃圾就会压迫堆，我们也就失去了引用计数法的一大优点——可即刻回收垃圾。 </p>
<p>要搜索的对象就越多，妨碍mutator运作的时间也就越长。</p>
<h2 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h2><p>然而事实上有很多研究表明，很多对象一生成马上就死了（详情请参考第7章）。也就是说，在很多情况下，计数器的值会在0到1的范围内变化，鲜少出现5位计数器溢出这样的情况。</p>
<p>对于计数器溢出的对象，我们可以这样处理：不再增减计数器的值，就把它放着，什么也不做。用其他算法回收</p>
<h2 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h2><p>回收不了 ，引用溢出，和循环引用的对象</p>
<h2 id="部分标记-清除算法"><a href="#部分标记-清除算法" class="headerlink" title="部分标记-清除算法"></a>部分标记-清除算法</h2><p>​	只回收循环引用对象，</p>
<p>部分标记-清除算法的优点，就是把要搜索的对象限定在阴影对象及其子对象，也就是“可能是循环垃圾的对象群”中</p>
<p>1．黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）</p>
<p>2．白（WHITE）：绝对是垃圾的对象</p>
<p>3．灰（GRAY）：搜索完毕的对象</p>
<p>4．阴影（HATCH）：可能是循环垃圾的对象</p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>优点：</p>
<ul>
<li>因为GC复制算法只搜索并复制活动对象，所以跟一般的GC标记-清除算法相比，它能在较短时间内完成GC。也就是说，其吞吐量优秀。尤其是堆越大，差距越明显。</li>
<li>可实现高速分配：GC复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。</li>
<li>不会发生碎片化</li>
<li>与缓存兼容</li>
</ul>
<p>缺点： </p>
<ul>
<li>堆使用效率低下</li>
<li>不兼容保守式GC算法 因为会移动对象</li>
<li>递归调用函数  因为在每次递归调用时都会消耗栈，所以还有栈溢出的可能。</li>
</ul>
<h3 id="Cheney的GC复制算法"><a href="#Cheney的GC复制算法" class="headerlink" title="Cheney的GC复制算法"></a>Cheney的GC复制算法</h3><p>Fenichel和Yochelson的GC复制算法采用的是深度优先搜索，而Cheney的复制算法采用的则是广度优先搜索。</p>
<p>优点： </p>
<p>Fenichel和Yochelson的GC复制算法是递归算法，而Cheney的GC复制算法是迭代算法，因此它可以抑制调用函数的额外负担和栈的消耗。特别是拿堆用作队列，省去了用于搜索的内存空间这一点，实在是令人赞叹。</p>
<p>缺点：</p>
<p>没法沾缓存的光 因此我们没法说Cheney的GC复制算法兼容缓存，只能说它比GC标记-清除算法和引用计数法要好一些而已。</p>
<h4 id="近似深度优先算法"><a href="#近似深度优先算法" class="headerlink" title="近似深度优先算法"></a>近似深度优先算法</h4><p>这是因为此算法采用的不是完整的广度优先搜索，而是在每个页面上分别进行广度优先搜索。这里利用了我们在4.5.1节中提到的广度优先搜索的性质，即在搜索一开始把有引用关系的对象安排在同一个页面中。</p>
<p><img src="/../../ImgSource/image-20211115142356100.png" alt="image-20211115142356100"></p>
<p>![image-20211115142257041](..&#x2F;..&#x2F;ImgSource&#x2F;image-20211115142257041.png                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>
<p><img src="/../../ImgSource/image-20211115142334139.png" alt="image-20211115142334139"></p>
<h4 id="多空间复制算法"><a href="#多空间复制算法" class="headerlink" title="多空间复制算法"></a>多空间复制算法</h4><p>我们不把堆分成2份，而是分成10份，其中需要拿出2块空间分别作为From空间和To空间来执行GC复制算法。反正无论如何都要空出1块空间来当To空间，那我们就把这个额外负担降到整体的1&#x2F;10就行了。</p>
<p>多空间复制算法说白了就是把堆N等分，对其中2块空间执行GC复制算法，对剩下的（N-2）块空间执行GC标记-清除算法，也就是把这2种算法组合起来使用。</p>
<p>首先在第2行调查参数obj是否在From空间里。如果在From空间里，那么它就是GC复制算法的对象。这时就通过copy()函数复制obj，返回新空间的地址。如果obj不在From空间里，它就是GC标记-清除算法的对象。这时要设置标志位，对其子对象递归调用mark_or_copy()函数。最后不要忘了返回obj。</p>
<p>优点：</p>
<p>多空间复制算法没有将堆二等分，而是分割成了更多块空间，从而更有效地利用了堆。以往的GC复制算法只能使用半个堆，而多空间复制算法仅仅需要空出一个分块，不能使用的只有1&#x2F;N个堆。</p>
<p>缺点：</p>
<p>执行GC复制算法的只有N等分中的两块空间，对于剩下的（N-2）块空间执行的是GC标记-清除算法。因此就出现了GC标记-清除算法固有的问题——分配耗费时间、分块碎片化等。</p>
<h2 id="GC标记-压缩算法"><a href="#GC标记-压缩算法" class="headerlink" title="GC标记-压缩算法"></a>GC标记-压缩算法</h2><p>不过它跟GC复制算法不同，不用牺牲半个堆。</p>
<p>压缩阶段由以下3个步骤构成。</p>
<p>1．设定forwarding指针</p>
<p>2．更新指针</p>
<p>3．移动对象</p>
<p>优点：</p>
<ul>
<li>GC标记-压缩算法和其他算法相比而言，堆利用效率高。</li>
<li>GC标记-压缩算法不会出现GC复制算法那样只能利用半个堆的情况。GC标记-压缩算法可以在整个堆中安排对象，堆使用效率几乎是GC复制算法的2倍。用“几乎”这个词，是因为要留出用于forwarding指针的空间，所以严格来说不到2倍。</li>
</ul>
<p>缺点： </p>
<p>压缩花费计算成本 </p>
<p>在本节介绍的Lisp2算法的压缩中，必须对整个堆进行3次搜索。也就是说，执行该算法所花费的时间是和堆大小成正比的。GC标记-压缩算法的吞吐量要劣于其他算法。</p>
<h4 id="Two-Finger算法"><a href="#Two-Finger算法" class="headerlink" title="Two-Finger算法"></a>Two-Finger算法</h4><p>优点： 压缩所带来的搜索次数只有2次，比Lisp2算法少1次，在吞吐量方面占优势。</p>
<p>缺点：我们基本上也无法期待这个算法能沾缓存的光。</p>
<p>此外该算法还有一个限制条件，那就是所有对象的大小必须一致。</p>
<h4 id="表格算法"><a href="#表格算法" class="headerlink" title="表格算法"></a>表格算法</h4><p>优点： 这是因为在表格算法中，可以通过缓存来提高对象的访问速度。</p>
<h4 id="ImmixGC算法"><a href="#ImmixGC算法" class="headerlink" title="ImmixGC算法"></a>ImmixGC算法</h4><p>这个算法虽然以GC标记-清除算法为基础，不过根据情况也会执行压缩。</p>
<p>这个算法不是以对象为单位，而是以线为单位回收垃圾的。</p>
<h2 id="种类指的是“保守式GC”和“准确式GC”"><a href="#种类指的是“保守式GC”和“准确式GC”" class="headerlink" title="种类指的是“保守式GC”和“准确式GC”"></a>种类指的是“保守式GC”和“准确式GC”</h2><h4 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h4><p>不能识别指针和非指针的GC</p>
<p>在采用GC标记-清除算法的情况下，一找到貌似指针的非指针，程序就会将非指针指向的对象错误地识别为活动对象，对其进行标记。因为被错误识别的对象不会被废弃而会被保留，所以遵守了GC的原则——“不废弃活动对象”。像这样，在运行GC时采取的是一种保守的态度，即“把可疑的东西看作指针，稳妥处理”，所以我们称这种方法为“保守式GC”。	</p>
<p>不明确时候怎么回收？当基于不明确的根运行GC时，我们就要从对象的头部获取对象的类型信息。</p>
<p>缺点：</p>
<ul>
<li>识别指针和非指针需要付出成本</li>
<li>错误识别指针会压迫堆</li>
<li>能够使用的GC算法有限</li>
</ul>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p>在对象中导入了“年龄”的概念，通过优先回收容易成为垃圾的对象，提高垃圾回收的效率。</p>
<p>大部分的对象在生成后马上就变成了垃圾，很少有对象能活得很久。在对象中导入了“年龄”的概念，经历过一次GC后活下来的对象年龄为1岁。</p>
<p>我们将对新对象执行的GC称为新生代GC（minor GC）</p>
<p>分代垃圾回收不是跟GC标记-清除算法和GC复制算法并列在一起供我们选择的算法，而是需要跟这些基本算法一并使用。</p>
<h3 id="Ungar的分代垃圾回收"><a href="#Ungar的分代垃圾回收" class="headerlink" title="Ungar的分代垃圾回收"></a>Ungar的分代垃圾回收</h3><p>我们总共需要利用4个空间，分别是生成空间、2个大小相等的幸存空间以及老年代空间，并分别用$new_start、$survivor1_start、$survivor2_start、$old_start这4个变量引用它们的开头。</p>
<p>此外我们准备出一个和堆不同的数组，称为记录集（remembered set），设为$rs。</p>
<p><img src="/../../ImgSource/image-20211115153449169.png" alt="image-20211115153449169"></p>
<h4 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h4><p>在记录集里不会记录引用的目标对象，而是记录发出引用的对象。</p>
<p><img src="/../../ImgSource/image-20211115154148157.png" alt="image-20211115154148157"></p>
<h4 id="写入屏障（write-barrier）"><a href="#写入屏障（write-barrier）" class="headerlink" title="写入屏障（write barrier）"></a>写入屏障（write barrier）</h4><p>老年代GC中利用了GC标记-清除算法</p>
<h3 id="新生代GC"><a href="#新生代GC" class="headerlink" title="新生代GC"></a>新生代GC</h3><p><img src="/../../ImgSource/image-20211115154908723.png" alt="image-20211115154908723"></p>
<p>注意： 幸存空间满了怎么办？</p>
<p>&#x3D;&#x3D;当发生这种情况时，稳妥起见只能把老年代空间作为复制的目标空间。当然，如果频繁发生这种情况，分代垃圾回收的优点就会淡化。&#x3D;&#x3D;</p>
<p>优点：</p>
<ul>
<li>通过使用分代垃圾回收，可以改善GC所花费的时间（吞吐量）。正如Ungar所说的那样：“据实验表明，分代垃圾回收花费的时间是GC复制算法的1&#x2F;4。”可见分代垃圾回收的导入非常明显地改善了吞吐量。</li>
<li>分代垃圾回收来缩减mutator最大暂停时间</li>
</ul>
<p>缺点：</p>
<ul>
<li>在部分程序中会起到反作用</li>
<li>写入屏障导致的额外负担降低了吞吐量。</li>
</ul>
<h4 id="卡片标记"><a href="#卡片标记" class="headerlink" title="卡片标记"></a>卡片标记</h4><h4 id="页面标记"><a href="#页面标记" class="headerlink" title="页面标记"></a>页面标记</h4><h2 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h2><p>分代数量越多，对象变成垃圾的机会也就越大，所以这个方法确实能减少活到最老代的对象。但是我们也不能过度增加分代数量。分代数量越多，每代的空间也就相应地变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。</p>
<h2 id="列车垃圾回收"><a href="#列车垃圾回收" class="headerlink" title="列车垃圾回收"></a>列车垃圾回收</h2><p>列车垃圾回收中将老年代空间按照一定大小划分，每个划分出来的空间称为车厢，由1个以上的车厢连接成的东西就叫作列车。这就是列车垃圾回收名字的由来。1次老年代GC是以1个车厢作为GC对象的。</p>
<p>每个列车和每个车厢都按其产生的顺序被赋予了编号，互相连接。车厢就是以这个顺序作为GC对象的。</p>
<p>新生代GC ：第10行的obj_to_car()函数会返回参数obj所属的车厢，get_last_car()则会返回参数car所属列车的&#x3D;&#x3D;最后一节车厢&#x3D;&#x3D;。</p>
<p>老年代GC：</p>
<p><img src="/../../ImgSource/image-20211115161508835.png" alt="image-20211115161508835"></p>
<p> &#x3D;&#x3D;从第一节车厢开始，老年代GC是以开头列车的开头车厢作为GC对象的。第一节车厢，剩下的对象会被copy 到最后一节车厢，如果to_car装不下这些对象，那么我们就新连接一节空车厢。&#x3D;&#x3D;</p>
<p>列车垃圾回收之所以能回收跨多个块（在这里也就是车厢）的大型垃圾，是因为列车垃圾回收会把互相引用的对象安排在同一辆列车上。</p>
<p>不过对于比车厢大的对象，需要将其安排到新生代空间和老年代空间以外的堆，使用跟列车垃圾回收不同的方法来执行GC。</p>
<p><img src="/../../ImgSource/image-20211115160905022.png" alt="image-20211115160905022"></p>
<p>注意：记录集的溢出</p>
<p>本来记录集满了就意味着此车厢里挤满了受欢迎（也就是被引用数非常大）的对象。这样的对象很难成为垃圾，每次执行GC都需要对其进行复制操作。为了省去花费在这项复制操作上的时间，我们有个办法，那就是索性把车厢C排除到GC对象的范围之外去。这看上去像是白白浪费了一个车厢，不过考虑到车厢C中大多数对象都会在执行GC后存活下来，所以一开始就不对其执行GC可能要更为划算些。</p>
<h2 id="增量式垃圾回收（Incremental-GC）"><a href="#增量式垃圾回收（Incremental-GC）" class="headerlink" title="增量式垃圾回收（Incremental GC）"></a>增量式垃圾回收（Incremental GC）</h2><p><img src="/../../ImgSource/image-20211115161630235.png" alt="image-20211115161630235"></p>
<p>三色标记法</p>
<p>· 白色：还未搜索过的对象</p>
<p>· 灰色：正在搜索的对象</p>
<p>· 黑色：搜索完成的对象</p>
<p>增量式垃圾回收不是一口气运行GC，而是和mutator交替运行的，因此不会长时间妨碍到mutator的运行。增量式垃圾回收适合那些比起提高吞吐量，更重视缩短最大暂停时间的应用程序。</p>
<h2 id="RC-Immix算法"><a href="#RC-Immix算法" class="headerlink" title="RC Immix算法"></a>RC Immix算法</h2><h4 id="合并性引用计数法"><a href="#合并性引用计数法" class="headerlink" title="合并性引用计数法"></a>合并性引用计数法</h4><p>于是人们开发出了一种方法，就是把注意力放在某一时期最初和最后的状态上，在该期间内不进行计数器的增减。这就是合并型引用计数法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1101(%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)/" data-id="cld1bs9ud003pfynhcg2nho4l" data-title="每日一问1101(垃圾回收)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1102(go学习)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/">每日一问1102(go学习)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="go-学习"><a href="#go-学习" class="headerlink" title="go 学习"></a>go 学习</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>学习目的</p>
</li>
<li><p>可以做什么</p>
</li>
<li><p>特性 </p>
<p>协程</p>
<p>语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高）</p>
</li>
<li><p>适用于哪些场景</p>
</li>
</ol>
<p> 它适合做网络编程，服务器编程，分布式系统，数据库系统，云平台，等。</p>
<ol>
<li>学习方法</li>
</ol>
<p>《A Tour of Go（Go语言之旅）》 (最新官方英文：<a href="https://link.zhihu.com/?target=https://tour.golang.org/">https://tour.golang.org/</a>，第三方中文翻译：<a href="https://link.zhihu.com/?target=https://tour.go-zh.org/">https://tour.go-zh.org/</a>) </p>
<p>《Effective Go（实效Go编程）》 (最新官方英文：<a href="https://link.zhihu.com/?target=https://golang.org/doc/effective_go">https://golang.org/doc/effective_go</a>，第三方中文翻译：<a href="https://link.zhihu.com/?target=https://go-zh.org/doc/effective_go.html">https://go-zh.org/doc/effective_go.html</a>)</p>
<ol>
<li>框架</li>
<li>高级</li>
<li>周边</li>
<li>就业方向</li>
<li>学到什么程度</li>
<li>问题</li>
</ol>
<p>  用 go 是不是会造成学习多门 都不精的情况？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1102(go%E5%AD%A6%E4%B9%A0)/" data-id="cld1bs9ud003qfynh6e0yaq9b" data-title="每日一问1102(go学习)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1107(linux)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/">每日一问1107(linux)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="服务器对比"><a href="#服务器对比" class="headerlink" title="服务器对比"></a>服务器对比</h2><table>
<thead>
<tr>
<th></th>
<th>Ubuntu</th>
<th>CentOS</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>CentOS（Community Enterprise Operating System，社区企业操作系统</td>
</tr>
<tr>
<td></td>
<td></td>
<td>相比Ubuntu, CentOS拥有更高的稳定性，但是用户界面相对欠缺。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>systemctl是一个系统管理守护进程、工具和库的集合，用于取代System V、service和chkconfig命令，初始进程主要负责控制systemd系统和服务管理器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1107(linux)/" data-id="cld1bs9ue003rfynh75i7dag7" data-title="每日一问1107(linux)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1108(云原生)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/">每日一问1108(云原生)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><p>随着物联网设备的大爆发，必然会产生大量的数据，以及随之而来的数据处理和数据安全等需求，而这些已经无法通过传统云计算的集中式处理方式来满足（比如带宽、实时性、隐私以及能耗等），于是就产生了边缘计算。边缘计算的核心目的就是拉近云端和物联网终端的距离，降低网络延迟，提供新的服务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1108(%E4%BA%91%E5%8E%9F%E7%94%9F)/" data-id="cld1bs9ue003sfynh6cq2eycg" data-title="每日一问1108(云原生)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021/每日一问1111(Quakus)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:11:12.360Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2021/">2021</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/">每日一问1111(Quakus)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Quakus"><a href="#Quakus" class="headerlink" title="Quakus"></a>Quakus</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE1111(Quakus)/" data-id="cld1bs9uf003tfynhhaxq6q3w" data-title="每日一问1111(Quakus)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/12/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2022/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0922(%E6%9E%B6%E6%9E%84)/">每日一问0922(架构)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2022/%E8%BF%B0%E8%81%8C%E6%A8%A1%E6%9D%BF/">述职模板</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E7%A7%AF%E7%B4%AF/">英文单词积累</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%9C%B0%E5%9D%80/">好玩的地址</a>
          </li>
        
          <li>
            <a href="/2023/01/18/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%90%8E%E6%9C%9F/">摄影后期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>