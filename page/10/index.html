<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://a240277805.github.io/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://a240277805.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-音乐/少年锦时" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/%E9%9F%B3%E4%B9%90/%E5%B0%91%E5%B9%B4%E9%94%A6%E6%97%B6/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/%E9%9F%B3%E4%B9%90/%E5%B0%91%E5%B9%B4%E9%94%A6%E6%97%B6/">少年锦时</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="少年锦时"><a href="#少年锦时" class="headerlink" title="少年锦时"></a>少年锦时</h1><h2 id="乐谱"><a href="#乐谱" class="headerlink" title="乐谱"></a>乐谱</h2><p><img src="/../../ImgSource/cvxphaflhcg.jpg" alt="少年锦时(四字歌谱)1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/%E9%9F%B3%E4%B9%90/%E5%B0%91%E5%B9%B4%E9%94%A6%E6%97%B6/" data-id="cld1buvv8005dbjopae5r6yyo" data-title="少年锦时" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-音乐/音乐框架" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/%E9%9F%B3%E4%B9%90/%E9%9F%B3%E4%B9%90%E6%A1%86%E6%9E%B6/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.738Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/%E9%9F%B3%E4%B9%90/%E9%9F%B3%E4%B9%90%E6%A1%86%E6%9E%B6/">音乐框架</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="曲目"><a href="#曲目" class="headerlink" title="曲目"></a>曲目</h1><h2 id="乐谱"><a href="#乐谱" class="headerlink" title="乐谱"></a>乐谱</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/%E9%9F%B3%E4%B9%90/%E9%9F%B3%E4%B9%90%E6%A1%86%E6%9E%B6/" data-id="cld1buvv9005ebjopfavjeemn" data-title="音乐框架" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0324(集合)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0324(%E9%9B%86%E5%90%88)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0324(%E9%9B%86%E5%90%88)/">每日一问0324(集合)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h4 id="arrayList-和-linkList-区别"><a href="#arrayList-和-linkList-区别" class="headerlink" title="*****.arrayList 和 linkList 区别"></a>*****.arrayList 和 linkList 区别</h4><p>都不是线程安全</p>
<p>1）arrayList 是数组存储,linkList 是双向链表每个元素有头和尾所以占内存要比arr要大一些。</p>
<p>2）arr 存储是在一定长的容器，超过临界点需要扩容， 扩容方式 是将所有元素复制到更大的内存空间，比较麻烦，<br>link则不需要维护容器长度。</p>
<p>3）arryList 查找快 N（1），支持快速随机访问，linkList 需要依次遍历前边元素，找到最终目标</p>
<p>4）插入删除 arr 插入删除（中间部分）需要将后边的元素全部移动，link则不需要</p>
<p>5）遍历 arrayList for循环 快速随机访问 最快；linkList 迭代器最快，但不要用for循环进行快速随机访问非常耗时，forEach 两者都差不多。</p>
<p>vector 所有方法是同步的，但一个线程访问的话需要耗费大量时间，</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-数据结构"><a href="#HashMap-数据结构" class="headerlink" title="HashMap 数据结构"></a>HashMap 数据结构</h3><ul>
<li>java8 以前: 数组+链表</li>
<li>java8:<code>数组+链表+红黑二叉树</code></li>
</ul>
<p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫<code>碰撞</code>，这样会在table[i]上形成一个链表。<code>数组中存储的是链表最后插入的元素（在前面进行插入）</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg: 用的一致性hash算法: key进行hash算法 对数组长度求余，得到当前要存的数组下标。</span><br></pre></td></tr></table></figure>
<h3 id="解决hash冲突"><a href="#解决hash冲突" class="headerlink" title="解决hash冲突"></a>解决hash冲突</h3><p>  拉链法解决冲突，数组每一格是一个链表，有冲突就加入到链表中；</p>
<p>  <code>jdk 1.8</code>之后将链表改为红黑树，默认规定最大长度为8，减少搜索速度</p>
<h3 id="jdk-1-8之前-HashMap在多线程下会发生死循环-怎么产生的？"><a href="#jdk-1-8之前-HashMap在多线程下会发生死循环-怎么产生的？" class="headerlink" title="jdk 1.8之前 HashMap在多线程下会发生死循环 ,怎么产生的？"></a>jdk 1.8之前 HashMap在多线程下会发生死循环 ,怎么产生的？</h3><p>jdk1.7的transfer是用头插法，新的链表和原来的是倒着的，所以这时候假如有两个线程，第一个线程只执行到Entry next &#x3D; e.next;然后就第二个线程执行了，等到第二个线程执行完，其实这时候已经完成了扩容的任务，且链表里的顺序 已经倒置了，这时候第一个线程继续执行，这时候就把尾巴又指向头了，然后就造成了环。</p>
<h3 id="死循环怎么解决的？"><a href="#死循环怎么解决的？" class="headerlink" title="死循环怎么解决的？"></a>死循环怎么解决的？</h3><p>尾插法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">do &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">        if (loTail == null)</span><br><span class="line">            loHead = e;</span><br><span class="line">        else</span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (hiTail == null)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        else</span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while ((e = next) != null);</span><br><span class="line">if (loTail != null) &#123;</span><br><span class="line">    loTail.next = null;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line">if (hiTail != null) &#123;</span><br><span class="line">    hiTail.next = null;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是声明两对指针，维护两个链表，依次在末端添加新的元素。</p>
<h4 id="hashMap-和hashTable"><a href="#hashMap-和hashTable" class="headerlink" title="hashMap 和hashTable"></a>hashMap 和hashTable</h4><p>map 线程不安全，快，可用 currentHashMap 代替线程安全</p>
<p>table 慢，线程安全</p>
<p>hashSet 是由hashMap 实现的</p>
<h4 id="多线程环境不建议使用-hashMap-有可能导致死循环和数据丢失，推荐使用ConcurrentHashMap"><a href="#多线程环境不建议使用-hashMap-有可能导致死循环和数据丢失，推荐使用ConcurrentHashMap" class="headerlink" title="多线程环境不建议使用 hashMap 有可能导致死循环和数据丢失，推荐使用ConcurrentHashMap"></a>多线程环境不建议使用 hashMap 有可能导致死循环和数据丢失，推荐使用ConcurrentHashMap</h4><h3 id="ConcurrentHashMap-put过程"><a href="#ConcurrentHashMap-put过程" class="headerlink" title="** ConcurrentHashMap put过程"></a>** ConcurrentHashMap put过程</h3><p>假设table已经初始化完成，put操作采用&#x3D;&#x3D;CAS+synchronized&#x3D;&#x3D;实现并发插入或更新操作：</p>
<ul>
<li>当前bucket为空时，使用CAS操作，将Node放入对应的bucket中。</li>
<li>出现hash冲突，则采用synchronized关键字。倘若当前hash对应的节点是链表的头节点，遍历链表，若找到对应的node节点，则修改node节点的val，否则在链表末尾添加node节点；倘若当前节点是红黑树的根节点，在树结构上遍历元素，更新或增加节点。</li>
<li>倘若当前map正在扩容f.hash &#x3D;&#x3D; MOVED， 则跟其他线程一起进行扩容</li>
</ul>
<h3 id="ConcurrentHashMap-1-7到1-8-改进"><a href="#ConcurrentHashMap-1-7到1-8-改进" class="headerlink" title="** ConcurrentHashMap 1.7到1.8 改进"></a>** ConcurrentHashMap 1.7到1.8 改进</h3><p>改进一：取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt;[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</p>
<p>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能</p>
<p>改进三： 另外，在其他方面也有一些小的改进，比如新增字段 transient volatile CounterCell[] counterCells; 可方便的计算hashmap中所有元素的个数，性能大大优于jdk1.7中的size()方法。</p>
<h3 id="ConcurrentHashMap和HashTable-区别"><a href="#ConcurrentHashMap和HashTable-区别" class="headerlink" title="****ConcurrentHashMap和HashTable 区别"></a>****ConcurrentHashMap和HashTable 区别</h3><p>都是线程安全，</p>
<ul>
<li>C 1.8之前 是 分段锁 按一定结构进行分割加锁（Segment 􏴢􏲇􏴆􏳺􏰮 +HashEntry，Segment 实现了 ReentrantLock是可重入锁 ），不加锁的部分可以正常访问读写，</li>
<li>1.8之后是Node 数组+链表+红黑树 ，写入在链表表头加锁，并发控制使用synchronized和CAS</li>
<li>HashTable一把大锁，效率低下</li>
</ul>
<h3 id="HashMap-写入实现"><a href="#HashMap-写入实现" class="headerlink" title="**HashMap 写入实现"></a>**HashMap 写入实现</h3><ul>
<li>首先判断key是否为null ，为null 则 putforNull</li>
<li>否则计算  通过 hash ,取模等等 ，得到hash值</li>
<li>通过hash值 找到索引位置，如果数组该位置有元素，则比较是否存在相同的key,若存在则覆盖原来的，不存在则写入链表放在链头(最先保存的放在链尾)，若该位置没有元素，直接保存。</li>
</ul>
<h4 id="HashMap到一定长度会自动扩容-，系统必须要在某个临界点进行扩容，"><a href="#HashMap到一定长度会自动扩容-，系统必须要在某个临界点进行扩容，" class="headerlink" title="HashMap到一定长度会自动扩容 ，系统必须要在某个临界点进行扩容，"></a>HashMap到一定长度会自动扩容 ，系统必须要在某个临界点进行扩容，</h4><h4 id="HashMap-存储-key-和value-是一起存的，根据key-的hash-决定存放位置。"><a href="#HashMap-存储-key-和value-是一起存的，根据key-的hash-决定存放位置。" class="headerlink" title="HashMap 存储 key 和value 是一起存的，根据key 的hash 决定存放位置。"></a>HashMap 存储 key 和value 是一起存的，根据key 的hash 决定存放位置。</h4><h4 id="解决hash冲突的办法-扩展"><a href="#解决hash冲突的办法-扩展" class="headerlink" title="解决hash冲突的办法(扩展)"></a>解决hash冲突的办法(扩展)</h4><ul>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立一个公共溢出区</li>
</ul>
<p>Java中hashmap的解决办法就是采用的<code>链地址法</code></p>
<h3 id="comparable-和-Comparator-区别？"><a href="#comparable-和-Comparator-区别？" class="headerlink" title="comparable 和 Comparator 区别？"></a>comparable 和 Comparator 区别？</h3><h3 id="hash-Map-扩容-最大阈值"><a href="#hash-Map-扩容-最大阈值" class="headerlink" title="hash Map 扩容 最大阈值"></a>hash Map 扩容 最大阈值</h3><p>###hashMap 链表变成 红黑二叉树 的最小阈值。</p>
<h3 id="treeMap-linkhashMap-hashMap-比较"><a href="#treeMap-linkhashMap-hashMap-比较" class="headerlink" title="treeMap linkhashMap hashMap 比较"></a>treeMap linkhashMap hashMap 比较</h3><p>哈希映射可用作提供快速存储和检索操作的通用映射实现。然而，它不足是由于条目的混乱和不规则安排。</p>
<p>这导致它在存在大量迭代的情况下表现不佳，因为底层数组的整个容量影响遍历而不仅仅是条目数。</p>
<p>链接的哈希映射拥有哈希映射的良好属性并为条目添加顺序。它在有大量迭代的情况下表现更好，因为无论容量如何，只考虑条目数。</p>
<p>通过提供对键应如何排序的完全控制，树映射将排序提升到下一级别。另一方面，它提供了比其他两种替代方案更差的一般性能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><code>*****</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/programmer_at/article/details/79715177">ConcurrentHashMap 介绍最全文章</a></li>
<li><code>*****</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/82377980">JDK 1.7及之前——HashMap死循环问题解析</a></li>
<li><code>***</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/biggoodloong/article/details/88596183?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7">分析多线程下jdk1.8之前hashmap的put方法造成死循环而jdk1.8之后如何解决这个死循环</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0324(%E9%9B%86%E5%90%88)/" data-id="cld1buvrs0000bjop24zu6xyl" data-title="每日一问0324(集合)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0325(JVM)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0325(JVM)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0325(JVM)/">每日一问0325(JVM)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="介绍下-Java-内存区域运行时数据区）"><a href="#介绍下-Java-内存区域运行时数据区）" class="headerlink" title="介绍下 Java 内存区域	运行时数据区）"></a>介绍下 Java 内存区域	运行时数据区）</h3><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。这些组成部分一些是线程私有的，其他的则是线程共享的。<br><img src="https://img-blog.csdnimg.cn/20190129145342903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZfbG92ZTY2Ng==,size_16,color_FFFFFF,t_70" alt="avatar"><br>线程私有的：</p>
<ul>
<li>程序计数器</li>
<li>本地方法栈</li>
<li>虚拟机栈</li>
</ul>
<p>线程共享的：</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p> 执行分支，循环，跳转，异常处理，线程恢复，线程切换后能恢复到正确的执行位置；程序计数器是不会内存溢出的。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p> 生命周期和线程相同 ，描述的事Java 的方法执行的内存模型,Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p>
<p> Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p>
<ul>
<li>StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li>OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p> 所有线程共享； 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p>
<p> Eden-s1-s2 (新生代) oldGeneration （老年代） perm (永久代)</p>
<p> JDK1.8 已经去除 永久代 而用 元空间代替，元空间存储在物理内存，受到本机物理内存限制</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>  共享 </p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p> NIO 流  堆外内存， 避免 Java堆和NATIVE堆 复制数据。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p> 1） 类加载检查</p>
<p> 2）内存分配 两种方式 ：</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p> 3）初始化零值 java代码中就可以不赋值直接使用</p>
<p> 4）设置对象头</p>
<ol start="5">
<li>执行 init 方法  执行前只是虚拟机新的对象产生了 ，执行完 Java代码才认</li>
</ol>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p> 对象头，实例数据和对齐填充</p>
<p> 对象头 有两部分数据:</p>
<ul>
<li>哈希码、GC分代年龄、锁状态标志等等</li>
<li>类型指针，即对象指向它的类元数据的指针</li>
</ul>
<p> 实例数据是 对象真正存储的有效信息</p>
<p> 对齐填充非必然存在。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p> 两种方式 </p>
<ul>
<li>使用句柄</li>
<li>直接指针</li>
</ul>
<p> 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h2 id="String-类和常量池"><a href="#String-类和常量池" class="headerlink" title="String 类和常量池"></a>String 类和常量池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcd&quot;;</span><br><span class="line">String str2 = new String(&quot;abcd&quot;);</span><br><span class="line">System.out.println(str1==str2);//false</span><br></pre></td></tr></table></figure>
<p> 这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。</p>
<p> String 类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  String s1 = new String(&quot;计算机&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = &quot;计算机&quot;;</span><br><span class="line">System.out.println(s2);//计算机</span><br><span class="line">System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span><br><span class="line">System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 3 String 字符串拼接</p>
<pre><code>       String str1 = &quot;str&quot;;
       String str2 = &quot;ing&quot;;
       String str3 = &quot;str&quot; + &quot;ing&quot;;//常量池中的对象
       String str4 = str1 + str2; //在堆上创建的新的对象	  
       String str5 = &quot;string&quot;;//常量池中的对象
       System.out.println(str3 == str4);//false
       System.out.println(str3 == str5);//true
       System.out.println(str4 == str5);//false
</code></pre>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<h1 id="全局字符串池（string-pool也有叫做string-literal-pool）"><a href="#全局字符串池（string-pool也有叫做string-literal-pool）" class="headerlink" title="全局字符串池（string pool也有叫做string literal pool）"></a>全局字符串池（string pool也有叫做string literal pool）</h1><p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。</p>
<h4 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h4><ul>
<li>Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值<code>[-128，127]</code>的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</li>
<li>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = 33;</span><br><span class="line">Integer i2 = 33;</span><br><span class="line">System.out.println(i1 == i2);// 输出true</span><br><span class="line">Integer i11 = 333;</span><br><span class="line">Integer i22 = 333;</span><br><span class="line">System.out.println(i11 == i22);// 输出false</span><br><span class="line">Double i3 = 1.2;</span><br><span class="line">Double i4 = 1.2;</span><br><span class="line">System.out.println(i3 == i4);// 输出false</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Minor-GC-和-Full-GC-有什么不同"><a href="#Minor-GC-和-Full-GC-有什么不同" class="headerlink" title="Minor GC 和 Full GC  有什么不同"></a>Minor GC 和 Full GC  有什么不同</h3><ul>
<li>新生代 GC （Minor GC ） 新生代垃圾回收非常频繁，回收速度快</li>
<li>老年代GC (Major GC &#x2F;Full GC)  会比 Minor GC慢 10倍以上</li>
</ul>
<h3 id="如何判断一个对象死亡"><a href="#如何判断一个对象死亡" class="headerlink" title="如何判断一个对象死亡"></a>如何判断一个对象死亡</h3><ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ol>
<li>Serial 收集器：</li>
</ol>
<ul>
<li>最老的收集器； </li>
<li>单线程 ， </li>
<li>回收时工作线程都要停顿</li>
<li>对于 Client模式下虚拟机是不错选择。</li>
</ul>
<ol start="2">
<li>ParNew 收集器</li>
</ol>
<ul>
<li>就是Serial 收集器的 多线程版本，控制参数,收集算法，回收策略和一样。</li>
<li>许多运行在 Server 模式下虚拟机首要选择。只有它能与CMS收集器配合工作</li>
</ul>
<ol start="3">
<li>ParaLLel Scavenge 收集器</li>
</ol>
<ul>
<li>关注点是吞吐量</li>
<li>提供了很多参数供用户找到最合适的停顿时间 或最大吞吐量。</li>
</ul>
<p>4.CMS􏶴􏽂􏰨收集器</p>
<ul>
<li>获取最短回收停顿时间为目标的收集器，非常适合注重用户体验的应用上使用。</li>
<li>实现了让垃圾收集线程和用户线程同时工作。</li>
<li>无法处理浮动垃圾</li>
<li>使用回收算法 “标记-清除”算法 会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<p>CMS垃圾回收期回收过程：</p>
<ul>
<li><p>初始标记（CMS initial mark）</p>
</li>
<li><p>并发标记（CMS concurrent mark）</p>
</li>
<li><p>重新标记（CMS remark）</p>
</li>
<li><p>并发清除（CMS concurrent sweep）</p>
</li>
</ul>
<ol>
<li><p>其中，&#x3D;&#x3D;初始标记、重新标记&#x3D;&#x3D;这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
</li>
<li><p>CMS默认启动的回收线程数是（CPU数量+3）&#x2F; 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
</li>
<li><p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数&#x3D;&#x3D;-XX:CMSInitiatingOccupancyFraction&#x3D;&#x3D;的值来提高触发百分比，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数&#x3D;&#x3D;-XX:CM SInitiatingOccupancyFraction&#x3D;&#x3D;设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。</p>
</li>
<li><p>G1 收集器</p>
</li>
</ol>
<h3 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h3><p>网上一个很形象的例子描述对象在JVM堆内存中的生命周期：</p>
<p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“To”区，自从去了Survivor区，我就开始漂泊了，因为Survivor的两个区总是交换名字，所以我总是搬家，搬到To Survivor居住，搬来搬去，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。</p>
<p><a target="_blank" rel="noopener" href="http://www.liuzk.com/294.html">一次JVM_OLD区占用过高、频繁Full GC的解决过程</a></p>
<h3 id="JVM-调优工具（java-tools）"><a href="#JVM-调优工具（java-tools）" class="headerlink" title="JVM 调优工具（java-tools）"></a>JVM 调优工具（java-tools）</h3><ul>
<li>jps 虚拟机进程状况工具</li>
<li>jstat 虚拟机统计信息监视工具</li>
<li>jmap 还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件</li>
<li>jstack 用户生成java 虚拟机当前时刻线程快照</li>
<li>jinfo用户实时查看和调整虚拟机运行参数</li>
<li>VisualVM 多合一故障管理工具，图形化界面，直接在命令行打入 jvisualvm</li>
</ul>
<h3 id="JVM-中的锁"><a href="#JVM-中的锁" class="headerlink" title="JVM 中的锁"></a>JVM 中的锁</h3><ul>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>自旋锁</li>
</ul>
<h4 id="内置于JVM中的获取锁的优化方法和获取锁的步骤"><a href="#内置于JVM中的获取锁的优化方法和获取锁的步骤" class="headerlink" title="内置于JVM中的获取锁的优化方法和获取锁的步骤"></a>内置于JVM中的获取锁的优化方法和获取锁的步骤</h4><ul>
<li>当A线程获取对象，先会cas 设置偏向锁</li>
<li>如果成功，会在<code>对象头</code>和栈帧的锁记录里记录线程A的ID</li>
<li>如果这时有B来竞争对象，发现对象有偏向锁，则B 标记对象不适合偏向锁，然后触发轻量级锁（即：把对象头中的MarkWord 复制到自己线程的锁记录中）</li>
<li>偏向锁可用会先尝试偏向锁</li>
<li>如果获取失败，尝试自旋来</li>
<li>轻量级锁可用会先尝试轻量级锁</li>
<li>以上都失败，尝试自旋锁</li>
<li>再失败，尝试普通锁，使用OS互斥量在操作系统层挂起</li>
</ul>
<h3 id="JVM参数调优"><a href="#JVM参数调优" class="headerlink" title="JVM参数调优"></a>JVM参数调优</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a target="_blank" rel="noopener" href="https://xiaochengxinyizhan.blog.csdn.net/article/details/92385172">Java代码的执行篇</a><br> <a target="_blank" rel="noopener" href="https://github.com/Homiss/Java-interview-questions/blob/master/JVM/JVM%E9%9D%A2%E8%AF%95%E9%A2%98.md">JVM面试题</a><br><a target="_blank" rel="noopener" href="http://www.liuzk.com/294.html">一次JVM_OLD区占用过高、频繁Full GC的解决过程</a></p>
<h1 id="字符串常量池和运行时常量池是在堆还是在方法区？"><a href="#字符串常量池和运行时常量池是在堆还是在方法区？" class="headerlink" title="字符串常量池和运行时常量池是在堆还是在方法区？"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cosmos-wong/p/12925299.html">字符串常量池和运行时常量池是在堆还是在方法区？</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45112292/article/details/118732695?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242">class文常量池、运行时常量池、字符串常量池的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/P8s3kuceBNovUP5adXpFCQ">线上服务的FGC问题排查，看这篇就够了！</a></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>8e426fdc9f06283135745f7def3811ac6a2aa3f7</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0325(JVM)/" data-id="cld1buvry0001bjopca6naozc" data-title="每日一问0325(JVM)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0330(多线程)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0330(%E5%A4%9A%E7%BA%BF%E7%A8%8B)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0330(%E5%A4%9A%E7%BA%BF%E7%A8%8B)/">每日一问0330(多线程)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul>
<li>Thread</li>
<li>runnable</li>
<li>callable 和 Feature</li>
</ul>
<p>前两种都存在以下问题</p>
<ul>
<li>无法获取子线程的返回值</li>
<li>run方法不可以抛出异常</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>在任意时间点，一个线程只有一种状态<br>* 新建(New)：创建后尚未启动<br>* 运行(Runable)：正在执行或正在等待CPU为它分配执行时间<br>* 等待(Waiting)：<br>* 无限等待(Waiting)：线程不会被分配CPU执行时间，等待被其他线程显式地唤醒。<br>* 期限等待(Timed Waiting)：线程不会被分配CPU执行时间，无须等待被其他线程显式地唤醒，在一定时间后它们会由系统自动唤醒。<br>* 阻塞(Blocked)：被阻塞<br>* 阻塞和等待的区别：<code>阻塞状态</code>在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而<code>等待状态</code>则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
<p>t.interrupted（）的精确含义是“唤醒轻量级阻塞”，而不是字面意思“中断一个线程”。</p>
<p>synchronized关键字其实是“给某个对象加了把锁”，</p>
<p><img src="/../../ImgSource/image-20220211111707313.png" alt="image-20220211111707313"></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>可见性  （任何进程在读取的时候，都会清空本进程里面持有的共享变量的值，强制从主存里面获取；<br>任何进程在写入完毕的时候，都会强制将共享变量的值写会主存。）</li>
<li>指令重排 （增加内存屏障）</li>
</ul>
<h3 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h3><p>如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。<br>两者的区别</p>
<ul>
<li>方法签名不同，void Runnable.run(), V Callable.call() throws Exception</li>
<li>是否允许有返回值，Callable允许有返回值（回调）</li>
<li>是否允许抛出异常，Callable允许抛出异常。</li>
</ul>
<h3 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="headerlink" title="sleep 和wait 区别"></a>sleep 和wait 区别</h3><ul>
<li>sleep 没有释放锁 ，wait释放锁</li>
<li>wait 用于线程间通讯 ,sleep 用于暂停执行</li>
<li>wait 调用后线程不会自动苏醒，需要notify ,sleep 执行完成后线程会自动苏醒。</li>
</ul>
<h3 id="Thread-和-Runnable-区别"><a href="#Thread-和-Runnable-区别" class="headerlink" title="Thread 和 Runnable 区别"></a>Thread 和 Runnable 区别</h3><p>实际上 Thread 类和 Runnable 接口之间在使用上也是有区别的，如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享。</p>
<h3 id="为什么我们调用start-会执行run-而不能直接调用run"><a href="#为什么我们调用start-会执行run-而不能直接调用run" class="headerlink" title="为什么我们调用start() 会执行run() ,而不能直接调用run()"></a>为什么我们调用start() 会执行run() ,而不能直接调用run()</h3><p> 调用start() 会执行线程的相应的准备工作，然后其中的线程自动执行run();而直接调用run() 会把她当成main()下的普通方法，并不是多线程工作。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程私有</p>
<p>每个THread 中都具备一个ThreadLocalMap ，而 ThreadLocalMap可以存储以ThreadLocal为Key的键值对。</p>
<h4 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h4><p>􏰛􏱾􏱿使用的 key 为 􏰺 ThreadLocal 的弱引用􏼏􏱿,而􏲻 value是强引用。所以如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而value 不会被清理掉。这样一来,ThreadLocalMap 中出现了key 为null 的Entry。加入没有任何措施的话，value 永远不会被GC回收，这个时候会产生内存泄露。<br>最好使用完ThreadLocal后手动调用remove()方法。</p>
<h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>方法名	功能<br>newFixedThreadPool(int nThreads)	创建固定大小的线程池<br>newSingleThreadExecutor()	创建只有一个线程的线程池<br>newCachedThreadPool()	创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</p>
<p>阿里开发手册中强制线程池不允许使用 Executors去创建,而是通过 ThreadPoolExecutor 的方式，避免资源耗尽的风险。<br>Executors线程池对象弊端如下：</p>
<ul>
<li>FixedThreadPool 和SingleThreadPool 允许队列的长度为Integer.Max_value ，可能堆积大量的请求，导致OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool 允许创建的线程数量为 Integer.Max_value 可能创建大量线程 ，导致OOM 。</li>
</ul>
<h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><h3 id="ThreadPoolExecutor-重要参数"><a href="#ThreadPoolExecutor-重要参数" class="headerlink" title="ThreadPoolExecutor 重要参数"></a>ThreadPoolExecutor 重要参数</h3><ul>
<li>corePoolSize :核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue: 达到最大线程数，会放到队列中</li>
</ul>
<p>常见参数：</p>
<ul>
<li><p>keepAliveTime: 大于核心线程数 又没有新任务 等待时间，线程空闲了多久会被回收</p>
</li>
<li><p>unit：等待时间单位</p>
</li>
<li><p>threadFactory </p>
</li>
<li><p>handler: 饱和策略</p>
</li>
</ul>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ul>
<li>AbortPolicy： 抛异常</li>
<li>CallerRUnsPolicy: 调用执行自己的线程运行任务,会降低新任务提交速度，影响性能，适合不能丢任务的请求。</li>
<li>DiscardPolicy： 不处理新任务</li>
<li>DiscardOldestPolicy: 丢弃最早的未处理的任务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line"> executor</span><br><span class="line"> </span><br><span class="line"> class runner&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> executor.execute(runner)</span><br><span class="line"> executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心参数设置"><a href="#核心参数设置" class="headerlink" title="核心参数设置"></a>核心参数设置</h2><h3 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h3><p>CPU密集型：核心线程数 &#x3D; CPU核数 + 1 (计算比较多)(这里核心线程数不是等于CPU核心数，是因为考虑CPU密集型任务由于某些原因而暂停，此时有额外的线程能确保CPU这个时刻不会浪费。但同时也会增加一个CPU上下文切换，因此核心线程数是等于CPU核心数？还是CPU核心数+1？可以根据实际情况来确定)</p>
<p>IO密集型：核心线程数 &#x3D; CPU核数 * 2  （硬盘内存 读写 操作比较多）</p>
<p>注：IO密集型（某大厂实践经验）<br>       核心线程数 &#x3D; CPU核数 &#x2F; （1-阻塞系数）     例如阻塞系数 0.8，CPU核数为4<br>       则核心线程数为20</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>AQS的实现依赖内部的同步队列,也就是FIFO的双向队列，如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p>
<h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>sync是一个静态内部类，它继承了AQS这个抽象类，前面说过AQS是一个同步工具，主要用来实现同步控制。我们在利用这个工具的时候，会继承它来实现同步控制功能。<br>通过进一步分析，发现Sync这个类有两个具体的实现，分别是NofairSync(非公平锁),FailSync(公平锁).</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><h3 id="年，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。"><a href="#年，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。" class="headerlink" title="年，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。"></a>年，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要逻辑是</p>
<ul>
<li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li>
<li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</li>
<li>acquireQueued，将Node作为参数，通过自旋去尝试获取锁。</li>
</ul>
<h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁：</p>
<p>公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。<br>锁的实现方式是基于如下几点：<br>表结点Node和状态state的volatile关</p>
<p>键字。<br>sum.misc.Unsafe.compareAndSet的原子操作(见附录)。</p>
<p>非公平锁：</p>
<p>在等待锁的过程中， 如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock锁都不会使得线程中断，除非开发者自己设置了中断位。</span><br><span class="line">ReentrantLock获取锁里面有看似自旋的代码，但是它不是自旋锁。</span><br><span class="line">ReentrantLock公平与非公平锁都是属于排它锁。</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CarpenterLee/p/9558026.html">Java线程池详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44777693/article/details/95246059">java线程池如何合理配置核心线程数？</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017372067">深入分析AQS实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/little-fly/p/10365109.html">Java中的公平锁和非公平锁实现详解</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0330(%E5%A4%9A%E7%BA%BF%E7%A8%8B)/" data-id="cld1buvs00002bjopfj1z73q1" data-title="每日一问0330(多线程)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0331(synchronized)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0331(synchronized)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0331(synchronized)/">每日一问0331(synchronized)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h3 id="谈谈-synchronized和ReenTrantLock-的区别"><a href="#谈谈-synchronized和ReenTrantLock-的区别" class="headerlink" title="谈谈 synchronized和ReenTrantLock 的区别"></a>谈谈 synchronized和ReenTrantLock 的区别</h3><ol>
<li>都是可重入锁</li>
</ol>
<p>2）synchronized 依赖于JVM ;ReenTrantLock 依赖于 API</p>
<p>3）ReenTrantLock 比sy 增加了一些高级功能</p>
<ul>
<li>中断等待锁的线程机制</li>
<li>可以指定是公平锁还是非公平锁</li>
</ul>
<p>说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。<br>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><img src="http://ifeve.com/wp-content/uploads/2012/10/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="avator"></p>
<p><img src="http://ifeve.com/wp-content/uploads/2012/10/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="avator"></p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_worldee/article/details/77823062">Java多线程–syncornized原理与应用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0331(synchronized)/" data-id="cld1buvs10003bjopdar31uym" data-title="每日一问0331(synchronized)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0407(消息队列)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0407(%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0407(%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)/">每日一问0407(消息队列)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>削峰填谷</li>
<li>业务解耦</li>
</ul>
<h3 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h3><ul>
<li>系统复杂性 重复消费</li>
<li>数据一致性</li>
</ul>
<h3 id="关于消息队列其他一些常见的问题展望"><a href="#关于消息队列其他一些常见的问题展望" class="headerlink" title="关于消息队列其他一些常见的问题展望"></a>关于消息队列其他一些常见的问题展望</h3><ol>
<li>引入消息队列之后如何保证高可用性</li>
<li>如何保证消息不被重复消费呢？</li>
<li>如何保证消息的可靠性传输（如何处理消息丢失的问题）？</li>
<li>我该怎么保证从消息队列里拿到的数据按顺序执行？</li>
<li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li>
<li>如果让你来开发一个消息队列中间件，你会怎么设计架构？</li>
<li>消息队列选型</li>
</ol>
<h3 id="如何保证消息队列的高可用啊？"><a href="#如何保证消息队列的高可用啊？" class="headerlink" title="如何保证消息队列的高可用啊？"></a>如何保证消息队列的高可用啊？</h3><h4 id="RabbitMQ的高可用性"><a href="#RabbitMQ的高可用性" class="headerlink" title="RabbitMQ的高可用性"></a>RabbitMQ的高可用性</h4><ul>
<li>镜像集群模式  在一个节点上创建 queue 也会在其他节点上同步一份数据。<br>保证高可用，缺点： 没有扩展性</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0407(%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)/" data-id="cld1buvs20004bjop35w66dob" data-title="每日一问0407(消息队列)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0414(kafka)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0414(kafka)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0414(kafka)/">每日一问0414(kafka)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: wurstmeister/zookeeper:latest</span><br><span class="line">    hostname: zookeeper</span><br><span class="line">    container_name: zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2181:2181&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ZOOKEEPER_CLIENT_PORT: 2181</span><br><span class="line">      ZOOKEEPER_TICK_TIME: 2000</span><br><span class="line">    #定义挂载点         </span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">  kafka:</span><br><span class="line">    image: wurstmeister/kafka:2.11-0.11.0.3</span><br><span class="line">    hostname: kafka</span><br><span class="line">    container_name: kafka</span><br><span class="line">    depends_on:</span><br><span class="line">      - zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_BROKER_ID: 1</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: &#x27;zookeeper:2181&#x27;</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: &quot;172.20.60.23&quot;</span><br><span class="line">      KAFKA_ADVERTISED_PORT: &quot;9092&quot;</span><br><span class="line">    #定义挂载点         </span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//创建topic</span><br><span class="line">bin/kafka-topics.sh --create --zookeeper 172.20.60.23:2181 --replication-factor 1 --partitions 1 --topic mykafka</span><br><span class="line"></span><br><span class="line">//查看topic</span><br><span class="line">bin/kafka-topics.sh --list --zookeeper 172.20.60.23:2181</span><br><span class="line"></span><br><span class="line">//创建生产者</span><br><span class="line">bin/kafka-console-producer.sh --broker-list 172.20.60.23:9092 --topic mykafka </span><br><span class="line"></span><br><span class="line">//创建消费者</span><br><span class="line">kafka-console-consumer.sh --bootstrap-server 172.20.60.23:9092 --topic DEVOPS_PLATFORM_EVENT_TOPIC --from-beginning</span><br><span class="line">//查看topic 分区</span><br><span class="line">kafka-topics.sh --describe --bootstrap-server 127.0.0.1:9094  --topic count</span><br><span class="line">//topic 分区增加到4个</span><br><span class="line">kafka-topics.sh --bootstrap-server 127.0.0.1:9094 --alter --topic count --partitions 4</span><br><span class="line">//topic 每个分区最新offset</span><br><span class="line">kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9094 --topic count</span><br><span class="line">//查看消费者组</span><br><span class="line">kafka-consumer-groups.sh  --bootstrap-server 127.0.0.1:9094  --list</span><br><span class="line">//查看消费者组里的消费者和消费信息</span><br><span class="line">kafka-consumer-groups.sh  --bootstrap-server 127.0.0.1:9094 --describe  --group zmk-group</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="confluent-kafka-安装"><a href="#confluent-kafka-安装" class="headerlink" title="confluent kafka 安装"></a>confluent kafka 安装</h3><p>有问题 待修复</p>
<p>部署参考   Quick Start for Apache Kafka using Confluent Platform (Docker)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Zookeeper and expose port 2181 <span class="keyword">for</span> use by the host machine</span></span><br><span class="line">docker run -d --name zookeeper -p 2181:2181 confluent/zookeeper</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Kafka and expose port 9092 <span class="keyword">for</span> use by the host machine</span></span><br><span class="line">docker run -d --name kafka -p 9092:9092 --link zookeeper:zookeeper confluent/kafka</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Schema Registry and expose port 8081 <span class="keyword">for</span> use by the host machine</span></span><br><span class="line">docker run -d --name schema-registry -p 8081:8081 --link zookeeper:zookeeper \</span><br><span class="line">    --link kafka:kafka confluent/schema-registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start REST Proxy and expose port 8082 <span class="keyword">for</span> use by the host machine</span></span><br><span class="line">docker run -d --name rest-proxy -p 8082:8082 --link zookeeper:zookeeper \</span><br><span class="line">    --link kafka:kafka --link schema-registry:schema-registry confluent/rest-proxy</span><br></pre></td></tr></table></figure>





<h2 id="Spring-kafka-配置"><a href="#Spring-kafka-配置" class="headerlink" title="Spring-kafka 配置"></a>Spring-kafka 配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################consumer的配置参数（开始）#################</span></span><br><span class="line"><span class="comment">#如果&#x27;enable.auto.commit&#x27;为true，则消费者偏移自动提交给Kafka的频率（以毫秒为单位），默认值为5000。</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-commit-interval;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#当Kafka中没有初始偏移量或者服务器上不再存在当前偏移量时该怎么办，默认值为latest，表示自动将偏移重置为最新的偏移量</span></span><br><span class="line"><span class="comment">#可选的值为latest, earliest, none</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-offset-reset=latest;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#以逗号分隔的主机：端口对列表，用于建立与Kafka群集的初始连接。</span></span><br><span class="line"><span class="string">spring.kafka.consumer.bootstrap-servers;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#ID在发出请求时传递给服务器;用于服务器端日志记录。</span></span><br><span class="line"><span class="string">spring.kafka.consumer.client-id;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果为true，则消费者的偏移量将在后台定期提交，默认值为true</span></span><br><span class="line"><span class="string">spring.kafka.consumer.enable-auto-commit=true;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果没有足够的数据立即满足“fetch.min.bytes”给出的要求，服务器在回答获取请求之前将阻塞的最长时间（以毫秒为单位）</span></span><br><span class="line"><span class="comment">#默认值为500</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-max-wait;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#服务器应以字节为单位返回获取请求的最小数据量，默认值为1，对应的kafka的参数为fetch.min.bytes。</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-min-size;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#用于标识此使用者所属的使用者组的唯一字符串。</span></span><br><span class="line"><span class="string">spring.kafka.consumer.group-id;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#心跳与消费者协调员之间的预期时间（以毫秒为单位），默认值为3000</span></span><br><span class="line"><span class="string">spring.kafka.consumer.heartbeat-interval;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#密钥的反序列化器类，实现类实现了接口org.apache.kafka.common.serialization.Deserializer</span></span><br><span class="line"><span class="string">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#值的反序列化器类，实现类实现了接口org.apache.kafka.common.serialization.Deserializer</span></span><br><span class="line"><span class="string">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#一次调用poll()操作时返回的最大记录数，默认值为500</span></span><br><span class="line"><span class="string">spring.kafka.consumer.max-poll-records;</span></span><br><span class="line"><span class="comment">#################consumer的配置参数（结束）#################</span></span><br><span class="line"><span class="comment">#################producer的配置参数（开始）#################</span></span><br><span class="line"><span class="comment">#procedure要求leader在考虑完成请求之前收到的确认数，用于控制发送记录在服务端的持久化，其值可以为如下：</span></span><br><span class="line"><span class="comment">#acks = 0 如果设置为零，则生产者将不会等待来自服务器的任何确认，该记录将立即添加到套接字缓冲区并视为已发送。在这种情况下，无法保证服务器已收到记录，并且重试配置将不会生效（因为客户端通常不会知道任何故障），为每条记录返回的偏移量始终设置为-1。</span></span><br><span class="line"><span class="comment">#acks = 1 这意味着leader会将记录写入其本地日志，但无需等待所有副本服务器的完全确认即可做出回应，在这种情况下，如果leader在确认记录后立即失败，但在将数据复制到所有的副本服务器之前，则记录将会丢失。</span></span><br><span class="line"><span class="comment">#acks = all 这意味着leader将等待完整的同步副本集以确认记录，这保证了只要至少一个同步副本服务器仍然存活，记录就不会丢失，这是最强有力的保证，这相当于acks = -1的设置。</span></span><br><span class="line"><span class="comment">#可以设置的值为：all, -1, 0, 1</span></span><br><span class="line"><span class="string">spring.kafka.producer.acks=1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#每当多个记录被发送到同一分区时，生产者将尝试将记录一起批量处理为更少的请求， </span></span><br><span class="line"><span class="comment">#这有助于提升客户端和服务器上的性能，此配置控制默认批量大小（以字节为单位），默认值为16384</span></span><br><span class="line"><span class="string">spring.kafka.producer.batch-size=16384</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#以逗号分隔的主机：端口对列表，用于建立与Kafka群集的初始连接</span></span><br><span class="line"><span class="string">spring.kafka.producer.bootstrap-servers</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#生产者可用于缓冲等待发送到服务器的记录的内存总字节数，默认值为33554432</span></span><br><span class="line"><span class="string">spring.kafka.producer.buffer-memory=33554432</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#ID在发出请求时传递给服务器，用于服务器端日志记录</span></span><br><span class="line"><span class="string">spring.kafka.producer.client-id</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#生产者生成的所有数据的压缩类型，此配置接受标准压缩编解码器（&#x27;gzip&#x27;，&#x27;snappy&#x27;，&#x27;lz4&#x27;），</span></span><br><span class="line"><span class="comment">#它还接受&#x27;uncompressed&#x27;以及&#x27;producer&#x27;，分别表示没有压缩以及保留生产者设置的原始压缩编解码器，</span></span><br><span class="line"><span class="comment">#默认值为producer</span></span><br><span class="line"><span class="string">spring.kafka.producer.compression-type=producer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#key的Serializer类，实现类实现了接口org.apache.kafka.common.serialization.Serializer</span></span><br><span class="line"><span class="string">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#值的Serializer类，实现类实现了接口org.apache.kafka.common.serialization.Serializer</span></span><br><span class="line"><span class="string">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果该值大于零时，表示启用重试失败的发送次数</span></span><br><span class="line"><span class="string">spring.kafka.producer.retries</span></span><br><span class="line"><span class="comment">#################producer的配置参数（结束）#################</span></span><br><span class="line"><span class="comment">#################listener的配置参数（结束）#################</span></span><br><span class="line"><span class="comment">#侦听器的AckMode,参见https://docs.spring.io/spring-kafka/reference/htmlsingle/#committing-offsets</span></span><br><span class="line"><span class="comment">#当enable.auto.commit的值设置为false时，该值会生效；为true时不会生效</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-mode;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#在侦听器容器中运行的线程数</span></span><br><span class="line"><span class="string">spring.kafka.listener.concurrency;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#轮询消费者时使用的超时（以毫秒为单位）</span></span><br><span class="line"><span class="string">spring.kafka.listener.poll-timeout;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#当ackMode为“COUNT”或“COUNT_TIME”时，偏移提交之间的记录数</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-count;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#当ackMode为“TIME”或“COUNT_TIME”时，偏移提交之间的时间（以毫秒为单位）</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-time;</span></span><br><span class="line"><span class="comment">#################listener的配置参数（结束）#################</span></span><br></pre></td></tr></table></figure>



<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a target="_blank" rel="noopener" href="https://www.codercto.com/a/29055.html">Kafka的Consumer负载均衡算法</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003985468">Kafka 高性能吞吐揭秘</a></p>
<p><a target="_blank" rel="noopener" href="https://kafka.apachecn.org/">kafka官方文档</a></p>
<h1 id="docker-安装kafka"><a href="#docker-安装kafka" class="headerlink" title="docker 安装kafka"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/11017000.html">docker 安装kafka</a></h1><p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/fenglibing/article/details/82117166">Spring Kafka中关于Kafka的配置参数 </a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35571554/article/details/82593159">关于消息队列Kafka的一些常见问题</a></p>
<p><a target="_blank" rel="noopener" href="http://matt33.com/2018/10/24/kafka-idempotent/">Kafka 事务性之幂等性实现</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.confluent.io/platform/current/quickstart/ce-docker-quickstart.html">Quick Start for Apache Kafka using Confluent Platform (Docker)</a></p>
<ul>
<li>***** <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137406991">Kafka-分区、片段、偏移量</a></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0414(kafka)/" data-id="cld1buvs30005bjop91a11spo" data-title="每日一问0414(kafka)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0421(分布式事务)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)/">每日一问0421(分布式事务)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>2pc,3pc,tcc</p>
<h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><h3 id="TX-LCN"><a href="#TX-LCN" class="headerlink" title="TX-LCN"></a>TX-LCN</h3><h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h4><p><img src="http://www.txlcn.org/img/docs/yuanli.png" alt="avatar"></p>
<p>有A，B，C 。A是发起方，BC两个业务方 ，另外还有协调器 TM，<br>A-&gt;加入协调器TM，-&gt;执行任务-&gt;调用业务B -&gt;业务B执行业务-&gt;执行结束 -&gt;加入TM，将结果返回A -&gt;A 继续执行 调用C-&gt;C 执行业务，-&gt;执行完加入TM，返回A -&gt;A 执行完业务 ，通知TM-&gt;TM 检查各个参与方，依次提交各个业务方，最终响应通知事务组。</p>
<h4 id="负载和集群配置"><a href="#负载和集群配置" class="headerlink" title="负载和集群配置"></a>负载和集群配置</h4><p>配置多台，随机选择一台做TM，告知其他模块都与它通讯，<br>当有一个不可用时，客户端会重试，重试不行则全部回滚。</p>
<h3 id="阿里GTS"><a href="#阿里GTS" class="headerlink" title="阿里GTS"></a>阿里GTS</h3><h3 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h3><h3 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h3><h3 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h3><ul>
<li>定时轮询</li>
<li>补偿</li>
<li>多台部署+随机选择TM</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.txlcn.org/zh-cn/docs/preface.html">TX-LCN</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0421(%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1)/" data-id="cld1buvs40006bjopck7m0i1a" data-title="每日一问0421(分布式事务)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/每日一问0425(流)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0425(%E6%B5%81)/" class="article-date">
  <time class="dt-published" datetime="2023-01-18T07:13:14.734Z" itemprop="datePublished">2023-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/2020/">2020</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0425(%E6%B5%81)/">每日一问0425(流)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><ol>
<li>Java面向对象三大特性：封装，继承，多态</li>
<li>String ,StringBuffer,Stringbuilder 区别</li>
</ol>
<ul>
<li>String 是final 每次都会实例化，频繁操作字符串避免用String</li>
<li>StringBuffer 和Stringbuilder 是 char[]</li>
<li>StringBUffer 加了同步锁 是线程安全的,Stringbuilder没有</li>
</ul>
<p>3 接口和抽象类</p>
<p>一个类能实现多个接口，只能实现一个抽象类</p>
<ol start="4">
<li>一个线程的几种状态</li>
</ol>
<p>1.新建，可运行，运行中，阻塞，等待，超时等待，终止</p>
<p>5.异常 error 和 exception</p>
<ul>
<li><p>error 程序处理不了的，比如JVM 内存溢出</p>
</li>
<li><p>exception 程序本身可以处理的</p>
</li>
</ul>
<ol start="6">
<li>JavaIO流分类： 字节流，字符流</li>
</ol>
<ul>
<li>reader&#x2F;writer 字符</li>
<li>inputStream&#x2F;outputStream 字节</li>
<li>字节流最小粒度 容易乱码</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://a240277805.github.io/2023/01/18/2020/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0425(%E6%B5%81)/" data-id="cld1buvs50007bjoph3lc13kc" data-title="每日一问0425(流)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2019/">2019</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2020/">2020</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2021/">2021</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/2022/">2022</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD/">学习英语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93/">快速通道</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%84%E5%BD%B1/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9F%B3%E4%B9%90/">音乐</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0303(Spring%E4%BA%AE%E7%9C%BC%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7)/">每日一问0303(Spring亮眼代码技巧)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0323(gateway)/">每日一问0323(gateway)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0326(%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA)/">每日一问0326(链路追踪)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0328(PorlarDB)/">每日一问0328(PorlarDB)</a>
          </li>
        
          <li>
            <a href="/2023/01/18/2021/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE0329(%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)/">每日一问0329(传输协议)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>